[
    {
        "rule_id": "PRE30-C",
        "rule_title": "Do not create a universal character name through concatenation",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/PRE30-C.+Do+not+create+a+universal+character+name+through+concatenation",
        "content": "The C Standard supports universal character names that may be used in identifiers, character constants, and string literals to designate characters that are not in the basic character set. The universal character name \\Unnnnnnnn designates the character whose 8-digit short identifier (as specified by ISO/IEC 10646) is nnnnnnnn. Similarly, the universal character name \\unnnn designates the character whose 4-digit short identifier is nnnn (and whose 8-digit short identifier is 0000nnnn).\nThe C Standard, 5.1.1.2, paragraph 4 [ISO/IEC 9899:2024], says\nIf a character sequence that matches the syntax of a universal character name is produced by token concatenation (6.10.5.3), the behavior is undefined.\nSee also undefined behavior 3.\nIn general, avoid universal character names in identifiers unless absolutely necessary.\nNoncompliant Code Example\nThis code example is noncompliant because it produces a universal character name by token concatenation:\n#define assign(uc1, uc2, val) uc1##uc2 = val\n void func(void) {\n  int \\u0401;\n  /* ... */\n  assign(\\u04, 01, 4);\n  /* ... */\n}\nImplementation Details\nThis code compiles and runs with Microsoft Visual Studio 2013, assigning 4 to the variable as expected.\nGCC 4.8.1 on Linux refuses to compile this code; it emits a diagnostic reading, \"stray '\\' in program,\" referring to the universal character fragment in the invocation of the assign macro.\nCompliant Solution\nThis compliant solution uses a universal character name but does not create it by using token concatenation:\n#define assign(ucn, val) ucn = val\n  void func(void) {\n  int \\u0401;\n  /* ... */\n  assign(\\u0401, 4);\n  /* ... */\n}\nRisk Assessment\nCreating a universal character name through token concatenation results in undefined behavior. See undefined behavior 3.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPRE30-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nuniversal-character-name-concatenation\nFully implemented\nAxivion Bauhaus Suite\n7.2.0\nCertC-PRE30 Fully implemented\nCodeSonar\n9.1p0\nLANG.PREPROC.PASTE\nLANG.PREPROC.PASTEHASH Macro uses ## operator\n## follows # operator\nCppcheck\n 2.15\npreprocessorErrorDirective\nCppcheck Premium\n24.11.0\npreprocessorErrorDirective\nHelix QAC\n2025.2\nC0905 \nC++0064,C++0080\nFully implemented\nKlocwork\n2025.2\nMISRA.DEFINE.SHARP\nFully implemented\nLDRA tool suite\n9.7.1\n573 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-PRE30-a Avoid token concatenation that may produce universal character names\nPolyspace Bug Finder\nR2025b\nCERT C: Rule PRE30-C Checks for universal character name from token concatenation (rule fully covered)\nRuleChecker\n24.04\nuniversal-character-name-concatenation\nFully checked\nSecurity Reviewer - Static Reviewer\n6.02\nRTOS_27 Fully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 10646-2003]\n[ISO/IEC 9899:2024] Subclause 5.1.1.2, \"Translation Phases\"",
        "language": "C"
    },
    {
        "rule_id": "PRE31-C",
        "rule_title": "Avoid side effects in arguments to unsafe macros",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/PRE31-C.+Avoid+side+effects+in+arguments+to+unsafe+macros",
        "content": "An unsafe function-like macro is one whose expansion results in evaluating one of its parameters more than once or not at all. Never invoke an unsafe macro with arguments containing an assignment, increment, decrement, volatile access, input/output, or other expressions with side effects (including function calls, which may cause side effects).\nThe documentation for unsafe macros should warn against invoking them with arguments with side effects, but the responsibility is on the programmer using the macro. Because of the risks associated with their use, it is recommended that the creation of unsafe function-like macros be avoided. (See PRE00-C. Prefer inline or static functions to function-like macros.)\nThis rule is similar to EXP44-C. Do not rely on side effects in operands to sizeof, _Alignof, or _Generic.\nNoncompliant Code Example\nOne problem with unsafe macros is side effects on macro arguments, as shown by this noncompliant code example:\n#define ABS(x) (((x) < 0) ? -(x) : (x))\n  void func(int n) {\n  /* Validate that n is within the desired range */\n  int m = ABS(++n);\n   /* ... */\n}\nThe invocation of the ABS() macro in this example expands to\nm = (((++n) < 0) ? -(++n) : (++n));\nThe resulting code is well defined but causes n to be incremented twice rather than once.\nCompliant Solution\nIn this compliant solution, the increment operation ++n is performed before the call to the unsafe macro.\n#define ABS(x) (((x) < 0) ? -(x) : (x)) /* UNSAFE */\n  void func(int n) {\n  /* Validate that n is within the desired range */\n  ++n;\n  int m = ABS(n);\n   /* ... */\n}\nNote the comment warning programmers that the macro is unsafe. The macro can also be renamed ABS_UNSAFE() to make it clear that the macro is unsafe. This compliant solution, like all the compliant solutions for this rule, has undefined behavior (see  undefined behavior 36) if the argument to ABS() is equal to the minimum (most negative) value for the signed integer type. (See INT32-C. Ensure that operations on signed integers do not result in overflow for more information.)\nCompliant Solution\nThis compliant solution follows the guidance of PRE00-C. Prefer inline or static functions to function-like macros by defining an inline function iabs() to replace the ABS() macro. Unlike the ABS() macro, which operates on operands of any type, the iabs() function will truncate arguments of types wider than int whose value is not in range of the latter type.\n#include <complex.h>\n#include <math.h>\n  static inline int iabs(int x) {\n  return (((x) < 0) ? -(x) : (x));\n}\n  void func(int n) {\n  /* Validate that n is within the desired range */\n int m = iabs(++n);\n   /* ... */\n}\nCompliant Solution\nA more flexible compliant solution is to declare the ABS() macro using a _Generic selection. To support all arithmetic data types, this solution also makes use of inline functions to compute integer absolute values. (See PRE00-C. Prefer inline or static functions to function-like macros and PRE12-C. Do not define unsafe macros.)\nAccording to the C Standard, 6.5.2.1, paragraph 3 [ISO/IEC 9899:2024]:\nThe controlling expression of a generic selection is not evaluated. If a generic selection has a generic association with a type name that is compatible with the type of the controlling expression, then the result expression of the generic selection is the expression in that generic association. Otherwise, the result expression of the generic selection is the expression in the default generic association. None of the expressions from any other generic association of the generic selection is evaluated. \nBecause the expression is not evaluated as part of the generic selection, the use of a macro in this solution is guaranteed to evaluate the macro parameter v only once.\n#include <complex.h>\n#include <math.h>\n  static inline long long llabs(long long v) {\n  return v < 0 ? -v : v;\n}\nstatic inline long labs(long v) {\n  return v < 0 ? -v : v;\n}\nstatic inline int iabs(int v) {\n  return v < 0 ? -v : v;\n}\nstatic inline int sabs(short v) {\n  return v < 0 ? -v : v;\n}\nstatic inline int scabs(signed char v) {\n  return v < 0 ? -v : v;\n}\n  #define ABS(v)  _Generic(v, signed char : scabs, \\\n                            short : sabs, \\\n                            int : iabs, \\\n                            long : labs, \\\n                            long long : llabs, \\\n                            float : fabsf, \\\n                            double : fabs, \\\n                            long double : fabsl, \\\n                            double complex : cabs, \\\n                            float complex : cabsf, \\\n                            long double complex : cabsl)(v)\n  void func(int n) {\n  /* Validate that n is within the desired range */\n  int m = ABS(++n);\n  /* ... */\n}\nGeneric selections were introduced in C11 and are not available in C99 and earlier editions of the C Standard.\nCompliant Solution (GCC)\nGCC's __typeof extension makes it possible to declare and assign the value of the macro operand to a temporary of the same type and perform the computation on the temporary, consequently guaranteeing that the operand will be evaluated exactly once. Another GCC extension, known as statement expression, makes it possible for the block statement to appear where an expression is expected:\n#define ABS(x) __extension__ ({ __typeof (x) tmp = x; \\\n                    tmp < 0 ? -tmp : tmp; })\nNote that relying on such extensions makes code nonportable and violates MSC14-C. Do not introduce unnecessary platform dependencies.\nNoncompliant Code Example (assert())\nThe assert() macro is a convenient mechanism for incorporating diagnostic tests in code. (See MSC11-C. Incorporate diagnostic tests using assertions.) Expressions used as arguments to the standard assert() macro should not have side effects. The behavior of the assert() macro depends on the definition of the object-like macro NDEBUG. If the macro NDEBUG is undefined, the assert() macro is defined to evaluate its expression argument and, if the result of the expression compares equal to 0, call the abort() function. If NDEBUG is defined, assert is defined to expand to ((void)0). Consequently, the expression in the assertion is not evaluated, and no side effects it may have had otherwise take place in non-debugging executions of the code.\nThis noncompliant code example includes an assert() macro containing an expression (index++) that has a side effect:\n#include <assert.h>\n#include <stddef.h>\n   void process(size_t index) {\n  assert(index++ > 0); /* Side effect */\n  /* ... */\n}\nCompliant Solution (assert())\nThis compliant solution avoids the possibility of side effects in assertions by moving the expression containing the side effect outside of the assert() macro.\n#include <assert.h>\n#include <stddef.h>\n   void process(size_t index) {\n  assert(index > 0); /* No side effect */\n  ++index;\n  /* ... */\n}\nExceptions\nPRE31-C-EX1: An exception can be made for invoking an unsafe macro with a function call argument provided that the function has no side effects. However, it is easy to forget about obscure side effects that a function might have, especially library functions for which source code is not available; even changing errno is a side effect. Unless the function is user-written and does nothing but perform a computation and return its result without calling any other functions, it is likely that many developers will forget about some side effect. Consequently, this exception must be used with great care.\nRisk Assessment\nInvoking an unsafe macro with an argument that has side effects may cause those side effects to occur more than once. This practice can lead to unexpected program behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPRE31-C\nLow\nUnlikely\nNo\nYes\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nexpanded-side-effect-multiplied\nexpanded-side-effect-not-evaluated\nside-effect-not-expanded\nPartially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-PRE31 Fully implemented\nCodeSonar\n9.1p0\nLANG.PREPROC.FUNCMACRO\nLANG.STRUCT.SE.DEC\nLANG.STRUCT.SE.INC\nFunction-Like Macro\nSide Effects in Expression with Decrement\nSide Effects in Expression with Increment\nCoverity\n2017.07\nASSERT_SIDE_EFFECTS\nPartially implemented\nCan detect the specific instance where assertion contains an operation/function call that may have a side effect\nCppcheck Premium \n24.11.0\npremium-cert-pre31-c\nECLAIR\n1.2\nCC2.EXP31\nCC2.PRE31 Fully implemented\nHelix QAC\n2025.2\nC3462, C3463, C3464,C3465,C3466,C3467\nC++3225, C++3226, C++3227, C++3228, C++3229 \nFully implemented\nKlocwork\n2025.2\nPORTING.VAR.EFFECTS Fully implemented\nLDRA tool suite\n9.7.1\n9 S, 562 S, 572 S, 35 D, 1 Q\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-PRE31-b\nCERT_C-PRE31-c\nCERT_C-PRE31-d\nAssertions should not contain assignments, increment, or decrement operators\nAssertions should not contain function calls nor function-like macro calls\nAvoid side effects in arguments to unsafe macros\nPC-lint Plus\n1.4\n666, 2666\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule PRE31-C\nChecks for side effect in arguments to unsafe macro (rule partially covered)\n\nRuleChecker\n24.04\nexpanded-side-effect-multiplied\nexpanded-side-effect-not-evaluated\nside-effect-not-expanded\nPartially checked\nSecurity Reviewer - Static Reviewer\n6.02\nRTOS_28\nFully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nBibliography\n[Dewhurst 2002] Gotcha #28, \"Side Effects in Assertions\"\n[ISO/IEC 9899:2024] Subclause 6.5.2.1, \"Generic Selection\" \n[Plum 1985] Rule 1-11",
        "language": "C"
    },
    {
        "rule_id": "PRE32-C",
        "rule_title": "Do not use preprocessor directives in invocations of function-like macros",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/PRE32-C.+Do+not+use+preprocessor+directives+in+invocations+of+function-like+macros",
        "content": "The arguments to a macro must not include preprocessor directives, such as #define, #ifdef, and #include. Doing so results in undefined behavior, according to the C Standard, 6.10.5, paragraph 11 [ISO/IEC 9899:2024]:\nThe sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of arguments for the function-like macro. The individual arguments within the list are separated by comma preprocessing tokens, but comma preprocessing tokens between matching inner parentheses do not separate arguments. If there are sequences of preprocessing tokens within the list of arguments that would otherwise act as preprocessing directives, the behavior is undefined.\nSee also undefined behavior 92.\nThis rule also applies to the use of preprocessor directives in arguments to any function where it is unknown whether or not the function is implemented using a macro. This includes all standard library functions, such as memcpy(), printf(), and assert(), because any standard library function may be implemented as a macro. (C24, 7.1.4, paragraph 1).\nNoncompliant Code Example\nIn this noncompliant code example [GCC Bugs], the programmer uses preprocessor directives to specify platform-specific arguments to memcpy(). However, if memcpy() is implemented using a macro, the code results in undefined behavior 92.\n#include <string.h>\n  void func(const char *src) {\n  /* Validate the source string; calculate size */\n  char *dest;\n  /* malloc() destination string */\n  memcpy(dest, src,\n    #ifdef PLATFORM1\n      12\n    #else\n      24\n    #endif\n  );\n  /* ... */\n}\nCompliant Solution\nIn this compliant solution [GCC Bugs], the appropriate call to memcpy() is determined outside the function call:\n#include <string.h>\n void func(const char *src) {\n  /* Validate the source string; calculate size */\n  char *dest;\n  /* malloc() destination string */ \n  #ifdef PLATFORM1\n    memcpy(dest, src, 12);\n  #else\n    memcpy(dest, src, 24);\n  #endif\n  /* ... */\n}\nRisk Assessment\nIncluding preprocessor directives in macro arguments is undefined behavior 92.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPRE32-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nmacro-argument-hash Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-PRE32 Fully implemented\nCodeSonar\n9.1p0\nLANG.PREPROC.MACROARG Preprocessing directives in macro argument\nECLAIR\n1.2\nCC2.PRE32\nFully implemented\nHelix QAC\n2025.2\nC0853\nC++1072\nFully implemented\nKlocwork\n2025.2\nMISRA.EXPANSION.DIRECTIVE Fully implemented\nLDRA tool suite\n9.7.1\n341 S Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-PRE32-a\nArguments to a function-like macro shall not contain tokens that look like preprocessing directives\nPC-lint Plus\n1.4\n436, 9501\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule PRE32-C Checks for preprocessor directive in macro argument (rule fully covered)\nRuleChecker\n24.04\nmacro-argument-hash Fully checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[GCC Bugs] \"Non-bugs\"\n[ISO/IEC 9899:2024] 6.10.5, \"Macro Replacement\"",
        "language": "C"
    },
    {
        "rule_id": "DCL00-C",
        "rule_title": "Const-qualify immutable objects",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL00-C.+Const-qualify+immutable+objects",
        "content": "Immutable objects should be const-qualified. Enforcing object immutability using const qualification helps ensure the correctness and security of applications. ISO/IEC TR 24772, for example, recommends labeling parameters as constant to avoid the unintentional modification of function arguments [ISO/IEC TR 24772]. STR05-C. Use pointers to const when referring to string literals describes a specialized case of this recommendation.\nAdding const qualification may propagate through a program; as you add const, qualifiers become still more necessary. This phenomenon is sometimes called const poisoning, which can frequently lead to violations of EXP05-C. Do not cast away a const qualification. Although const qualification is a good idea, the costs may outweigh the value in the remediation of existing code.\nA macro or an enumeration constant may also be used instead of a const-qualified object. DCL06-C. Use meaningful symbolic constants to represent literal values describes the relative merits of using const-qualified objects, enumeration constants, and object-like macros. However, adding a const qualifier to an existing variable is a better first step than replacing the variable with an enumeration constant or macro because the compiler will issue warnings on any code that changes your const-qualified variable. Once you have verified that a const-qualified variable is not changed by any code, you may consider changing it to an enumeration constant or macro, as best fits your design.\nNoncompliant Code Example\nIn this noncompliant code, pi is declared as a float. Although pi is a mathematical constant, its value is not protected from accidental modification.\nfloat pi = 3.14159f;\nfloat degrees;\nfloat radians;\n/* ... */\nradians = degrees * pi / 180;\nCompliant Solution\nIn this compliant solution, pi is declared as a const-qualified object:\nconst float pi = 3.14159f;\nfloat degrees;\nfloat radians;\n/* ... */\nradians = degrees * pi / 180;\nRisk Assessment\nFailing to const-qualify immutable objects can result in a constant being modified at runtime.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL00-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nparameter-missing-const Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL00\nCodeSonar\n9.1p0\nLANG.CAST.PC.CRCQ\nLANG.TYPE.VCBC\nLANG.STRUCT.RPNTC\nCast removes const qualifier\nVariable Could Be const\nReturned Pointer Not Treated as const\nCompass/ROSE\n\n\n\nECLAIR\n1.2\nCC2.DCL00\nPartially implemented\nHelix QAC\n2025.2\nC3204, C3227, C3232, C3673, C3677\n\nLDRA tool suite\n9.7.1\n78 D\n93 D\n200 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-DCL00-a\nCERT_C-DCL00-b\nDeclare local variable as const whenever possible\nDeclare parameters as const whenever possible\nPC-lint Plus\n1.4\n953\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: DCL00-C Checks for unmodified variable not const-qualified (rule fully covered).\nRuleChecker\n24.04\nparameter-missing-const Partially checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID DCL00-CPP. Const-qualify immutable objects\n Bibliography\n[Dewhurst 2002] Gotcha #25, \"#define Literals\"\n[Saks 2000]",
        "language": "C"
    },
    {
        "rule_id": "DCL30-C",
        "rule_title": "Declare objects with appropriate storage durations",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL30-C.+Declare+objects+with+appropriate+storage+durations",
        "content": "Every object has a storage duration that determines its lifetime: static, thread, automatic, or allocated.\nAccording to the C Standard, 6.2.4, paragraph 2 [ISO/IEC 9899:2024],\nThe lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address, and retains its last-stored value throughout its lifetime. If an object is referred to outside of its lifetime, the behavior is undefined. If a pointer value is used in an evaluation after the object the pointer points to (or just past) reaches the end of its lifetime, the behavior is undefined.\nDo not attempt to access an object outside of its lifetime. Attempting to do so is undefined behavior and can lead to an exploitable vulnerability. (See also undefined behavior 9 in the C Standard, Annex J.)\nNoncompliant Code Example (Differing Storage Durations)\nIn this noncompliant code example, the address of the variable c_str with automatic storage duration is assigned to the variable p, which has static storage duration. The assignment itself is valid, but it is invalid for c_str to go out of scope while p holds its address, as happens at the end of dont_do_this().\n#include <stdio.h>\n  const char *p;\nvoid dont_do_this(void) {\n  const char c_str[] = \"This will change\";\n  p = c_str; /* Dangerous */\n}\n void innocuous(void) {\n  printf(\"%s\\n\", p);\n}\n int main(void) {\n  dont_do_this();\n  innocuous();\n  return 0;\n}\nCompliant Solution (Same Storage Durations)\nIn this compliant solution, p is declared with the same storage duration as c_str, preventing p from taking on an indeterminate value outside of this_is_OK():\nvoid this_is_OK(void) {\n  const char c_str[] = \"Everything OK\";\n  const char *p = c_str;\n  /* ... */\n}\n/* p is inaccessible outside the scope of string c_str */\nAlternatively, both p and c_str could be declared with static storage duration.\nCompliant Solution (Differing Storage Durations)\nIf it is necessary for p to be defined with static storage duration but c_str with a more limited duration, then p can be set to NULL before c_str is destroyed. This practice prevents p from taking on an indeterminate value, although any references to p must check for NULL.\nconst char *p;\nvoid is_this_OK(void) {\n  const char c_str[] = \"Everything OK?\";\n  p = c_str;\n  /* ... */\n  p = NULL;\n}\nNoncompliant Code Example (Return Values)\nIn this noncompliant code sample, the function init_array() returns a pointer to a character array with automatic storage duration, which is accessible to the caller:\nchar *init_array(void) {\n  char array[10];\n  /* Initialize array */\n  return array;\n}\nSome compilers generate a diagnostic message when a pointer to an object with automatic storage duration is returned from a function, as in this example. Programmers should compile code at high warning levels and resolve any diagnostic messages. (See MSC00-C. Compile cleanly at high warning levels.)\nCompliant Solution (Return Values)\nThe solution, in this case, depends on the intent of the programmer. If the intent is to modify the value of array and have that modification persist outside the scope of init_array(), the desired behavior can be achieved by declaring array elsewhere and passing it as an argument to init_array():\n#include <stddef.h>\nvoid init_array(char *array, size_t len) {\n  /* Initialize array */\n  return;\n}\n int main(void) {\n  char array[10];\n  init_array(array, sizeof(array) / sizeof(array[0]));\n  /* ... */\n  return 0;\n}\nNoncompliant Code Example (Output Parameter)\nIn this noncompliant code example, the function squirrel_away() stores a pointer to local variable local into a location pointed to by function parameter ptr_param. Upon the return of squirrel_away(), the pointer ptr_param points to a variable that has an expired lifetime.\nvoid squirrel_away(char **ptr_param) {\n  char local[10];\n  /* Initialize array */\n  *ptr_param = local;\n}\n void rodent(void) {\n  char *ptr;\n  squirrel_away(&ptr);\n  /* ptr is live but invalid here */\n}\nCompliant Solution (Output Parameter)\nIn this compliant solution, the variable local has static storage duration; consequently, ptr can be used to reference the local array within the rodent() function:\nchar local[10];\n  void squirrel_away(char **ptr_param) {\n  /* Initialize array */\n  *ptr_param = local;\n}\n void rodent(void) {\n  char *ptr;\n  squirrel_away(&ptr);\n  /* ptr is valid in this scope */\n}\nRisk Assessment\nReferencing an object outside of its lifetime can result in an attacker being able to execute arbitrary code.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL30-C\nHigh\nProbable\nNo\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\npointered-deallocation\nreturn-reference-local\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL30 Fully implemented\nCodeSonar\n9.1p0\nLANG.STRUCT.RPL Returns pointer to local\nCompass/ROSE\n\nCan detect violations of this rule. It automatically detects returning pointers to local variables. Detecting more general cases, such as examples where static pointers are set to local variables which then go out of scope, would be difficult\nCoverity\n2017.07\nRETURN_LOCAL\nFinds many instances where a function will return a pointer to a local stack variable. Coverity Prevent cannot discover all violations of this rule, so further verification is necessary\nCppcheck\n 2.15\ndanglingLifetime\nreturnDanglingLifetime\nautoVariables\ninvalidLifetime\n\nCppcheck Premium\n24.11.0\ndanglingLifetime\nreturnDanglingLifetime\nautoVariables\ninvalidLifetime\n\nHelix QAC\n2025.2\nC3217, C3225, C3230, C4140\nC++2515, C++2516, C++2527, C++2528, C++4026, C++4624, C++4629\nFully implemented\nKlocwork\n2025.2\nLOCRET.ARG\nLOCRET.GLOB\nLOCRET.RET Fully implemented\nLDRA tool suite\n9.7.1\n42 D, 77 D, 71 S, 565 S\nEnhanced Enforcement\nParasoft C/C++test\n2024.2\nCERT_C-DCL30-a\nCERT_C-DCL30-b\nThe address of an object with automatic storage shall not be returned from a function\nThe address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist\nPC-lint Plus\n1.4\n604, 674, 733, 789\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule DCL30-C\n\nChecks for pointer or reference to stack variable leaving scope (rule fully covered)\nPVS-Studio\n7.38\nV506, V507, V558, V623, V723, V738\n\nRuleChecker\n24.04\nreturn-reference-local\nPartially checked\nSecurity Reviewer - Static Reviewer\n6.02\nC18\nC176\nC177\nC178\nC179\nFully implemented\nSplint\n3.1.1\n\n\nTrustInSoft Analyzer\n1.38\ndangling_pointer\nExhaustively detects undefined behavior (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard MSC00-C. Compile cleanly at high warning levels Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C EXP54-CPP. Do not access an object outside of its lifetime Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Dangling References to Stack Frames [DCM] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Escaping of the address of an automatic object [addrescape] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 18.6 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-562 and DCL30-C\nDCL30-C = Union( CWE-562, list) where list =\n\nAssigning a stack pointer to an argument (thereby letting it outlive the current function\n\nBibliography\n[Coverity 2007]\n[ISO/IEC 9899:2024] 6.2.4, \"Storage Durations of Objects\"",
        "language": "C"
    },
    {
        "rule_id": "DCL31-C",
        "rule_title": "Declare identifiers before using them",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL31-C.+Declare+identifiers+before+using+them",
        "content": "The C23 Standard requires type specifiers and forbids implicit function declarations. The C90 Standard allows implicit typing of variables and functions. Consequently, some existing legacy code uses implicit typing. Some C compilers still support legacy code by allowing implicit typing, but it should not be used for new code. Such an implementation may choose to assume an implicit declaration and continue translation to support existing programs that used this feature.\nNoncompliant Code Example (Implicit int)\nC no longer allows the absence of type specifiers in a declaration. The C Standard, 6.7.3 paragraph 2 [ ISO/IEC 9899:2024 ], states\nExcept where the type is inferred (6.7.10), at least one type specifier shall be given in the declaration specifiers in each declaration, and in the specifier-qualifier list in each member declaration and type name.\nThis noncompliant code example omits the type specifier:\nextern foo;\nSome C implementations do not issue a diagnostic for the violation of this constraint. These nonconforming C translators continue to treat such declarations as implying the type int.\nCompliant Solution (Implicit int)\nThis compliant solution explicitly includes a type specifier:\nextern int foo;\nNoncompliant Code Example (Implicit Function Declaration)\nImplicit declaration of functions is not allowed; every function must be explicitly declared before it can be called. In C90, if a function is called without an explicit prototype, the compiler provides an implicit declaration.\nThe C90 Standard [ISO/IEC 9899:1990] includes this requirement:\nIf the expression that precedes the parenthesized argument list in a function call consists solely of an identifier, and if no declaration is visible for this identifier, the identifier is implicitly declared exactly as if, in the innermost block containing the function call, the declaration extern int identifier(); appeared.\nIf a function declaration is not visible at the point at which a call to the function is made, C90-compliant platforms assume an implicit declaration of extern int identifier();.\nThis declaration implies that the function may take any number and type of arguments and return an int. However, to conform to the current C Standard, programmers must explicitly prototype every function before invoking it. An implementation that conforms to the C Standard may or may not perform implicit function declarations, but C does require a conforming implementation to issue a diagnostic if it encounters an undeclared function being used.\nIn this noncompliant code example, if malloc() is not declared, either explicitly or by including stdlib.h, a compiler that conforms only to C90 may implicitly declare malloc() as int malloc(). If the platform's size of int is 32 bits, but the size of pointers is 64 bits, the resulting pointer would likely be truncated as a result of the implicit declaration of malloc(), returning a 32-bit integer.\n#include <stddef.h>\n/* #include <stdlib.h> is missing */\n \nint main(void) {\n  for (size_t i = 0; i < 100; ++i) {\n    /* int malloc() assumed */\n    char *ptr = (char *)malloc(0x10000000);\n    *ptr = 'a';\n  }\n  return 0;\n}\nImplementation Details\nWhen compiled with Microsoft Visual Studio 2013 for a 64-bit platform, this noncompliant code example will eventually cause an access violation when dereferencing ptr in the loop.\nCompliant Solution (Implicit Function Declaration)\nThis compliant solution declares malloc() by including the appropriate header file:\n#include <stdlib.h>\n \nint main(void) {\n  for (size_t i = 0; i < 100; ++i) {\n    char *ptr = (char *)malloc(0x10000000);\n    *ptr = 'a';\n  }\n  return 0;\n}\nFor more information on function declarations, see DCL07-C. Include the appropriate type information in function declarators.\nNoncompliant Code Example (Implicit Return Type)\nDo not declare a function with an implicit return type. For example, if a function returns a meaningful integer value, declare it as returning int. If it returns no meaningful value, declare it as returning void.\n#include <limits.h>\n#include <stdio.h>\n \nfoo(void) {\n  return UINT_MAX;\n}\n\nint main(void) {\n  long long int c = foo();\n  printf(\"%lld\\n\", c);\n  return 0;\n}\nBecause the compiler assumes that foo() returns a value of type int for this noncompliant code example, UINT_MAX is incorrectly converted to \u22121.\nCompliant Solution (Implicit Return Type)\nThis compliant solution explicitly defines the return type of foo() as unsigned int. As a result, the function correctly returns UINT_MAX .\n#include <limits.h>\n#include <stdio.h>\n\nunsigned int foo(void) {\n  return UINT_MAX;\n}\n\nint main(void) {\n  long long int c = foo();\n  printf(\"%lld\\n\", c);\n  return 0;\n}\nRisk Assessment\nBecause implicit declarations lead to less stringent type checking, they can introduce unexpected and erroneous behavior. Occurrences of an omitted type specifier in existing code are rare, and the consequences are generally minor, perhaps resulting in abnormal program termination.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL31-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ntype-specifier\nfunction-return-type\nimplicit-function-declaration\nundeclared-parameter\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL31 Fully implemented\nClang\n3.9\n-Wimplicit-int\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nMISRA C 2012 Rule 8.1 Implemented\nCppcheck Premium\n24.11.0\npremium-cert-dcl31-c\nECLAIR\n1.2\nCC2.DCL31\nFully implemented\nGCC\n4.3.5\n\nCan detect violations of this rule when the -Wimplicit and -Wreturn-type flags are used\nHelix QAC\n2025.2\nC0434, C2050, C2051, C3335 Fully implemented\nKlocwork\n2025.2\nCWARN.IMPLICITINT\nMISRA.DECL.NO_TYPE\nMISRA.FUNC.NOPROT.CALL\nRETVOID.IMPLICIT\nFully implemented\nLDRA tool suite\n9.7.1\n24 D, 41 D, 20 S, 326 S, 496 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-DCL31-a\nAll functions shall be declared before use\nPC-lint Plus\n1.4\n601, 718, 746, 808\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule DCL31-C\n\nChecks for:\nTypes not explicitly specified\nImplicit function declaration\nRule fully covered.\nPVS-Studio\n7.38\nV1031\nSecurity Reviewer - Static Reviewer\n6.02\nC19 Fully implemented\nSonarQube C/C++ Plugin\n3.11\nS819, S820   Partially implemented; implicit return type not covered.\nRuleChecker\n24.04\ntype-specifier\nfunction-return-type\nimplicit-function-declaration\nundeclared-parameter\nFully checked\nTrustInSoft Analyzer\n1.38\ntype specifier missing\nPartially verified (exhaustively detects undefined behavior).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard DCL07-C. Include the appropriate type information in function declarators Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Subprogram Signature Mismatch [OTR] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 8.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:1990]\n[ISO/IEC 9899:2024] Subclause 6.7.3, \"Type Specifiers\"\n[Jones 2008]",
        "language": "C"
    },
    {
        "rule_id": "DCL36-C",
        "rule_title": "Do not declare an identifier with conflicting linkage classifications",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL36-C.+Do+not+declare+an+identifier+with+conflicting+linkage+classifications",
        "content": "Linkage can make an identifier declared in different scopes or declared multiple times within the same scope refer to the same object or function. Identifiers are classified as externally linked, internally linked, or not linked. These three kinds of linkage have the following characteristics [Kirch-Prinz 2002]:\nExternal linkage: An identifier with external linkage represents the same object or function throughout the entire program, that is, in all compilation units and libraries belonging to the program. The identifier is available to the linker. When a second declaration of the same identifier with external linkage occurs, the linker associates the identifier with the same object or function.\nInternal linkage: An identifier with internal linkage represents the same object or function within a given translation unit. The linker has no information about identifiers with internal linkage. Consequently, these identifiers are internal to the translation unit.\nNo linkage: If an identifier has no linkage, then any further declaration using the identifier declares something new, such as a new variable or a new type.\nAccording to the C Standard, 6.2.2 paragraph 3 [ISO/IEC 9899:2024], linkage is determined as follows:\nIf the declaration of a file scope identifier for:\n    - an object contains any of the storage-class specifiers static  or contexpr;\n    - or, a function contains the storage-class specifier static,\n then the identifier has internal linkage.\nFor an identifier declared with the storage-class specifier extern in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the linkage of the identifier at the later declaration is the same as the linkage specified at the prior declaration. If no prior declaration is visible, or if the prior declaration specifies no linkage, then the identifier has external linkage.\nIf the declaration of an identifier for a function has no storage-class specifier, its linkage is determined exactly as if it were declared with the storage-class specifier extern. If the declaration of an identifier for an object has file scope and does not contain the storage-class specifier static or contexpr, its linkage is external.\nThe following identifiers have no linkage: an identifier declared to be anything other than an object or a function; an identifier declared to be a function parameter; a block scope identifier for an object declared without the storage-class specifier extern.\n\nUse of an identifier (within one translation unit) classified as both internally and externally linked is undefined behavior. (See also undefined behavior 8.) A translation unit includes the source file together with its headers and all source files included via the preprocessing directive #include.\nThe following table identifies the linkage assigned to an object that is declared twice in a single translation unit. The column designates the first declaration, and the row designates the redeclaration.\nNoncompliant Code Example\nIn this noncompliant code example, i2 and i5 are defined as having both internal and external linkage. Future use of either identifier results in undefined behavior 8.\nint i1 = 10;         /* Definition, external linkage */\nstatic int i2 = 20;  /* Definition, internal linkage */\nextern int i3 = 30;  /* Definition, external linkage */\nint i4;              /* Tentative definition, external linkage */\nstatic int i5;       /* Tentative definition, internal linkage */\n\nint i1;  /* Valid tentative definition */\nint i2;  /* Undefined, linkage disagreement with previous */\nint i3;  /* Valid tentative definition */\nint i4;  /* Valid tentative definition */\nint i5;  /* Undefined, linkage disagreement with previous */\n\nint main(void) {\n  /* ... */\n  return 0;\n}\nImplementation Details\nMicrosoft Visual Studio 2013 issues no warnings about this code, even at the highest diagnostic levels.\nGCC and Clang 14 both generate fatal diagnostics for the conflicting definitions of i2 and i5.\nCompliant Solution\nThis compliant solution does not include conflicting definitions:\nint i1 = 10;         /* Definition, external linkage */\nstatic int i2 = 20;  /* Definition, internal linkage */\nextern int i3 = 30;  /* Definition, external linkage */\nint i4;              /* Tentative definition, external linkage */\nstatic int i5;       /* Tentative definition, internal linkage */\n\nint main(void) {\n  /* ... */\n  return 0;\n}\nRisk Assessment\nUse of an identifier classified as both internally and externally linked is undefined behavior 8.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL36-C\nMedium\nProbable\nYes\nNo\nP8\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nstatic-function-declaration\nstatic-object-declaration\nPartially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL36 Fully implemented\nCodeSonar\n9.1p0\nLANG.STRUCT.DECL.NOEXT\nMissing External Declaration\nCoverity\n2017.07\nPW.LINKAGE_CONFLICT Implemented\nCppcheck Premium\n24.11.0\npremium-cert-dcl36-c\nECLAIR\n1.2\nCC2.DCL36\nFully implemented\nGCC\n4.3.5\n\n\nHelix QAC\n2025.2\nC0625 Fully implemented\nKlocwork\n2025.2\nMISRA.FUNC.STATIC.REDECL\nFully implemented\nLDRA tool suite\n9.7.1\n461 S, 575 S, 2 X\nFully implemented\nPC-lint Plus\n1.4\n401, 839, 1051\nFully supported\nSplint\n3.1.1\n\n\nParasoft C/C++test\n2024.2\nCERT_C-DCL36-a\nIdentifiers shall not simultaneously have both internal and external linkage in the same translation unit\nPolyspace Bug Finder\nR2025b\nCERT C: Rule DCL36-C\n\nChecks for inconsistent use of static and extern in object declarations (rule partially covered)\nRuleChecker\n24.04\nstatic-function-declaration\nstatic-object-declaration Partially checked\nTrustInSoft Analyzer\n1.38\nnon-static declaration follows static declaration\nPartially verified.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nMISRA C:2012 Rule 8.2 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 8.4 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 8.8 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 17.3 (mandatory) Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[Banahan 2003] Section 8.2, \"Declarations, Definitions and Accessibility\"\n[ISO/IEC 9899:2024] 6.2.2, \"Linkages of Identifiers\"\n[Kirch-Prinz 2002]",
        "language": "C"
    },
    {
        "rule_id": "DCL37-C",
        "rule_title": "Do not declare or define a reserved identifier",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL37-C.+Do+not+declare+or+define+a+reserved+identifier",
        "content": "According to the C Standard, 6.4.2.1 paragraph 7 [ISO/IEC 9899:2024],\nSome identifiers are reserved.\n    \u2014  All identifiers that begin with a double underscore (__) or begin with an underscore (_) followed by an uppercase letter are reserved for any use, except those identifiers which are lexically identical to keywords.\n    \u2014  All identifiers that begin with an underscore are reserved for use as identifiers with file scope in both the ordinary and tag name spaces.\nOther identifiers may be reserved, see 7.1.3.\nC Standard, 7.1.3 paragraph 1 [ISO/IEC 9899:2024],\nEach header declares or defines all identifiers listed in its associated subclause, and optionally declares or defines identifiers listed in its associated future library directions subclause and identifiers which are always reserved either for any use or for use as file scope identifiers.\n    \u2014 All potentially reserved identifiers (including ones listed in the future library directions) that are provided by an implementation with an external definition are reserved for any use. An implementation shall not provide an external definition of a potentially reserved identifier unless that identifier is reserved for a use where it would have external linkage. All other potentially reserved identifiers that are provided by an implementation (including in the form of a macro) are reserved for any use when the associated header is included. No other potentially reserved identifiers are reserved.\n    \u2014 Each macro name in any of the following subclauses (including the future library directions) is reserved for use as specified if any of its associated headers is included; unless explicitly stated otherwise (see 7.1.4).\n    \u2014 All identifiers with external linkage in any of the following subclauses (including the future library directions) and errno are always reserved for use as identifiers with external linkage.\n    \u2014 Each identifier with file scope listed in any of the following subclauses (including the future library directions) is reserved for use as a macro name and as an identifier with file scope in the same name space if any of its associated headers is included.\nAdditionally, subclause 7.33 defines many other reserved identifiers for future library directions.\nNo other identifiers are reserved. (The POSIX standard extends the set of identifiers reserved by the C Standard to include an open-ended set of its own. See Portable Operating System Interface [POSIX\u00ae], Base Specifications, Issue 7, Section 2.2, \"The Compilation Environment\" [IEEE Std 1003.1-2013].) The behavior of a program that declares or defines an identifier in a context in which it is reserved or that defines a reserved identifier as a macro name is undefined. (See undefined behavior 105.)\nNoncompliant Code Example (Include Guard)\nA common, but noncompliant, practice is to choose a reserved name for a macro used in a preprocessor conditional guarding against multiple inclusions of a header file. (See also PRE06-C. Enclose header files in an include guard.) The name may clash with reserved names defined by the implementation of the C standard library in its headers or with reserved names implicitly predefined by the compiler even when no C standard library header is included.\n#ifndef _MY_HEADER_H_\n#define _MY_HEADER_H_\n\n/* Contents of <my_header.h> */\n\n#endif /* _MY_HEADER_H_ */\nCompliant Solution (Include Guard)\nThis compliant solution avoids using leading underscores in the macro name of the include guard:\n#ifndef MY_HEADER_H\n#define MY_HEADER_H\n\n/* Contents of <my_header.h> */\n\n#endif /* MY_HEADER_H */\nNoncompliant Code Example (File Scope Objects)\nIn this noncompliant code example, the names of the file scope objects _max_limit and _limit both begin with an underscore. Because _max_limit is static, this declaration might seem to be impervious to clashes with names defined by the implementation. However, because the header <stddef.h> is included to define size_t, a potential for a name clash exists. (Note, however, that a conforming compiler may implicitly declare reserved names regardless of whether any C standard library header is explicitly included.)\nIn addition, because _limit has external linkage, it may clash with a symbol of the same name defined in the language runtime library even if such a symbol is not declared in any header. Consequently, it is not safe to start the name of any file scope identifier with an underscore even if its linkage limits its visibility to a single translation unit.\n#include <stddef.h>\n\nstatic const size_t _max_limit = 1024;\nsize_t _limit = 100;\n\nunsigned int getValue(unsigned int count) {\n  return count < _limit ? count : _limit;\n}\nCompliant Solution (File Scope Objects)\nIn this compliant solution, names of file scope objects do not begin with an underscore:\n#include <stddef.h>\n\nstatic const size_t max_limit = 1024;\nsize_t limit = 100;\n\nunsigned int getValue(unsigned int count) {\n  return count < limit ? count : limit;\n}\nNoncompliant Code Example (Reserved Macros)\nIn this noncompliant code example, because the C standard library header <inttypes.h> is specified to include <stdint.h>, the name SIZE_MAX conflicts with a standard macro of the same name, which is used to denote the upper limit of size_t. In addition, although the name INTFAST16_LIMIT_MAX is not defined by the C standard library, it is a reserved identifier because it begins with the INT prefix and ends with the _MAX suffix. (See the C Standard, 7.33.14.)\n#include <inttypes.h>\n#include <stdio.h>\n\nstatic const int_fast16_t INTFAST16_LIMIT_MAX = 12000;\n\nvoid print_fast16(int_fast16_t val) {\n  enum { SIZE_MAX = 80 };\n  char buf[SIZE_MAX];\n  if (INTFAST16_LIMIT_MAX < val) {\n    sprintf(buf, \"The value is too large\");\n  } else {\n    snprintf(buf, SIZE_MAX, \"The value is %\" PRIdFAST16, val);\n  }\n}\nCompliant Solution (Reserved Macros)\nThis compliant solution avoids redefining reserved names or using reserved prefixes and suffixes:\n#include <inttypes.h>\n#include <stdio.h>\n \nstatic const int_fast16_t MY_INTFAST16_UPPER_LIMIT = 12000;\n\nvoid print_fast16(int_fast16_t val) {\n  enum { BUFSIZE = 80 };\n  char buf[BUFSIZE];\n  if (MY_INTFAST16_UPPER_LIMIT < val) {\n    sprintf(buf, \"The value is too large\");\n  } else {\n    snprintf(buf, BUFSIZE, \"The value is %\" PRIdFAST16, val);\n  }\n}\nNoncompliant Code Example (Identifiers with External Linkage)\nThis noncompliant example provides definitions for the C standard library functions malloc() and free(). Although this practice is permitted by many traditional implementations of UNIX (for example, the Dmalloc library), it is undefined behavior 84 according to the C Standard. Even on systems that allow replacing malloc(), doing so without also replacing aligned_alloc(), calloc(), and realloc() is likely to cause problems.\n#include <stddef.h>\n \nvoid *malloc(size_t nbytes) {\n  void *ptr;\n  /* Allocate storage from own pool and set ptr */\n  return ptr;\n}\n\nvoid free(void *ptr) {\n  /* Return storage to own pool */\n}\nCompliant Solution (Identifiers with External Linkage)\nThe compliant, portable solution avoids redefining any C standard library identifiers with external linkage. In addition, it provides definitions for all memory allocation functions:\n#include <stddef.h>\n\nvoid *my_malloc(size_t nbytes) {\n  void *ptr;\n  /* Allocate storage from own pool and set ptr */\n  return ptr;\n}\n\nvoid *my_aligned_alloc(size_t alignment, size_t size) {\n  void *ptr;\n  /* Allocate storage from own pool, align properly, set ptr */\n  return ptr;\n}\n\nvoid *my_calloc(size_t nelems, size_t elsize) {\n  void *ptr;\n  /* Allocate storage from own pool, zero memory, and set ptr */\n  return ptr;\n}\n\nvoid *my_realloc(void *ptr, size_t nbytes) {\n  /* Reallocate storage from own pool and set ptr */\n  return ptr;\n}\n\nvoid my_free(void *ptr) {\n  /* Return storage to own pool */\n}\nNoncompliant Code Example (errno)\nIn addition to symbols defined as functions in each C standard library header, identifiers with external linkage include errno and math_errhandling.  According to the C Standard, 7.5, paragraph 2 [ISO/IEC 9899:2011], the behavior of a program is undefined when\nA macro definition of errno is suppressed in order to access an actual object, or the program defines an identifier with the name errno. \nSee undefined behavior 111.\nThe errno identifier expands to a modifiable lvalue that has type int but is not necessarily the identifier of an object. It might expand to a modifiable lvalue resulting from a function call, such as *errno(). It is unspecified whether errno is a macro or an identifier declared with external linkage. If a macro definition is suppressed to access an actual object, or if a program defines an identifier with the name errno, the behavior is undefined.\nLegacy code is apt to include an incorrect declaration, such as the following:\nextern int errno;\nCompliant Solution (errno)\nThe correct way to declare errno is to include the header <errno.h>:\n#include <errno.h>\nImplementations conforming to C are required to declare errno in <errno.h>, although some historic implementations failed to do so.\nExceptions\nDCL37-C-EX1: Provided that a library function can be declared without reference to any type defined in a header, it is permissible to declare that function without including its header provided that declaration is compatible with the standard declaration.\n/* Not including stdlib.h */\nvoid free(void *);\n \nvoid func(void *ptr) {\n  free(ptr);\n}\nSuch code is compliant because the declaration matches what stdlib.h would provide and does not redefine the reserved identifier. However, it would not be acceptable to provide a definition for the free() function in this example.\nDCL37-C-EX2: For compatibility with other compiler vendors or language standard modes, it is acceptable to create a macro identifier that is the same as a reserved identifier so long as the behavior is idempotent, as in this example:\n/* Sometimes generated by configuration tools such as autoconf */\n#define const const\n \n/* Allowed compilers with semantically equivalent extension behavior */\n#define inline __inline\nDCL37-C-EX3: As a compiler vendor or standard library developer, it is acceptable to use identifiers reserved for your implementation. Reserved identifiers may be defined by the compiler, in standard library headers or headers included by a standard library header, as in this example declaration from the glibc standard C library implementation:\n/*\n  The following declarations of reserved identifiers exist in the glibc implementation of\n  <stdio.h>. The original source code may be found at:\n  https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=include/stdio.h;hb=HEAD\n*/\n \n#  define __need_size_t\n#  include <stddef.h>\n/* Generate a unique file name (and possibly open it).  */\nextern int __path_search (char *__tmpl, size_t __tmpl_len,\n     const char *__dir, const char *__pfx,\n     int __try_tempdir);\nRisk Assessment\nUsing reserved identifiers can lead to incorrect program operation.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL37-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nfuture-library-use\nlanguage-override\nlanguage-override-c99\nreserved-declaration\nreserved-declaration-c99\nreserved-identifier\nPartially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL37 Fully implemented. Reserved identifiers, as in DCL37-C-EX3, are configurable.\nCodeSonar\n9.1p0\nLANG.STRUCT.DECL.RESERVED\nDeclaration of reserved name\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nMISRA C 2004 Rule 20.1\nMISRA C 2004 Rule 20.2\nMISRA C 2012 Rule 21.1\nMISRA C 2012 Rule 21.2\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-dcl37-c\n\nECLAIR\n1.2\nCC2.DCL37 Fully implemented\nHelix QAC\n2025.2\nC0602, C0603, C4600, C4601, C4602, C4603, C4604, C4605, C4606, C4607, C4608, C4620, C4621, C4622, C4623, C4624, C4640, C4641, C4642, C4643, C4644, C4645\nFully implemented\nKlocwork\n2025.2\nMISRA.DEFINE.WRONGNAME.UNDERSCORE\nMISRA.STDLIB.WRONGNAME.UNDERSCORE\nMISRA.STDLIB.WRONGNAME Fully implemented\nLDRA tool suite\n9.7.1\n86 S, 218 S, 219 S, 580 S, 626 S\nFully Implemented\nParasoft C/C++test 2024.2\nCERT_C-DCL37-b\nCERT_C-DCL37-c\nCERT_C-DCL37-d\nCERT_C-DCL37-e\nCERT_C-DCL37-f\nCERT_C-DCL37-g\nIdentifiers that begin with an underscore and either an uppercase letter or another underscore should not be declared\nAvoid declaring file-scoped objects whose names begin with an underscore\nThe names of standard library macros should not be reused (C11 code)\nThe names of standard library identifiers with file scope should not be reused (C11 code)\nThe standard library identifiers with external linkage should not be reused (C11 code)\nMacros that begin with an underscore and either an uppercase letter or another underscore should not be defined\nPC-lint Plus\n1.4\n978, 9071, 9093\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule DCL37-C\n\nChecks for:\nDefining and undefining reserved identifiers or macros\nDeclaring a reserved identifier or macro name\nRule partially covered\nPVS-Studio\n7.38\nV677\nSonarQube C/C++ Plugin\n3.11\nS978\nRuleChecker\n24.04\nfuture-library-use\nlanguage-override\nlanguage-override-c99\nreserved-declaration\nreserved-declaration-c99\nreserved-identifier\nPartially checked\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard PRE00-C. Prefer inline or static functions to function-like macros Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard PRE06-C. Enclose header files in an include guard Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard PRE31-C. Avoid side effects in arguments to unsafe macros Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C DCL51-CPP. Do not declare or define a reserved identifier Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Using identifiers that are reserved for the implementation [resident] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 21.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 21.2 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[IEEE Std 1003.1-2013] Section 2.2, \"The Compilation Environment\"\n[ISO/IEC 9899:2024] 7.1.3, \"Reserved Identifiers\"\n7.33.14, \"Integer Types <stdint.h>\"",
        "language": "C"
    },
    {
        "rule_id": "DCL38-C",
        "rule_title": "Use the correct syntax when declaring a flexible array member",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL38-C.+Use+the+correct+syntax+when+declaring+a+flexible+array+member",
        "content": "Flexible array members are a special type of array in which the last element of a structure with more than one named member has an incomplete array type; that is, the size of the array is not specified explicitly within the structure. This \"struct hack\" was widely used in practice and supported by a variety of compilers. Consequently, a variety of different syntaxes have been used for declaring flexible array members. For conforming C implementations, use the syntax guaranteed to be valid by the C Standard.\nFlexible array members are defined in the C Standard, 6.7.3.2, paragraph 20 [ISO/IEC 9899:2024], as follows:\nAs a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. In most situations, the flexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply. However, when a . (or ->) operator has a left operand that is (a pointer to) a structure with a flexible array member and the right operand names that member, it behaves as if that member were replaced with the longest array (with the same element type) that would not make the structure larger than the object being accessed; the offset of the array shall remain that of the flexible array member, even if this would differ from that of the replacement array. If this array would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it.\nStructures with a flexible array member can be used to produce code with defined behavior. However, some restrictions apply:\nThe incomplete array type must be the last element within the structure.\nThere cannot be an array of structures that contain a flexible array member.\nStructures that contain a flexible array member cannot be used as a member of another structure.\nThe structure must contain at least one named member in addition to the flexible array member.\nNoncompliant Code Example\nBefore the introduction of flexible array members in the C Standard, structures with a one-element array as the final member were used to achieve similar functionality. This noncompliant code example illustrates how struct flexArrayStruct is declared in this case.\nThis noncompliant code example attempts to allocate a flexible array-like member with a one-element array as the final member. When the structure is instantiated, the size computed for malloc() is modified to account for the actual size of the dynamic array.\n#include <stdlib.h>\n  struct flexArrayStruct {\n  int num;\n  int data[1];\n};\n void func(size_t array_size) {\n  /* Space is allocated for the struct */\n  struct flexArrayStruct *structP\n    = (struct flexArrayStruct *)\n     malloc(sizeof(struct flexArrayStruct)\n          + sizeof(int) * (array_size - 1));\n  if (structP == NULL) {\n    /* Handle malloc failure */\n  }\n     structP->num = array_size;\n   /*\n   * Access data[] as if it had been allocated\n   * as data[array_size].\n   */\n  for (size_t i = 0; i < array_size; ++i) {\n    structP->data[i] = 1;\n  }\n}\nThis example has undefined behavior 59 when accessing any element other than the first element of the data array. (See the C Standard, 6.5.7.) Consequently, the compiler can generate code that does not return the expected value when accessing the second element of data.\nThis approach may be the only alternative for compilers that do not yet implement the standard C syntax.\nCompliant Solution\nThis compliant solution uses a flexible array member to achieve a dynamically sized structure:\n#include <stdlib.h>\n  struct flexArrayStruct{\n  int num;\n  int data[];\n};\n void func(size_t array_size) {\n  /* Space is allocated for the struct */\n  struct flexArrayStruct *structP\n    = (struct flexArrayStruct *)\n    malloc(sizeof(struct flexArrayStruct)\n         + sizeof(int) * array_size);\n  if (structP == NULL) {\n    /* Handle malloc failure */\n  }\n   structP->num = array_size;\n   /*\n   * Access data[] as if it had been allocated\n   * as data[array_size].\n   */\n  for (size_t i = 0; i < array_size; ++i) {\n    structP->data[i] = 1;\n  }\n}\nThis compliant solution allows the structure to be treated as if its member data[] was declared to be data[array_size] in a manner that conforms to the C Standard.\nRisk Assessment\nFailing to use the correct syntax when declaring a flexible array member can result in undefined behavior 59, although the incorrect syntax will work on most implementations.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL38-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\narray_out_of_bounds\nSupported\nAstr\u00e9e reports all out-of-bounds array access.\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL38 Detects if the final member of struct which is declared as an array of small bound, is used as a flexible array member.\nCompass/ROSE\n\n\nCan detect some violations of this rule. In particular, it warns if the last element of a struct is an array with a small index (0 or 1)\nCppcheck Premium\n24.11.0\npremium-cert-dcl38-c\n\nHelix QAC\n2025.2\nC1037, C1039 Fully implemented\nKlocwork\n2025.2\nCERT.STRUCT.FLEXIBLE_ARRAY_MEMBER Fully implemented\nLDRA tool suite\n 9.7.1\n648 S Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-DCL38-a\nThe final member of a structure should not be an array of size '0' or '1'\nPC-lint Plus\n1.4\n9040\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule DCL38-C Checks for incorrect syntax of flexible array member size (rule fully covered)\nTrustInSoft Analyzer\n1.38\nindex_bound Exhaustively detects out-of-bounds array access (see the compliant and the non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nThis rule supplements MEM33-C. Allocate and copy structures containing a flexible array member dynamically\nBibliography\n[ISO/IEC 9899:2024]\n6.5.7, \"Additive Operators\"\n6.7.3.2, \"Structure and Union Specifiers\"\n[McCluskey 2001] \"Flexible Array Members and Designators in C9X\"",
        "language": "C"
    },
    {
        "rule_id": "DCL39-C",
        "rule_title": "Avoid information leakage when passing a structure across a trust boundary",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL39-C.+Avoid+information+leakage+when+passing+a+structure+across+a+trust+boundary",
        "content": "The C Standard, 6.7.3.2, discusses the layout of structure fields. It specifies that non-bit-field members are aligned in an implementation-defined manner and that there may be padding within or at the end of a structure. Furthermore, initializing the members of the structure does not guarantee initialization of the padding bytes. The C Standard, 6.2.6.1, paragraph 6 [ISO/IEC 9899:2024], states\nWhen a value is stored in an object of structure or union type, including in a member object, the bytes of the object representation that correspond to any padding bytes take unspecified values (e.g. structure and union assignment may or may not copy any padding bits). \nAdditionally, the storage units in which a bit-field resides may also have padding bits. For an object with automatic storage duration, these padding bits do not take on specific values and can contribute to leaking sensitive information.\nWhen passing a pointer to a structure across a trust boundary to a different trusted domain, the programmer must ensure that the padding bytes and bit-field storage unit padding bits of such a structure do not contain sensitive information.\nNoncompliant Code Example\nThis noncompliant code example runs in kernel space and copies data from arg to user space. However, padding bytes may be used within the structure, for example, to ensure the proper alignment of the structure members. These padding bytes may contain sensitive information, which may then be leaked when the data is copied to user space.\n#include <stddef.h>\n struct test {\n  int a;\n  char b;\n  int c;\n};\n /* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n void do_stuff(void *usr_buf) {\n  struct test arg = {.a = 1, .b = 2, .c = 3};\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\nNoncompliant Code Example (memset())\nThe padding bytes can be explicitly initialized by calling memset():\n#include <string.h>\n struct test {\n  int a;\n  char b;\n  int c;\n};\n /* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n void do_stuff(void *usr_buf) {\n  struct test arg;\n   /* Set all bytes (including padding bytes) to zero */\n  memset(&arg, 0, sizeof(arg));\n   arg.a = 1;\n  arg.b = 2;\n  arg.c = 3;\n   copy_to_user(usr_buf, &arg, sizeof(arg));\n}\nHowever, a conforming compiler is free to implement arg.b = 2 by setting the low-order bits of a register to 2, leaving the high-order bits unchanged and containing sensitive information. Then the platform copies all register bits into memory, leaving sensitive information in the padding bits. Consequently, this implementation could leak the high-order bits from the register to a user.\nCompliant Solution\nThis compliant solution serializes the structure data before copying it to an untrusted context:\n#include <stddef.h>\n#include <string.h>\n  struct test {\n  int a;\n  char b;\n  int c;\n};\n  /* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n  void do_stuff(void *usr_buf) {\n  struct test arg = {.a = 1, .b = 2, .c = 3};\n  /* May be larger than strictly needed */\n  unsigned char buf[sizeof(arg)];\n  size_t offset = 0;\n     memcpy(buf + offset, &arg.a, sizeof(arg.a));\n  offset += sizeof(arg.a);\n  memcpy(buf + offset, &arg.b, sizeof(arg.b));\n  offset += sizeof(arg.b);\n  memcpy(buf + offset, &arg.c, sizeof(arg.c));\n  offset += sizeof(arg.c);\n  /* Set all remaining bytes to zero */\n  memset(buf + offset, 0, sizeof(arg) - offset);\n   copy_to_user(usr_buf, buf, offset /* size of info copied */);\n} \nThis code ensures that no uninitialized padding bytes are copied to unprivileged users. Important: The structure copied to user space is now a packed structure and the copy_to_user() function (or other eventual user) would need to unpack it to recreate the original padded structure.\nCompliant Solution (Padding Bytes)\nPadding bytes can be explicitly declared as fields within the structure. This solution is not portable, however, because it depends on the implementation and target memory architecture. The following solution is specific to the x86-32 architecture:\n#include <assert.h>\n#include <stddef.h>\n struct test {\n  int a;\n  char b;\n  char padding_1, padding_2, padding_3;\n  int c;\n};\n /* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n void do_stuff(void *usr_buf) {\n  /* Ensure c is the next byte after the last padding byte */\n  static_assert(offsetof(struct test, c) ==\n                offsetof(struct test, padding_3) + 1,\n                \"Structure contains intermediate padding\");\n  /* Ensure there is no trailing padding */\n  static_assert(sizeof(struct test) ==\n                offsetof(struct test, c) + sizeof(int),\n                \"Structure contains trailing padding\");\n  struct test arg = {.a = 1, .b = 2, .c = 3};\n  arg.padding_1 = 0;\n  arg.padding_2 = 0;\n  arg.padding_3 = 0;\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\nThe C Standard static_assert() macro accepts a constant expression and an error message. The expression is evaluated at compile time and, if false, the compilation is terminated and the error message is output. (See DCL03-C. Use a static assertion to test the value of a constant expression for more details.) The explicit insertion of the padding bytes into the struct should ensure that no additional padding bytes are added by the compiler and consequently both static assertions should be true. However, it is necessary to validate these assumptions to ensure that the solution is correct for a particular implementation.\nCompliant Solution (Structure Packing\u2014GCC)\nGCC allows specifying declaration attributes using the keyword __attribute__((__packed__)). When this attribute is present, the compiler will not add padding bytes for memory alignment unless an explicit alignment specifier for a structure member requires the introduction of padding bytes.\n#include <stddef.h>\n struct test {\n  int a;\n  char b;\n  int c;\n} __attribute__((__packed__));\n /* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n void do_stuff(void *usr_buf) {\n  struct test arg = {.a = 1, .b = 2, .c = 3};\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\nCompliant Solution (Structure Packing\u2014Microsoft Visual Studio)\nMicrosoft Visual Studio  supports #pragma pack() to suppress padding bytes [MSDN]. The compiler adds padding bytes for memory alignment, depending on the current packing mode, but still honors the alignment specified by __declspec(align()). In this compliant solution, the packing mode is set to 1 in an attempt to ensure all fields are given adjacent offsets:\n#include <stddef.h>\n #pragma pack(push, 1) /* 1 byte */\nstruct test {\n  int a;\n  char b;\n  int c;\n};\n#pragma pack(pop)\n  /* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n void do_stuff(void *usr_buf) {\n  struct test arg = {1, 2, 3};\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\nThe pack pragma takes effect at the first struct declaration after the pragma is seen.\nNoncompliant Code Example\nThis noncompliant code example also runs in kernel space and copies data from struct test to user space. However, padding bits will be used within the structure due to the bit-field member lengths not adding up to the number of bits in an unsigned object. Further, there is an unnamed bit-field that causes no further bit-fields to be packed into the same storage unit. These padding bits may contain sensitive information, which may then be leaked when the data is copied to user space. For instance, the uninitialized bits may contain a sensitive kernel space pointer value that can be trivially reconstructed by an attacker in user space.\n#include <stddef.h>\n struct test {\n  unsigned a : 1;\n  unsigned : 0;\n  unsigned b : 4;\n};\n /* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n void do_stuff(void *usr_buf) {\n  struct test arg = { .a = 1, .b = 10 };\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\nCompliant Solution\nPadding bits can be explicitly declared, allowing the programmer to specify the value of those bits. When explicitly declaring all of the padding bits, any unnamed bit-fields of length 0 must be removed from the structure because the explicit padding bits ensure that no further bit-fields will be packed into the same storage unit.\n#include <assert.h>\n#include <limits.h>\n#include <stddef.h>\n struct test {\n  unsigned a : 1;\n  unsigned padding1 : sizeof(unsigned) * CHAR_BIT - 1;\n  unsigned b : 4;\n  unsigned padding2 : sizeof(unsigned) * CHAR_BIT - 4;\n};\n/* Ensure that we have added the correct number of padding bits. */\nstatic_assert(sizeof(struct test) == sizeof(unsigned) * 2,\n              \"Incorrect number of padding bits for type: unsigned\");\n /* Safely copy bytes to user space */\nextern int copy_to_user(void *dest, void *src, size_t size);\n void do_stuff(void *usr_buf) {\n  struct test arg = { .a = 1, .padding1 = 0, .b = 10, .padding2 = 0 };\n  copy_to_user(usr_buf, &arg, sizeof(arg));\n}\nThis solution is not portable, however, because it depends on the implementation and target memory architecture. The explicit insertion of padding bits into the struct should ensure that no additional padding bits are added by the compiler. However, it is still necessary to validate these assumptions to ensure that the solution is correct for a particular implementation. For instance, the DEC Alpha is an example of a 64-bit architecture with 32-bit integers that allocates 64 bits to a storage unit.\nIn addition, this solution assumes that there are no integer padding bits in an unsigned int.  The portable version of the width calculation from INT35-C. Use correct integer precisions cannot be used because the bit-field width must be an integer constant expression.\nFrom this situation, it can be seen that special care must be taken because no solution to the bit-field padding issue will be 100% portable.\n Risk Assessment\nPadding units might contain sensitive data because the C Standard allows any padding to take unspecified values. A pointer to such a structure could be passed to other functions, causing information leakage.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL39-C\nLow\nUnlikely\nNo\nYes\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nfunction-argument-with-padding Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL39 Detects composite structures with padding, in particular those passed to trust boundary routines.\nCodeSonar\n9.1p0\nMISC.PADDING.POTB\nPadding Passed Across a Trust Boundary\nCppcheck Premium 24.11.0\n\npremium-cert-dcl39-c\n\nHelix QAC\n2025.2\nDF4941, DF4942, DF4943\nFully implemented\nKlocwork\n2025.2\nPORTING.STORAGE.STRUCT\n\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-DCL39-a\nA pointer to a structure should not be passed to a function that can copy data to the user space\nPolyspace Bug Finder\nR2025b\nCERT C: Rule DCL39-C Checks for information leak via structure padding \nRuleChecker\n24.04\nfunction-argument-with-padding Partially checked\nSecurity Reviewer - Static Reviewer\n6.02\nC20, C21,C22, C23, C25 Fully implemented\nRelated Vulnerabilities\nNumerous vulnerabilities in the Linux Kernel have resulted from violations of this rule. CVE-2010-4083 describes a vulnerability in which the semctl() system call allows unprivileged users to read uninitialized kernel stack memory because various fields of a semid_ds struct declared on the stack are not altered or zeroed before being copied back to the user.\nCVE-2010-3881 describes a vulnerability in which structure padding and reserved fields in certain data structures in QEMU-KVM were not initialized properly before being copied to user space. A privileged host user with access to /dev/kvm could use this flaw to leak kernel stack memory to user space.\nCVE-2010-3477 describes a kernel information leak in act_police where incorrectly initialized structures in the traffic-control dump code may allow the disclosure of kernel memory to user space applications.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard DCL03-C. Use a static assertion to test the value of a constant expression Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 6.2.6.1, \"General\"\n6.7.3.2, \"Structure and Union Specifiers\"\n[Graff 2003]\n[Sun 1993]",
        "language": "C"
    },
    {
        "rule_id": "DCL40-C",
        "rule_title": "Do not create incompatible declarations of the same function or object",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL40-C.+Do+not+create+incompatible+declarations+of+the+same+function+or+object",
        "content": "Two or more incompatible declarations of the same function or object must not appear in the same program because they result in undefined behavior. The C Standard, 6.2.7, mentions that two types may be distinct yet compatible and addresses precisely when two distinct types are compatible.\nThe C Standard identifies four situations in which undefined behavior (UB) may arise as a result of incompatible declarations of the same function or object:\nUB\nDescription\nCode\n14\nTwo declarations of the same object or function specify types that are not compatible (6.2.7).\nAll noncompliant code in this guideline\n30 Two identifiers differ only in nonsignificant characters (6.4.2.1). Excessively Long Identifiers\n36\nAn object has its stored value accessed other than by an lvalue of an allowable type (6.5).\nIncompatible Object Declarations\nIncompatible Array Declarations\n37\nA function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function (6.5.2.2).\nIncompatible Function Declarations \nExcessively Long Identifiers\nAlthough the effect of two incompatible declarations simply appearing in the same program may be benign on most implementations, the effects of invoking a function through an expression whose type is incompatible with the function definition are typically catastrophic. Similarly, the effects of accessing an object using an lvalue of a type that is incompatible with the object definition may range from unintended information exposure to memory overwrite to a hardware trap.\nNoncompliant Code Example (Incompatible Object Declarations)\nIn this noncompliant code example, the variable i is declared to have type int in file a.c but defined to be of type short in file b.c. The declarations are incompatible, resulting in undefined behavior 14. Furthermore, accessing the object using an lvalue of an incompatible type, as shown in function f(), is undefined behavior 36 with possible observable results ranging from unintended information exposure to memory overwrite to a hardware trap.\n/* In a.c */\nextern int i;   /* UB 14 */\n int f(void) {\n  return ++i;   /* UB 36 */\n}\n /* In b.c */\nshort i;   /* UB 14 */\nCompliant Solution (Incompatible Object Declarations)\nThis compliant solution has compatible declarations of the variable i:\n/* In a.c */\nextern int i;  \n int f(void) {\n  return ++i;  \n}\n /* In b.c */\nint i;\nNoncompliant Code Example (Incompatible Array Declarations)\nIn this noncompliant code example, the variable a is declared to have a pointer type in file a.c but defined to have an array type in file b.c. The two declarations are incompatible, resulting in undefined behavior 14. As before, accessing the object in function f() is undefined behavior 36 with the typical effect of triggering a hardware trap.\n/* In a.c */\nextern int *a;   /* UB 14 */\n int f(unsigned int i, int x) {\n  int tmp = a[i];   /* UB 36: read access */\n  a[i] = x;         /* UB 36: write access */\n  return tmp;\n}\n /* In b.c */\nint a[] = { 1, 2, 3, 4 };   /* UB 14 */\nCompliant Solution (Incompatible Array Declarations)\nThis compliant solution declares a as an array in a.c and b.c:\n/* In a.c */\nextern int a[];  \n int f(unsigned int i, int x) {\n  int tmp = a[i];  \n  a[i] = x;        \n  return tmp;\n}\n /* In b.c */\nint a[] = { 1, 2, 3, 4 };\nNoncompliant Code Example (Incompatible Function Declarations)\nIn this noncompliant code example, the function f() is declared in file a.c with one prototype but defined in file b.c with another. The two prototypes are incompatible, resulting in undefined behavior 14. Furthermore, invoking the function is undefined behavior 37 and typically has catastrophic consequences.\n/* In a.c */\nextern int f(int a);   /* UB 14 */\n int g(int a) {\n  return f(a);   /* UB 37 */\n}\n /* In b.c */\nlong f(long a) {   /* UB 14 */\n  return a * 2;\n}\nCompliant Solution (Incompatible Function Declarations)\nThis compliant solution has compatible prototypes for the function f():\n/* In a.c */\nextern int f(int a);  \n int g(int a) {\n  return f(a);  \n}\n /* In b.c */\nint f(int a) {  \n  return a * 2;\n}\nNoncompliant Code Example (Incompatible Variadic Function Declarations)\nIn this noncompliant code example, the function buginf() is defined to take a variable number of arguments and expects them all to be signed integers with a sentinel value of -1:\n/* In a.c */\nvoid buginf(const char *fmt, ...) {\n   /* ... */\n}\n  /* In b.c */\nvoid buginf();\n\nAlthough this code appears to be well defined because of the prototype-less declaration of buginf(), it exhibits undefined behavior 76 in accordance with the C Standard, 6.7.7.4, paragraph 14 [ISO/IEC 9899:2024],\nFor two function types to be compatible, both shall specify compatible return types. Moreover, the parameter type lists shall agree in the number of parameters and in use of the final ellipsis; corresponding parameters shall have compatible types. In the determination of type compatibility and of a composite type, each parameter declared with function or array type is taken as having the adjusted type and each parameter declared with qualified type is taken as having the unqualified version of its declared type.\nCompliant Solution (Incompatible Variadic Function Declarations)\nIn this compliant solution, the prototype for the function buginf() is included in the scope in the source file where it will be used:\n/* In a.c */\nvoid buginf(const char *fmt, ...) {\n   /* ... */\n}\n /* In b.c */\nvoid buginf(const char *fmt, ...);\nNoncompliant Code Example (Excessively Long Identifiers)\nIn this noncompliant code example, the length of the identifier declaring the function pointer bash_groupname_completion_function() in the file bashline.h exceeds by 3 the minimum implementation limit of 31 significant initial characters in an external identifier. This introduces the possibility of colliding with the bash_groupname_completion_funct integer variable defined in file b.c, which is exactly 31 characters long. On an implementation that exactly meets this limit, this is undefined behavior 30. It results in two incompatible declarations of the same function. (See undefined behavior 14.) In addition, invoking the function leads to undefined behavior 37 with typically catastrophic effects.\n/* In bashline.h */\n/* UB 14, UB 30 */\nextern char * bash_groupname_completion_function(const char *, int);\n /* In a.c */\n#include \"bashline.h\"\n void f(const char *s, int i) {\n  bash_groupname_completion_function(s, i);  /* UB 37 */\n}\n /* In b.c */\nint bash_groupname_completion_funct;  /* UB 14, UB 30 */\nNOTE: The identifier bash_groupname_completion_function referenced here was taken from GNU Bash, version 3.2.\nCompliant Solution (Excessively Long Identifiers)\nIn this compliant solution, the length of the identifier declaring the function pointer bash_groupname_completion() in bashline.h is less than 32 characters. Consequently, it cannot clash with bash_groupname_completion_funct on any compliant platform.\n/* In bashline.h */\nextern char * bash_groupname_completion(const char *, int);  \n /* In a.c */\n#include \"bashline.h\"\n void f(const char *s, int i) {\n  bash_groupname_completion(s, i); \n}\n /* In b.c */\nint bash_groupname_completion_funct;\nRisk Assessment\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL40-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ntype-compatibility\ntype-compatibility-link\ndistinct-extern\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL40 Fully implemented\nCodeSonar\n9.1p0\nLANG.STRUCT.DECL.IF\nLANG.STRUCT.DECL.IO\nInconsistent function declarations\nInconsistent object declarations\nCoverity\n2017.07\nMISRA C 2012 Rule 8.4 Implemented\nCppcheck Premium\n24.11.0\npremium-cert-dcl40-c\nHelix QAC\n2025.2\nC0776, C0778, C0779, C0789, C1510\nC++1510\nFully implemented\nKlocwork\n2025.2\nMISRA.FUNC.NOPROT.DEF.2012\nMISRA.FUNC.PARAMS.IDENT\nFully implemented\nLDRA tool suite 8.5.4\n1 X, 17 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-DCL40-a\nCERT_C-DCL40-b\nAll declarations of an object or function shall have compatible types\nIf objects or functions are declared more than once their types shall be compatible\nParasoft Insure++\n\n\nRuntime analysis\nPC-lint Plus\n1.4\n18, 621, 793, 4376\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule DCL40-C\n\n\n\nChecks for declaration mismatch (rule fully covered)\nRuleChecker\n24.04\ntype-compatibility\ntype-compatibility-link\ndistinct-extern\n  Fully checked\nSecurity Reviewer - Static Reviewer\n6.02\nC26\nFully implemented\nTrustInSoft Analyzer\n1.38\nincompatible declaration Exhaustively verified.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TS 17961 Declaring the same function or object in incompatible ways [funcdecl] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 8.4 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[Hatton 1995] Section 2.8.3\n[ISO/IEC 9899:2011]\nJ.2, \"Undefined Behavior\"\n[ISO/IEC 9899:2024]\n6.7.7.4 \"Function Declarators\"",
        "language": "C"
    },
    {
        "rule_id": "DCL41-C",
        "rule_title": "Do not declare variables inside a switch statement before the first case label",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL41-C.+Do+not+declare+variables+inside+a+switch+statement+before+the+first+case+label",
        "content": "According to the C Standard, 6.8.5.3, paragraph 4 [ISO/IEC 9899:2024],\nA switch statement causes control to jump to, into, or past the statement that is the switch body, depending on the value of a controlling expression, and on the presence of a default label and the values of any case labels on or in the switch body. A case or default label is accessible only within the closest enclosing switch statement.\nIf a programmer declares variables, initializes them before the first case statement, and then tries to use them inside any of the case statements, those variables will have scope inside the switch block but will not be initialized and will consequently contain indeterminate values.  Reading such values also violates EXP33-C. Do not read uninitialized memory.\nNoncompliant Code Example\nThis noncompliant code example declares variables and contains executable statements before the first case label within the switch statement:\n#include <stdio.h>\n  extern void f(int i);\n  void func(int expr) {\n  switch (expr) {\n    int i = 4;\n    f(i);\n  case 0:\n    i = 17;\n    /* Falls through into default code */\n  default:\n    printf(\"%d\\n\", i);\n  }\n}\nImplementation Details\nWhen the preceding example is executed on GCC 4.8.1, the variable i is instantiated with automatic storage duration within the block, but it is not initialized. Consequently, if the controlling expression expr has a nonzero value, the call to printf() will access an indeterminate value of i. Similarly, the call to f() is not executed.\nValue of expr\nOutput\n0\n17\nNonzero\nIndeterminate\nCompliant Solution\nIn this compliant solution, the statements before the first case label occur before the switch statement:\n#include <stdio.h>\n  extern void f(int i);\n  int func(int expr) {\n  /*\n   * Move the code outside the switch block; now the statements\n   * will get executed.\n   */\n  int i = 4;\n  f(i);\n   switch (expr) {\n    case 0:\n      i = 17;\n      /* Falls through into default code */\n    default:\n      printf(\"%d\\n\", i);\n  }\n  return 0;\n}\nRisk Assessment\nUsing test conditions or initializing variables before the first case statement in a switch block can result in unexpected behavior and undefined behavior 20.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL41-C\nMedium\nUnlikely\nYes\nYes\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e 24.04\nswitch-skipped-code\nFully checked\nAxivion Bauhaus Suite 7.2.0 CertC-DCL41 Fully implemented\nClang 3.9 -Wsometimes-uninitialized\n\nCodeSonar 9.1p0 LANG.STRUCT.SW.BAD Malformed switch Statement\nCoverity 2017.07\nMISRA C 2004 Rule 15.0\nMISRA C 2012 Rule 16.1\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-dcl41-c\n\nHelix QAC 2025.2 C2008, C2882, C3234 Fully implemented\nKlocwork 2025.2 CERT.DCL.SWITCH.VAR_BEFORE_CASE Fully implemented\nLDRA tool suite  9.7.1 385 S Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-DCL41-a\nA switch statement shall only contain switch labels and switch clauses, and no other code\nPC-lint Plus\n1.4\n527\nAssistance provided\nPolyspace Bug Finder\nR2025b\nCERT C: Rule DCL41-C\nChecks for ill-formed switch statements (rule partially covered)\nPVS-Studio\n7.38\nV622\nRuleChecker\n24.04\nswitch-skipped-code\nFully checked\nTrustInSoft Analyzer\n1.38\ninitialisation Exhaustively detects undefined behavior (see the compliant and the non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nMISRA C:2012 Rule 16.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 6.8.5.3, \"The switch Statement\"",
        "language": "C"
    },
    {
        "rule_id": "EXP30-C",
        "rule_title": "Do not depend on the order of evaluation for side effects",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP30-C.+Do+not+depend+on+the+order+of+evaluation+for+side+effects",
        "content": "Evaluation of an expression may produce side effects. At specific points during execution, known as sequence points, all side effects of previous evaluations are complete, and no side effects of subsequent evaluations have yet taken place. Do not depend on the order of evaluation for side effects unless there is an intervening sequence point.\nThe C Standard, 6.5, paragraph 2 [ISO/IEC 9899:2024], states\nIf a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.\nThis requirement must be met for each allowable ordering of the subexpressions of a full expression; otherwise, the behavior is undefined. (See undefined behavior 34.)\nThe following sequence points are defined in the C Standard, Annex C [ISO/IEC 9899:2011]:\nBetween the evaluations of the function designator and actual arguments in a function call and the actual call\nBetween the evaluations of the first and second operands of the following operators:\nLogical AND: &&\nLogical OR: ||\nComma: ,\nBetween the evaluations of the first operand of the conditional ?: operator and whichever of the second and third operands is evaluated\nThe end of a full declarator\nBetween the evaluation of a full expression and the next full expression to be evaluated; the following are full expressions:\nAn initializer that is not part of a compound literal\nThe expression in an expression statement\nThe controlling expression of a selection statement (if or switch)\nThe controlling expression of a while or do statement\nEach of the (optional) expressions of a for statement\nThe (optional) expression in a return statement\nImmediately before a library function returns\nAfter the actions associated with each formatted input/output function conversion specifier\nImmediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call\nFurthermore, Section 6.5.17.1, paragraph 3 [ISO/IEC 9899:2024] says (regarding assignment operations):\nThe side effect of updating the stored value of the left operand is sequenced after the value computations of the left and right operands. \nThis rule means that statements such as\ni = i + 1;\na[i] = i;\nhave defined behavior, and statements such as the following do not:\n/* i is modified twice between sequence points */\ni = ++i + 1;  \n\n/* i is read other than to determine the value to be stored */\na[i++] = i;   \nNot all instances of a comma in C code denote a usage of the comma operator. For example, the comma between arguments in a function call is not a sequence point. However, according to the C Standard, 6.5.3.3, paragraph 8 [ISO/IEC 9899:2024]\nEvery evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function.\nThis rule means that the order of evaluation for function call arguments is unspecified and can happen in any order.\nNoncompliant Code Example\nPrograms cannot safely rely on the order of evaluation of operands between sequence points. In this noncompliant code example, i is evaluated twice without an intervening sequence point, so the behavior of the expression is undefined:\n#include <stdio.h>\n\nvoid func(int i, int *b) {\n  int a = i + b[++i];\n  printf(\"%d, %d\", a, i);\n}\nCompliant Solution\nThese examples are independent of the order of evaluation of the operands and can be interpreted in only one way:\n#include <stdio.h>\n\nvoid func(int i, int *b) {\n  int a;\n  ++i;\n  a = i + b[i];\n  printf(\"%d, %d\", a, i);\n}\nAlternatively:\n#include <stdio.h>\n\nvoid func(int i, int *b) {\n  int a = i + b[i + 1];\n  ++i;\n  printf(\"%d, %d\", a, i);\n}\nNoncompliant Code Example\nThe call to func() in this noncompliant code example has undefined behavior 34 because there is no sequence point between the argument expressions:\nextern void func(int i, int j);\n \nvoid f(int i) {\n  func(i++, i);\n}\nThe first (left) argument expression reads the value of i (to determine the value to be stored) and then modifies i. The second (right) argument expression reads the value of i between the same pair of sequence points as the first argument, but not to determine the value to be stored in i. This additional attempt to read the value of i has undefined behavior 34.\nCompliant Solution\nThis compliant solution is appropriate when the programmer intends for both arguments to func() to be equivalent:\nextern void func(int i, int j);\n \nvoid f(int i) {\n  i++;\n  func(i, i);\n}\nThis compliant solution is appropriate when the programmer intends for the second argument to be 1 greater than the first:\nextern void func(int i, int j);\n \nvoid f(int i) {\n  int j = i++;\n  func(j, i);\n}\nNoncompliant Code Example\nThe order of evaluation for function arguments is unspecified. This noncompliant code example exhibits unspecified behavior but not undefined behavior:\nextern void c(int i, int j);\nint glob;\n \nint a(void) {\n  return glob + 10;\n}\n\nint b(void) {\n  glob = 42;\n  return glob;\n}\n \nvoid func(void) {\n  c(a(), b());\n}\nIt is unspecified what order a() and b() are called in; the only guarantee is that both a() and b() will be called before c() is called. If a() or b() rely on shared state when calculating their return value, as they do in this example, the resulting arguments passed to c() may differ between compilers or architectures.\nCompliant Solution\nIn this compliant solution, the order of evaluation for a() and b() is fixed, and so no unspecified behavior occurs:\nextern void c(int i, int j);\nint glob;\n \nint a(void) {\n  return glob + 10;\n}\nint b(void) {\n  glob = 42;\n  return glob;\n}\n \nvoid func(void) {\n  int a_val, b_val;\n \n  a_val = a();\n  b_val = b();\n\n  c(a_val, b_val);\n}\nRisk Assessment\nAttempting to modify an object multiple times between sequence points may cause that object to take on an unexpected value, which can lead to unexpected program behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP30-C\nMedium\nProbable\nNo\nYes\nP8\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nevaluation-order\nmultiple-volatile-accesses\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP30\nClang\n3.9\n-Wunsequenced Detects simple violations of this rule, but does not diagnose unsequenced function call arguments.\nCodeSonar\n9.1p0\nLANG.STRUCT.SE.DEC\nLANG.STRUCT.SE.INC\nLANG.STRUCT.SE.INIT\nSide Effects in Expression with Decrement\nSide Effects in Expression with Increment\nSide Effects in Initializer List\nCompass/ROSE\n\n\nCan detect simple violations of this rule. It needs to examine each expression and make sure that no variable is modified twice in the expression. It also must check that no variable is modified once, then read elsewhere, with the single exception that a variable may appear on both the left and right of an assignment operator\nCoverity\n2017.07\nEVALUATION_ORDER\nCan detect the specific instance where a statement contains multiple side effects on the same value with an undefined evaluation order because, with different compiler flags or different compilers or platforms, the statement may behave differently\nCppcheck\n 2.15\nunknownEvaluationOrder\nCppcheck Premium\n24.11.0\nunknownEvaluationOrder\nECLAIR\n1.2\nCC2.EXP30\nFully implemented\nGCC\n4.3.5\n\nCan detect violations of this rule when the -Wsequence-point flag is used\nHelix QAC\n2025.2\nC0400, C0401, C0402, C0403, C0404, C0405 Fully implemented\nKlocwork\n2025.2\nPORTING.VAR.EFFECTS\nMISRA.INCR_DECR.OTHER\nFully implemented\nLDRA tool suite\n9.7.1\n35 D, 1 Q, 9 S, 30 S, 134 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP30-a\nCERT_C-EXP30-b\nCERT_C-EXP30-c\nCERT_C-EXP30-d\nThe value of an expression shall be the same under any order of evaluation that the standard permits\nDon't write code that depends on the order of evaluation of function arguments\nDon't write code that depends on the order of evaluation of function designator and function arguments\nDon't write code that depends on the order of evaluation of expression that involves a function call\nPC-lint Plus\n1.4\n564\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP30-C Checks for situations when expression value depends on order of evaluation or of side effects (rule partially covered)\n\nPVS-Studio\n7.38\nV532, V567\nRuleChecker\n24.04\nevaluation-order\nmultiple-volatile-accesses\nFully checked\nSecurity Reviewer - Static Reviewer\n6.02\nC50\nFully implemented\nSplint\n3.1.1\n\n\nSonarQube C/C++ Plugin\n3.11\nIncAndDecMixedWithOtherOperators\nTrustInSoft Analyzer\n1.38\nseparated\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C EXP50-CPP. Do not depend on the order of evaluation for side effects Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java EXP05-J. Do not follow a write by a subsequent write or read of the same object within an expression Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Operator Precedence/Order of Evaluation [JCW] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Side-effects and Order of Evaluation [SAM] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 13.2 (required)\nCERT cross-reference in MISRA C:2012 \u2013 Addendum 3\nCWE 2.11 CWE-758 2017-07-07: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-758 and EXP30-C\nIndependent( INT34-C, INT36-C, MEM30-C, MSC37-C, FLP32-C, EXP33-C, EXP30-C, ERR34-C, ARR32-C)\nCWE-758 = Union( EXP30-C, list) where list =\n\nUndefined behavior that results from anything other than reading and writing to a variable twice without an intervening sequence point.\n\nBibliography\n[ISO/IEC 9899:2011]\nAnnex C, \"Sequence Points\"\n[ISO/IEC 9899:2024]\n6.5, \"Expressions\"\n6.5.17.1, \"Assignment Operators\"\n6.5.3.3, \"Function Calls\"\n[Saks 2007]\n[Summit 2005] Questions 3.1, 3.2, 3.3, 3.3b, 3.7, 3.8, 3.9, 3.10a, 3.10b, and 3.11",
        "language": "C"
    },
    {
        "rule_id": "EXP32-C",
        "rule_title": "Do not access a volatile object through a nonvolatile reference",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP32-C.+Do+not+access+a+volatile+object+through+a+nonvolatile+reference",
        "content": "An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. Referencing a volatile object by using a non-volatile lvalue is undefined behavior. The C Standard, 6.7.4 paragraph 7 [ISO/IEC 9899:2024], states\nIf an attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type, the behavior is undefined.\nSee undefined behavior 62.\nNoncompliant Code Example\nIn this noncompliant code example, a volatile object is accessed through a non-volatile-qualified reference, resulting in undefined behavior 62:\n#include <stdio.h>\n  void func(void) {\n  static volatile int **ipp;\n  static int *ip;\n  static volatile int i = 0;\n   printf(\"i = %d.\\n\", i);\n   ipp = &ip; /* May produce a warning diagnostic */\n  ipp = (int**) &ip; /* Constraint violation; may produce a warning diagnostic */\n  *ipp = &i; /* Valid */\n  if (*ip != 0) { /* Valid */\n    /* ... */\n  }\n}\nThe assignment ipp = &ip is not safe because it allows the valid code that follows to reference the value of the volatile object i through the non-volatile-qualified reference ip. In this example, the compiler may optimize out the entire if block because *ip != 0 must be false if the object to which ip points is not volatile.\nImplementation Details\nThis example compiles without warning on Microsoft Visual Studio 2013 when compiled in C mode (/TC) but causes errors when compiled in C++ mode (/TP).\nGCC 4.8.1 generates a warning but compiles successfully.\nCompliant Solution\nIn this compliant solution, ip is declared volatile:\n#include <stdio.h>\n void func(void) {\n  static volatile int **ipp;\n  static volatile int *ip;\n  static volatile int i = 0;\n   printf(\"i = %d.\\n\", i);\n   ipp = &ip;\n  *ipp = &i;\n  if (*ip != 0) {\n    /* ... */\n  }\n }\nRisk Assessment\nAccessing an object with a volatile-qualified type through a reference with a non-volatile-qualified type is undefined behavior 62.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP32-C\nLow\nLikely\nNo\nYes\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\npointer-qualifier-cast-volatile\npointer-qualifier-cast-volatile-implicit\nSupported indirectly via MISRA C 2012 Rule 11.8\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP32 Fully implemented\nClang\n3.9\n-Wincompatible-pointer-types-discards-qualifiers\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nMISRA C 2012 Rule 11.8\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-exp32-c\nGCC\n4.3.5\n\nCan detect violations of this rule when the -Wcast-qual flag is used\nHelix QAC\n2025.2\nC0312, C0562, C0563, C0673, C0674 Fully implemented\nKlocwork\n2025.2\nCERT.EXPR.VOLATILE.ADDR\nCERT.EXPR.VOLATILE.ADDR.PARAM\nCERT.EXPR.VOLATILE.PTRPTR\nFully implemented\nLDRA tool suite\n9.7.1\n344 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP32-a\nA cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP32-C\nChecks for cast to pointer that removes const or volatile qualification (rule fully covered)\nRuleChecker\n24.04\npointer-qualifier-cast-volatile\npointer-qualifier-cast-volatile-implicit Supported indirectly via MISRA C 2012 Rule 11.8\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TR 24772:2013 Pointer Casting and Pointer Type Changes [HFC] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Type System [IHN] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 11.8 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C EXP55-CPP. Do not access a cv-qualified object through a cv-unqualified type Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 6.7.4, \"Type Qualifiers\"",
        "language": "C"
    },
    {
        "rule_id": "EXP33-C",
        "rule_title": "Do not read uninitialized memory",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory",
        "content": "Local, automatic variables assume unexpected values if they are read before they are initialized. The C Standard, 6.7.11, paragraph 11, specifies [ISO/IEC 9899:2024]\nIf an object that has automatic storage duration is not initialized explicitly, its representation is indeterminate.\nSee undefined behavior 11.\nWhen local, automatic variables are stored on the program stack, for example, their values default to whichever values are currently stored in stack memory.\nAdditionally, some dynamic memory allocation functions do not initialize the contents of the memory they allocate.\nFunction\nInitialization\naligned_alloc()\nDoes not perform initialization\ncalloc()\nZero-initializes allocated memory\nmalloc()\nDoes not perform initialization\nrealloc()\nCopies contents from original pointer; may not initialize all memory\nUninitialized automatic variables or dynamically allocated memory has indeterminate values, which for objects of some types, can be a trap representation. Reading such trap representations is undefined behavior; it can cause a program to behave in an unexpected manner and provide an avenue for attack. (See undefined behavior 10 and undefined behavior 12.)  In many cases, compilers issue a warning diagnostic message when reading uninitialized variables. (See MSC00-C. Compile cleanly at high warning levels for more information.)\nNoncompliant Code Example (Return-by-Reference)\nIn this noncompliant code example, the set_flag() function is intended to set the parameter, sign_flag, to the sign of number. However, the programmer neglected to account for the case where number is equal to 0. Because the local variable sign is uninitialized when calling set_flag() and is never written to by set_flag(), the comparison operation exhibits undefined behavior when reading sign.\nvoid set_flag(int number, int *sign_flag) {\n  if (NULL == sign_flag) {\n    return;\n  }\n   if (number > 0) {\n    *sign_flag = 1;\n  } else if (number < 0) {\n    *sign_flag = -1;\n  }\n}\n int is_negative(int number) {\n  int sign;\n  set_flag(number, &sign);\n  return sign < 0;\n}\nSome compilers assume that when the address of an uninitialized variable is passed to a function, the variable is initialized within that function. Because compilers frequently fail to diagnose any resulting failure to initialize the variable, the programmer must apply additional scrutiny to ensure the correctness of the code.\nThis defect results from a failure to consider all possible data states. (See MSC01-C. Strive for logical completeness for more information.)\nCompliant Solution (Return-by-Reference)\nThis compliant solution trivially repairs the problem by accounting for the possibility that number can be equal to 0.\nAlthough compilers and static analysis tools often detect uses of uninitialized variables when they have access to the source code, diagnosing the problem is difficult or impossible when either the initialization or the use takes place in object code for which the source code is inaccessible. Unless doing so is prohibitive for performance reasons, an additional defense-in-depth practice worth considering is to initialize local variables immediately after declaration.\nvoid set_flag(int number, int *sign_flag) {\n  if (NULL == sign_flag) {\n    return;\n  }\n   /* Account for number being 0 */\n  if (number >= 0) {\n    *sign_flag = 1;\n  } else {\n    *sign_flag = -1;\n  }\n}\n int is_negative(int number) {\n  int sign = 0; /* Initialize for defense-in-depth */\n  set_flag(number, &sign);\n  return sign < 0;\n}\nNoncompliant Code Example (Uninitialized Local)\nIn this noncompliant code example, the programmer mistakenly fails to set the local variable error_log to the msg argument in the report_error() function [Mercy 2006]. Because error_log has not been initialized, an indeterminate value is read. The sprintf() call copies data from the arbitrary location pointed to by the indeterminate error_log variable until a null byte is reached, which can result in a buffer overflow.\n#include <stdio.h>\n /* Get username and password from user, return -1 on error */\nextern int do_auth(void);\nenum { BUFFERSIZE = 24 }; \nvoid report_error(const char *msg) {\n  const char *error_log;\n  char buffer[BUFFERSIZE];\n   sprintf(buffer, \"Error: %s\", error_log);\n  printf(\"%s\\n\", buffer);\n}\n int main(void) {\n  if (do_auth() == -1) {\n    report_error(\"Unable to login\");\n  }\n  return 0;\n}\nNoncompliant Code Example (Uninitialized Local)\nIn this noncompliant code example, the report_error() function has been modified so that error_log is properly initialized:\n#include <stdio.h>\nenum { BUFFERSIZE = 24 }; \nvoid report_error(const char *msg) {\n  const char *error_log = msg;\n  char buffer[BUFFERSIZE];\n   sprintf(buffer, \"Error: %s\", error_log);\n  printf(\"%s\\n\", buffer);\n}\nThis example remains problematic because a buffer overflow will occur if the null-terminated byte string referenced by msg is greater than 17 characters, including the null terminator. (See STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator for more information.)\nCompliant Solution (Uninitialized Local)\nIn this compliant solution, the buffer overflow is eliminated by calling the snprintf() function:\n#include <stdio.h>\nenum { BUFFERSIZE = 24 };\nvoid report_error(const char *msg) {\n  char buffer[BUFFERSIZE];\n   if (0 < snprintf(buffer, BUFFERSIZE, \"Error: %s\", msg))\n    printf(\"%s\\n\", buffer);\n  else\n    puts(\"Unknown error\");\n}\nCompliant Solution (Uninitialized Local)\nA less error-prone compliant solution is to simply print the error message directly instead of using an intermediate buffer:\n#include <stdio.h>\n  void report_error(const char *msg) {\n  printf(\"Error: %s\\n\", msg);\n}\nNoncompliant Code Example (mbstate_t)\nIn this noncompliant code example, the function mbrlen() is passed the address of an automatic mbstate_t object that has not been properly initialized. This is undefined behavior 200 because mbrlen() dereferences and reads its third argument.\n#include <string.h>\n#include <wchar.h>\n  void func(const char *mbs) {\n  size_t len;\n  mbstate_t state;\n   len = mbrlen(mbs, strlen(mbs), &state);\n}\nCompliant Solution (mbstate_t)\nBefore being passed to a multibyte conversion function, an mbstate_t object must be either initialized to the initial conversion state or set to a value that corresponds to the most recent shift state by a prior call to a multibyte conversion function. This compliant solution sets the mbstate_t object to the initial conversion state by setting it to all zeros:\n#include <string.h>\n#include <wchar.h>\n  void func(const char *mbs) {\n  size_t len;\n  mbstate_t state;\n   memset(&state, 0, sizeof(state));\n  len = mbrlen(mbs, strlen(mbs), &state);\n}\nNoncompliant Code Example (POSIX, Entropy)\nIn this noncompliant code example described in \"More Randomness or Less\" [Wang 2012], the process ID, time of day, and uninitialized memory junk is used to seed a random number generator. This behavior is characteristic of some distributions derived from Debian Linux that use uninitialized memory as a source of entropy because the value stored in junk is indeterminate. However, because accessing an indeterminate value is undefined behavior 11, compilers may optimize out the uninitialized variable access completely, leaving only the time and process ID and resulting in a loss of desired entropy.\n#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n   void func(void) {\n  struct timeval tv;\n  unsigned long junk;\n   gettimeofday(&tv, NULL);\n  srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ junk);\n}\nIn security protocols that rely on unpredictability, such as RSA encryption, a loss in entropy results in a less secure system.\nCompliant Solution (POSIX, Entropy)\nThis compliant solution seeds the random number generator by using the CPU clock and the real-time clock instead of reading uninitialized memory:\n#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n void func(void) {    \n  double cpu_time;\n  struct timeval tv;\n   cpu_time = ((double) clock()) / CLOCKS_PER_SEC;\n  gettimeofday(&tv, NULL);\n  srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ cpu_time);\n}\nNoncompliant Code Example (realloc())\nThe realloc() function changes the size of a dynamically allocated memory object. The initial size bytes of the returned memory object are unchanged, but any newly added space is uninitialized, and its value is indeterminate. As in the case of malloc(), accessing memory beyond the size of the original object is undefined behavior 186.\nIt is the programmer's responsibility to ensure that any memory allocated with malloc() and realloc() is properly initialized before it is used.\nIn this noncompliant code example, an array is allocated with malloc() and properly initialized. At a later point, the array is grown to a larger size but not initialized beyond what the original array contained. Subsequently accessing the uninitialized bytes in the new array is undefined behavior.\n#include <stdlib.h>\n#include <stdio.h>\nenum { OLD_SIZE = 10, NEW_SIZE = 20 };\n  int *resize_array(int *array, size_t count) {\n  if (0 == count) {\n    return 0;\n  }\n    int *ret = (int *)realloc(array, count * sizeof(int));\n  if (!ret) {\n    free(array);\n    return 0;\n  }\n    return ret;\n}\n  void func(void) {\n    int *array = (int *)malloc(OLD_SIZE * sizeof(int));\n  if (0 == array) {\n    /* Handle error */\n  }\n    for (size_t i = 0; i < OLD_SIZE; ++i) {\n    array[i] = i;\n  }\n    array = resize_array(array, NEW_SIZE);\n  if (0 == array) {\n    /* Handle error */\n  }\n    for (size_t i = 0; i < NEW_SIZE; ++i) {\n    printf(\"%d \", array[i]);\n  }\n}\nCompliant Solution (realloc())\nIn this compliant solution, the resize_array() helper function takes a second parameter for the old size of the array so that it can initialize any newly allocated elements:\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n enum { OLD_SIZE = 10, NEW_SIZE = 20 };\n  int *resize_array(int *array, size_t old_count, size_t new_count) {\n  if (0 == new_count) {\n    return 0;\n  }\n    int *ret = (int *)realloc(array, new_count * sizeof(int));\n  if (!ret) {\n    free(array);\n    return 0;\n  }\n    if (new_count > old_count) {\n    memset(ret + old_count, 0, (new_count - old_count) * sizeof(int));\n  }\n    return ret;\n}\n  void func(void) {\n    int *array = (int *)malloc(OLD_SIZE * sizeof(int));\n  if (0 == array) {\n    /* Handle error */\n  }\n    for (size_t i = 0; i < OLD_SIZE; ++i) {\n    array[i] = i;\n  }\n    array = resize_array(array, OLD_SIZE, NEW_SIZE);\n  if (0 == array) {\n    /* Handle error */\n  }\n    for (size_t i = 0; i < NEW_SIZE; ++i) {\n    printf(\"%d \", array[i]);\n  }\n}\nExceptions\nEXP33-C-EX1: Reading uninitialized memory by an lvalue of type unsigned char that could not have been declared with the register storage class does not trigger undefined behavior. The unsigned char type is defined to not have a trap representation, which allows for moving bytes without knowing if they are initialized. (See the C Standard, 6.2.6.1, paragraph 3.) The requirement that register could not have been used (not merely that it was not used) is because on some architectures, such as the Intel Itanium, registers have a bit to indicate whether or not they have been initialized. The C Standard, 6.3.2.1, paragraph 2, allows such implementations to cause a trap for an object that never had its address taken and is stored in a register if such an object is referred to in any way.\nRisk Assessment\nReading uninitialized variables is undefined behavior 20 and can result in unexpected program behavior. In some cases, these security flaws may allow the execution of arbitrary code.\nReading uninitialized variables for creating entropy is problematic because these memory accesses can be removed by compiler optimization. VU#925211 is an example of a vulnerability caused by this coding error.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP33-C\nHigh\nProbable\nNo\nYes\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nuninitialized-local-read\nuninitialized-variable-use\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP33\nCodeSonar\n9.1p0\nLANG.MEM.UVAR Uninitialized variable\nCompass/ROSE\n\nAutomatically detects simple violations of this rule, although it may return some false positives. It may not catch more complex violations, such as initialization within functions taking uninitialized variables as arguments. It does catch the second noncompliant code example, and can be extended to catch the first as well\nCoverity\n2017.07\nUNINIT\nImplemented\nCppcheck\n 2.15\nuninitvar\nuninitdata\nuninitstring\nuninitMemberVar\nuninitStructMember\n\nCppcheck Premium\n24.11.0\nuninitvar\nuninitdata\nuninitstring\nuninitMemberVar\nuninitStructMember\nGCC 4.3.5\nCan detect some violations of this rule when the -Wuninitialized flag is used\nHelix QAC\n2025.2\nDF2726, DF2727, DF2728, DF2961, DF2962, DF2963, DF2966, DF2967, DF2968, DF2971, DF2972, DF2973, DF2976, DF2977, DF2978\nFully implemented\nKlocwork\n2025.2\nUNINIT.HEAP.MIGHT\nUNINIT.HEAP.MUST\nUNINIT.STACK.ARRAY.MIGHT\nUNINIT.STACK.ARRAY.MUST\nUNINIT.STACK.ARRAY.PARTIAL.MUST\nUNINIT.STACK.MIGHT\nUNINIT.STACK.MUST\nFully implemented\nLDRA tool suite\n9.7.1\n53 D, 69 D, 631 S, 652 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP33-a\nAvoid use before initialization\nParasoft Insure++\n2024.2\n\nRuntime analysis\nPC-lint Plus\n1.4\n530, 603, 644, 901\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP33-C\n\nChecks for:\nNon-initialized variable\nNon-initialized pointer\nRule partially covered\nPVS-Studio\n7.38\nV573, V614, V670, V679, V1050\n\nRuleChecker\n24.04\nuninitialized-local-read\nPartially checked\nSecurity Reviewer - Static Reviewer\n6.02\nC54\nC55\nC56\nC57\nC58\nC59\nC60\nC61\nC62\nC63\nFully implemented\nSplint 3.1.1\n\nTrustInSoft Analyzer\n1.38\ninitialisation\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nCVE-2009-1888 results from a violation of this rule. Some versions of SAMBA (up to 3.3.5) call a function that takes in two potentially uninitialized variables involving access rights. An attacker can exploit these coding errors to bypass the access control list and gain access to protected files [xorl 2009].\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard MSC00-C. Compile cleanly at high warning levels Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard MSC01-C. Strive for logical completeness Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C EXP53-CPP. Do not read uninitialized memory Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Initialization of Variables [LAV] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Referencing uninitialized memory [uninitref] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-456 2017-07-05: CERT: Exact\nCWE 2.11 CWE-457 2017-07-05: CERT: Exact\nCWE 2.11 CWE-758 2017-07-05: CERT: Rule subset of CWE\nCWE 2.11 CWE-908 2017-07-05: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-119 and EXP33-C\n\nIntersection( CWE-119, EXP33-C) = \u00d8\n\n\nEXP33-C is about reading uninitialized memory, but this memory is considered part of a valid buffer (on the stack, or returned by a heap function). No buffer overflow is involved.\n\nCWE-676 and EXP33-C\n\nIntersection( CWE-676, EXP33-C) = \u00d8\n\n\nEXP33-C implies that memory allocation functions (e.g., malloc()) are dangerous because they do not initialize the memory they reserve. However, the danger is not in their invocation, but rather reading their returned memory without initializing it.\n\nCWE-758 and EXP33-C\nIndependent( INT34-C, INT36-C, MSC37-C, FLP32-C, EXP33-C, EXP30-C, ERR34-C, ARR32-C)\nCWE-758 = Union( EXP33-C, list) where list =\n\nUndefined behavior that results from anything other than reading uninitialized memory\n\nCWE-665 and EXP33-C\nIntersection( CWE-665, EXP33-C) = \u00d8\nCWE-665 is about correctly initializing items (usually objects), not reading them later. EXP33-C is about reading memory later (that has not been initialized).\nCWE-908 and EXP33-C\nCWE-908 = Union( EXP33-C, list) where list =\n\nUse of uninitialized items besides raw memory (objects, disk space, etc)\n\nNew CWE-CERT mappings:\nCWE-123 and EXP33-C\nIntersection( CWE-123, EXP33-C) = \u00d8\nEXP33-C is only about reading uninitialized memory, not writing, whereas CWE-123 is about writing.\nCWE-824 and EXP33-C\nEXP33-C = Union( CWE-824, list) where list =\n\nRead of uninitialized memory that does not represent a pointer\n\nBibliography\n[Flake 2006]\n[ISO/IEC 9899:2024] Subclause 6.7.11, \"Initialization\"\nSubclause 6.2.6.1, \"General\"\nSubclause 6.3.2.1, \"Lvalues, Arrays, and Function Designators\"\n[Mercy 2006]\n[VU#925211]\n[Wang 2012] \"More Randomness or Less\"\n[xorl 2009] \"CVE-2009-1888: SAMBA ACLs Uninitialized Memory Read\"",
        "language": "C"
    },
    {
        "rule_id": "EXP34-C",
        "rule_title": "Do not dereference null pointers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP34-C.+Do+not+dereference+null+pointers",
        "content": "Dereferencing a null pointer is undefined behavior.\nOn many platforms, dereferencing a null pointer results in abnormal program termination, but this is not required by the standard. See \"Clever Attack Exploits Fully-Patched Linux Kernel\" [Goodin 2009] for an example of a code execution exploit that resulted from a null pointer dereference.\nNoncompliant Code Example\nThis noncompliant code example is derived from a real-world example taken from a vulnerable version of the libpng library as deployed on a popular ARM-based cell phone [Jack 2007]. The  libpng library allows applications to read, create, and manipulate PNG (Portable Network Graphics) raster image files. The libpng library implements its own wrapper to malloc() that returns a null pointer on error or on being passed a 0-byte-length argument.\nThis code also violates ERR33-C. Detect and handle standard library errors.\n#include <png.h> /* From libpng */\n#include <string.h>\n  void func(png_structp png_ptr, int length, const void *user_data) {\n  png_charp chunkdata;\n  chunkdata = (png_charp)png_malloc(png_ptr, length + 1);\n  /* ... */\n  memcpy(chunkdata, user_data, length);\n  /* ... */\n }\nIf length has the value \u22121, the addition yields 0, and png_malloc() subsequently returns a null pointer, which is assigned to chunkdata. The chunkdata pointer is later used as a destination argument in a call to memcpy(), resulting in user-defined data overwriting memory starting at address 0. In the case of the ARM and XScale architectures, the 0x0 address is mapped in memory and serves as the exception vector table; consequently, dereferencing 0x0 did not cause an abnormal program termination.\nCompliant Solution\nThis compliant solution ensures that the pointer returned by png_malloc() is not null. It also uses the unsigned type size_t to pass the length parameter, ensuring that negative values are not passed to func().\nThis solution also ensures that the user_data pointer is not null. Passing a null pointer to memcpy() would produce undefined behavior, even if the number of bytes to copy were 0.  The user_data pointer could be invalid in other ways, such as pointing to freed memory. However there is no portable way to verify that the pointer is valid, other than checking for null.\n#include <png.h> /* From libpng */\n#include <string.h>\n  void func(png_structp png_ptr, size_t length, const void *user_data) {\n  png_charp chunkdata;\n  if (length == SIZE_MAX) {\n    /* Handle error */\n  }\n  if (NULL == user_data) {\n    /* Handle error */\n  }\n  chunkdata = (png_charp)png_malloc(png_ptr, length + 1);\n  if (NULL == chunkdata) {\n    /* Handle error */\n  }\n  /* ... */\n  memcpy(chunkdata, user_data, length);\n  /* ... */\n  }\nNoncompliant Code Example\nIn this noncompliant code example, input_str is copied into dynamically allocated memory referenced by c_str. If malloc() fails, it returns a null pointer that is assigned to c_str. When c_str is dereferenced in memcpy(), the program exhibits undefined behavior.  Additionally, if input_str is a null pointer, the call to strlen() dereferences a null pointer, also resulting in undefined behavior. This code also violates ERR33-C. Detect and handle standard library errors.\n#include <string.h>\n#include <stdlib.h>\n  void f(const char *input_str) {\n  size_t size = strlen(input_str) + 1;\n  char *c_str = (char *)malloc(size);\n  memcpy(c_str, input_str, size);\n  /* ... */\n  free(c_str);\n  c_str = NULL;\n  /* ... */\n}\nCompliant Solution\nThis compliant solution ensures that both input_str and the pointer returned by malloc() are not null: \n#include <string.h>\n#include <stdlib.h>\n  void f(const char *input_str) {\n  size_t size;\n  char *c_str;\n    if (NULL == input_str) {\n    /* Handle error */\n  }\n     size = strlen(input_str) + 1;\n  c_str = (char *)malloc(size);\n  if (NULL == c_str) {\n    /* Handle error */\n  }\n  memcpy(c_str, input_str, size);\n  /* ... */\n  free(c_str);\n  c_str = NULL;\n  /* ... */\n}\nNoncompliant Code Example\nThis noncompliant code example is from a version of drivers/net/tun.c and affects Linux kernel 2.6.30 [Goodin 2009]:\nstatic unsigned int tun_chr_poll(struct file *file, poll_table *wait)  {\n  struct tun_file *tfile = file->private_data;\n  struct tun_struct *tun = __tun_get(tfile);\n  struct sock *sk = tun->sk;\n  unsigned int mask = 0;\n   if (!tun)\n    return POLLERR;\n   DBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n   poll_wait(file, &tun->socket.wait, wait);\n   if (!skb_queue_empty(&tun->readq))\n    mask |= POLLIN | POLLRDNORM;\n   if (sock_writeable(sk) ||\n     (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n     sock_writeable(sk)))\n    mask |= POLLOUT | POLLWRNORM;\n   if (tun->dev->reg_state != NETREG_REGISTERED)\n    mask = POLLERR;\n   tun_put(tun);\n  return mask;\n}\nThe sk pointer is initialized to tun->sk before checking if tun is a null pointer. Because null pointer dereferencing is undefined behavior, the compiler (GCC in this case) can optimize away the if (!tun) check because it is performed after tun->sk is accessed, implying that tun is non-null. As a result, this noncompliant code example is vulnerable to a null pointer dereference exploit, because null pointer dereferencing can be permitted on several platforms, for example, by using mmap(2) with the MAP_FIXED flag on Linux and Mac OS X, or by using the shmat() POSIX function with the SHM_RND flag [Liu 2009].\nCompliant Solution\nThis compliant solution eliminates the null pointer deference by initializing sk to tun->sk following the null pointer check. It also adds assertions to document that certain other pointers must not be null.\nstatic unsigned int tun_chr_poll(struct file *file, poll_table *wait)  {\n  assert(file);\n  struct tun_file *tfile = file->private_data;\n  struct tun_struct *tun = __tun_get(tfile);\n  struct sock *sk;\n  unsigned int mask = 0;\n   if (!tun)\n    return POLLERR;\n  assert(tun->dev);\n  sk = tun->sk;\n  assert(sk);\n  assert(sk->socket);\n  /* The remaining code is omitted because it is unchanged... */\n}\nRisk Assessment\nDereferencing a null pointer is undefined behavior, typically abnormal program termination. In some situations, however, dereferencing a null pointer can lead to the execution of arbitrary code [Jack 2007, van Sprundel 2006]. The indicated severity is for this more severe case; on platforms where it is not possible to exploit a null pointer dereference to execute arbitrary code, the actual severity is low.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP34-C\nHigh\nLikely\nNo\nYes\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nnull-dereferencing Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP34\nCodeSonar\n9.1p0\nLANG.MEM.NPD\nLANG.STRUCT.NTAD\nLANG.STRUCT.UPD\nNull pointer dereference\nNull test after dereference\nUnchecked parameter dereference\nCompass/ROSE\n\nCan detect violations of this rule. In particular, ROSE ensures that any pointer returned by malloc(), calloc(), or realloc() is first checked for NULL before being used (otherwise, it is free()-ed). ROSE does not handle cases where an allocation is assigned to an lvalue that is not a variable (such as a struct member or C++ function call returning a reference)\nCoverity\n\n2017.07\nCHECKED_RETURN\nNULL_RETURNS\nREVERSE_INULL\nFORWARD_NULL\nFinds instances where a pointer is checked against NULL and then later dereferenced\nIdentifies functions that can return a null pointer but are not checked\nIdentifies code that dereferences a pointer and then checks the pointer against NULL\nCan find the instances where NULL is explicitly dereferenced or a pointer is checked against NULL but then dereferenced anyway. Coverity Prevent cannot discover all violations of this rule, so further verification is necessary\nCppcheck\n 2.15\nnullPointer, nullPointerDefaultArg, nullPointerRedundantCheck\n\nCppcheck Premium\n24.11.0\nnullPointer, nullPointerDefaultArg, nullPointerRedundantCheck\n\nHelix QAC\n2025.2\nDF2810, DF2811, DF2812, DF2813\nFully implemented\nKlocwork\n2025.2\nNPD.CHECK.CALL.MIGHT\nNPD.CHECK.CALL.MUST\nNPD.CHECK.MIGHT\nNPD.CHECK.MUST\nNPD.CONST.CALL\nNPD.CONST.DEREF\nNPD.FUNC.CALL.MIGHT\nNPD.FUNC.CALL.MUST\nNPD.FUNC.MIGHT\nNPD.FUNC.MUST\nNPD.GEN.CALL.MIGHT\nNPD.GEN.CALL.MUST\nNPD.GEN.MIGHT\nNPD.GEN.MUST\nRNPD.CALL\nRNPD.DEREF\nFully implemented\nLDRA tool suite\n9.7.1\n45 D, 123 D, 128 D, 129 D, 130 D, 131 D, 652 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP34-a\nAvoid null pointer dereferencing\nParasoft Insure++\n\nRuntime analysis\nPC-lint Plus\n1.4\n413, 418, 444, 613, 668\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP34-C\n\nChecks for use of null pointers (rule partially covered)\nPVS-Studio\n7.38\nV522, V595, V664, V713, V1004\nSecurity Reviewer - Static Reviewer\n6.02\nC64\nC65\nC66 Fully implemented\nSonarQube C/C++ Plugin\n3.11\nS2259\nSplint\n3.1.1\n\n\nTrustInSoft Analyzer\n1.38\nmem_access Exhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT Oracle Secure Coding Standard for Java EXP01-J. Do not use a null in a case where an object is required Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Pointer Casting and Pointer Type Changes [HFC] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Null Pointer Dereference [XYH] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Dereferencing an out-of-domain pointer [nullref] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-476, NULL Pointer Dereference 2017-07-06: CERT: Exact\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-690 and EXP34-C\nEXP34-C = Union( CWE-690, list) where list =\n\nDereferencing null pointers that were not returned by a function\n\nCWE-252 and EXP34-C\nIntersection( CWE-252, EXP34-C) = \u00d8\nEXP34-C is a common consequence of ignoring function return values, but it is a distinct error, and can occur in other scenarios too.\nBibliography \n[Goodin 2009]\n[Jack 2007]\n[Liu 2009]\n[van Sprundel 2006]\n[Viega 2005] Section 5.2.18, \"Null-Pointer Dereference\"",
        "language": "C"
    },
    {
        "rule_id": "EXP35-C",
        "rule_title": "Do not modify objects with temporary lifetime",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP35-C.+Do+not+modify+objects+with+temporary+lifetime",
        "content": "The C11 Standard [ISO/IEC 9899:2011] introduced a new term: temporary lifetime. This term still remains in the C23 Standard. Modifying an object with temporary lifetime is undefined behavior. According to subclause 6.2.4, paragraph 8 [ISO/IEC 9899:2024]\nA non-lvalue expression with structure or union type, where the structure or union contains a member with array type (including, recursively, members of all contained structures and unions) refers to an object with automatic storage duration and temporary lifetime. Its lifetime begins when the expression is evaluated and its initial value is the value of the expression. Its lifetime ends when the evaluation of the containing full expression ends. Any attempt to modify an object with temporary lifetime results in undefined behavior.\nThis definition differs from the C99 Standard (which defines modifying the result of a function call or accessing it after the next sequence point as undefined behavior) because a temporary object's lifetime ends when the evaluation containing the full expression or full declarator ends, so the result of a function call can be accessed. This extension to the lifetime of a temporary also removes a quiet change to C90 and improves compatibility with C++. \nC functions may not return arrays; however, functions can return a pointer to an array or a  struct or union that contains arrays. Consequently, in any version of C, if a function call returns by value a struct or union containing an array, do not modify those arrays within the expression containing the function call. In C99 and older, do not access an array returned by a function after the next sequence point or after the evaluation of the containing full expression or full declarator ends.\nNoncompliant Code Example\nThis noncompliant code example conforms to the C11 Standard; however, it fails to conform to C99. If compiled with a C99-conforming implementation, this code has undefined behavior 34 because the sequence point preceding the call to printf() comes between the call and the access by printf() of the string in the returned object.\n#include <stdio.h>\n struct X { char a[8]; };\n struct X salutation(void) {\n  struct X result = { \"Hello\" };\n  return result;\n}\n struct X addressee(void) {\n  struct X result = { \"world\" };\n  return result;\n}\n int main(void) {\n  printf(\"%s, %s!\\n\", salutation().a, addressee().a);\n  return 0;\n}\nCompliant Solution (C11 and newer)\nThis compliant solution checks __STDC_VERSION__ to ensure that a pre-C11 compiler will fail to compile the code, rather than invoking undefined behavior.\n#include <stdio.h>\n #if __STDC_VERSION__ < 201112L\n#error This code requires a compiler supporting the C11 standard or newer\n#endif\n struct X { char a[8]; };\n struct X salutation(void) {\n  struct X result = { \"Hello\" };\n  return result;\n}\n struct X addressee(void) {\n  struct X result = { \"world\" };\n  return result;\n}\n int main(void) {\n  printf(\"%s, %s!\\n\", salutation().a, addressee().a);\n  return 0;\n}\nCompliant Solution\nThis compliant solution stores the structures returned by the call to addressee() before calling the printf() function. Consequently, this program conforms to both C99 and C11.\n#include <stdio.h>\n struct X { char a[8]; };\n  struct X salutation(void) {\n  struct X result = { \"Hello\" };\n  return result;\n}\n struct X addressee(void) {\n  struct X result = { \"world\" };\n  return result;\n}\n int main(void) {\n  struct X my_salutation = salutation();\n  struct X my_addressee = addressee();\n    printf(\"%s, %s!\\n\", my_salutation.a, my_addressee.a);\n  return 0;\n}\nNoncompliant Code Example\nThis noncompliant code example attempts to retrieve an array and increment the array's first value. The array is part of a struct that is returned by a function call. Consequently, the array has temporary lifetime, and modifying the array is undefined behavior in both C99 and C11.\n#include <stdio.h>\n struct X { int a[6]; };\n struct X addressee(void) {\n  struct X result = { { 1, 2, 3, 4, 5, 6 } };\n  return result;\n}\n int main(void) {\n  printf(\"%x\", ++(addressee().a[0]));\n  return 0;\n}\nCompliant Solution\nThis compliant solution stores the structure returned by the call to addressee() as my_x before calling the printf() function. When the array is modified, its lifetime is no longer temporary but matches the lifetime of the block in main().\n#include <stdio.h>\n struct X { int a[6]; };\n struct X addressee(void) {\n  struct X result = { { 1, 2, 3, 4, 5, 6 } };\n  return result;\n}\n int main(void) {\n  struct X my_x = addressee();\n  printf(\"%x\", ++(my_x.a[0]));\n  return 0;\n}\nNoncompliant Code Example\nThis noncompliant code example attempts to save a pointer to an array that is part of a struct that is returned by a function call. Consequently, the array has temporary lifetime, and using the pointer to it outside of the full expression is undefined behavior in both C99 and C11.\n#include <stdio.h>\n struct X { int a[6]; };\n struct X addressee(void) {\n  struct X result = { { 1, 2, 3, 4, 5, 6 } };\n  return result;\n}\n int main(void) {\n  int *my_a = addressee().a;\n  printf(\"%x\", my_a[0]);\n  return 0;\n}\nCompliant Solution\nThis compliant solution stores the structure returned by the call to addressee() as my_x before saving a pointer to its array member. When the pointer is used, its lifetime is no longer temporary but matches the lifetime of the block in main().\n#include <stdio.h>\n struct X { int a[6]; };\n struct X addressee(void) {\n  struct X result = { { 1, 2, 3, 4, 5, 6 } };\n  return result;\n}\n int main(void) {\n  struct X my_x = addressee();\n  int *my_a = my_x.a;\n  printf(\"%x\", my_a[0]);\n  return 0;\n}\nRisk Assessment\nAttempting to modify an array or access it after its lifetime expires may result in erroneous program behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP35-C\nLow\nProbable\nYes\nYes\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ntemporary-object-modification Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP35\nCodeSonar\n9.1p0\nLANG.CAST.ARRAY.TEMP\nArray to Pointer Conversion on Temporary Object\nCppcheck Premium\n24.11.0\npremium-cert-exp35-c\nHelix QAC\n2025.2\nC0450, C0455, C0459, C0464, C0465\nC++3807, C++3808\nFully implemented\nLDRA tool suite\n9.7.1\n642 S, 42 D, 77 D Enhanced Enforcement\nParasoft C/C++test\n2024.2\nCERT_C-EXP35-a\nDo not modify objects with temporary lifetime\nPolyspace Bug Finder\nR2025b\nCERT-C: Rule EXP35-C Checks for accesses on objects with temporary lifetime (rule fully covered)\nSplint\n3.1.1\n\n\nRuleChecker\n24.04\ntemporary-object-modification Partially checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TR 24772:2013 Dangling References to Stack Frames [DCM] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Side-effects and Order of Evaluation [SAM] Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 6.2.4, \"Storage Durations of Objects\"",
        "language": "C"
    },
    {
        "rule_id": "EXP36-C",
        "rule_title": "Do not cast pointers into more strictly aligned pointer types",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP36-C.+Do+not+cast+pointers+into+more+strictly+aligned+pointer+types",
        "content": "Do not convert a pointer value to a pointer type that is more strictly aligned than the referenced type. Different alignments are possible for different types of objects. If the type-checking system is overridden by an explicit cast or the pointer is converted to a void pointer (void *) and then to a different type, the alignment of an object may be changed.\nThe C Standard, 6.3.2.3, paragraph 7 [ISO/IEC 9899:2024], states\nA pointer to an object type may be converted to a pointer to a different object type. If the resulting pointer is not correctly aligned for the referenced type, the behavior is undefined.\nSee undefined behavior 24.\nIf the misaligned pointer is dereferenced, the program may terminate abnormally. On some architectures, the cast alone may cause a loss of information even if the value is not dereferenced if the types involved have differing alignment requirements.\nNoncompliant Code Example\nIn this noncompliant example, the char pointer &c is converted to the more strictly aligned int pointer ip. On some implementations, cp will not match &c. As a result, if a pointer to one object type is converted to a pointer to a different object type, the second object type must not require stricter alignment than the first.\n#include <assert.h>\n  void func(void) {\n  char c = 'x';\n  int *ip = (int *)&c; /* This can lose information */\n  char *cp = (char *)ip;\n   /* Will fail on some conforming implementations */\n  assert(cp == &c);\n}\nCompliant Solution (Intermediate Object)\nIn this compliant solution, the char value is stored into an object of type int so that the pointer's value will be properly aligned:\n#include <assert.h>\n  void func(void) {\n  char c = 'x';\n  int i = c;\n  int *ip = &i;\n   assert(ip == &i);\n}\nNoncompliant Code Example\nThe C Standard allows any object pointer to be cast to and from void *. As a result, it is possible to silently convert from one pointer type to another without the compiler diagnosing the problem by storing or casting a pointer to void * and then storing or casting it to the final type. In this noncompliant code example, loop_function() is passed the char pointer char_ptr but returns an object of type int pointer:\nint *loop_function(void *v_pointer) {\n  /* ... */\n  return v_pointer;\n}\n  void func(char *char_ptr) {\n  int *int_ptr = loop_function(char_ptr);\n   /* ... */\n}\nThis example compiles without warning using GCC 4.8 on Ubuntu Linux 14.04. However, int_pointer can be more strictly aligned than an object of type char *.\nCompliant Solution\nBecause the input parameter directly influences the return value, and loop_function() returns an object of type int *, the formal parameter v_pointer is redeclared to accept only an object of type int *:\nint *loop_function(int *v_pointer) {\n  /* ... */\n  return v_pointer;\n}\n  void func(int *loop_ptr) {\n  int *int_ptr = loop_function(loop_ptr);\n   /* ... */\n}\nNoncompliant Code Example\nSome architectures require that pointers are correctly aligned when accessing objects larger than a byte. However, it is common in system code that unaligned data (for example, the network stacks) must be copied to a properly aligned memory location, such as in this noncompliant code example:\n#include <string.h>\n  struct foo_header {\n  int len;\n  /* ... */\n};\n  void func(char *data, size_t offset) {\n  struct foo_header *tmp;\n  struct foo_header header;\n   tmp = (struct foo_header *)(data + offset);\n  memcpy(&header, tmp, sizeof(header));\n   /* ... */\n}\nAssigning an unaligned value to a pointer that references a type that needs to be aligned is undefined behavior 24. An implementation may notice, for example, that tmp and header must be aligned and use an inline memcpy() that uses instructions that assume aligned data.\nCompliant Solution\nThis compliant solution avoids the use of the foo_header pointer:\n#include <string.h>\n  struct foo_header {\n  int len;\n  /* ... */\n};\n   void func(char *data, size_t offset) {\n  struct foo_header header;\n  memcpy(&header, data + offset, sizeof(header));\n   /* ... */\n}\nExceptions\nEXP36-C-EX1: Some hardware architectures have relaxed requirements with regard to pointer alignment. Using a pointer that is not properly aligned is correctly handled by the architecture, although there might be a performance penalty. On such an architecture, improper pointer alignment is permitted but remains an efficiency problem.\nThe x86 32- and 64-bit architectures usually impose only a performance penalty for violations of this rule, but under some circumstances, noncompliant code can still exhibit undefined behavior. Consider the following program:\n#include <stdio.h>\n#include <stdint.h>\n #define READ_UINT16(ptr)       (*(uint16_t *)(ptr))\n#define WRITE_UINT16(ptr, val) (*(uint16_t *)(ptr) = (val))\n void compute(unsigned char *b1, unsigned char *b2,\n             int value, int range) {\n  int i;\n  for (i = 0; i < range; i++) {\n    int newval = (int)READ_UINT16(b1) + value;\n    WRITE_UINT16(b2, newval);\n    b1 += 2;\n    b2 += 2;\n  }\n}\n int main() {\n  unsigned char buffer1[1024];\n  unsigned char buffer2[1024];\n  printf(\"Compute something\\n\");\n  compute(buffer1 + 3, buffer2 + 1, 42, 500);\n  return 0;\n}\nThis code tries to read short ints (which are 16 bits long) from odd pairs in a character array, which violates this rule. On 32- and 64-bit x86 platforms, this program should run to completion without incident. However, the program aborts with a SIGSEGV due to the unaligned reads on a 64-bit platform running Debian Linux, when compiled with GCC 4.9.4 using the flags  -O3   or  -O2 -ftree-loop-vectorize -fvect-cost-model.\nIf a developer wishes to violate this rule and use undefined behavior, they must not only ensure that the hardware guarantees the behavior of the object code, but they must also ensure that their compiler, along with its optimizer, also respect these guarantees.\n\nEXP36-C-EX2: If a pointer is known to be correctly aligned to the target type, then a cast to that type is permitted. There are several cases where a pointer is known to be correctly aligned to the target type. The pointer could point to an object declared with a suitable alignment specifier. It could point to an object returned by aligned_alloc(), calloc(), malloc(), or realloc(), as per the C standard, section 7.24.3, paragraph 1  [ISO/IEC 9899:2024].\nThis compliant solution uses the alignment specifier, which is new to C11, to declare the char object c with the same alignment as that of an object of type int. As a result, the two pointers reference equally aligned pointer types:\n#include <stdalign.h>\n#include <assert.h>\n  void func(void) {\n  /* Align c to the alignment of an int */\n  alignas(int) char c = 'x';\n  int *ip = (int *)&c;\n  char *cp = (char *)ip;\n  /* Both cp and &c point to equally aligned objects */\n  assert(cp == &c);\n}\nRisk Assessment\nAccessing a pointer or an object that is not properly aligned can cause a program to crash or give erroneous information, or it can cause slow pointer accesses (if the architecture allows misaligned accesses).\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP36-C\nLow\nProbable\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\npointer-cast-alignment Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP36\nCodeSonar\n9.1p0\nLANG.CAST.PC.OBJ\nLANG.CAST.PC.VBASE\nLANG.CAST.PC.DCVBASE\nCast: object pointers\nCast: virtual base to derived\nDerived Class From Virtual Base\nCompass/ROSE\n\nCan detect violations of this rule. However, it does not flag explicit casts to void * and then back to another pointer type\nCoverity\n2017.07\nMISRA C 2004 Rule 11.4\nMISRA C 2012 Rule 11.1\nMISRA C 2012 Rule 11.2\nMISRA C 2012 Rule 11.5\nMISRA C 2012 Rule 11.7\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-exp36-c\nECLAIR\n1.2\nCC2.EXP36\nFully implemented\nEDG\n\n\nGCC\n4.3.5\n\nCan detect some violations of this rule when the -Wcast-align flag is used\nHelix QAC\n2025.2\nC0326, C3305\nC++3033, C++3038\n\nKlocwork\n 2025.2\nMISRA.CAST.OBJ_PTR_TO_OBJ_PTR.2012\nLDRA tool suite\n9.7.1\n94 S, 606 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP36-a\nDo not cast pointers into more strictly aligned pointer types\nPC-lint Plus\n1.4\n2445\nPartially supported: reports casts directly from a pointer to a less strictly aligned type to a pointer to a more strictly aligned type\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP36-C\nChecks for source buffer misaligned with destination buffer (rule fully covered)\nPVS-Studio\n7.38\nV548, V641, V1032\n\nRuleChecker\n24.04\npointer-cast-alignment Fully checked\nSecurity Reviewer - Static Reviewer\n6.02\nC67\nC68\nC69\nC70 Fully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C VOID EXP56-CPP. Do not cast pointers into more strictly aligned pointer types Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Pointer Casting and Pointer Type Changes [HFC] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Converting pointer values to more strictly aligned pointer types [alignconv] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 11.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 11.2 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 11.5 (advisory) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 11.7 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[Bryant 2003]\n[ISO/IEC 9899:2024] 6.3.2.3, \"Pointers\"\n[Walfridsson 2003] Aliasing, Pointer Casts and GCC 3.3",
        "language": "C"
    },
    {
        "rule_id": "EXP37-C",
        "rule_title": "Call functions with the correct number and type of arguments",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP37-C.+Call+functions+with+the+correct+number+and+type+of+arguments",
        "content": "Do not call a function with the wrong number or type of arguments. \nThe C Standard identifies two distinct situations in which undefined behavior (UB) may arise as a result of invoking a function using a declaration that is incompatible with its definition or by supplying incorrect types or numbers of arguments:\nUB Description\n25\nA pointer is used to call a function whose type is not compatible with the referenced type (6.3.2.3).\n37\nA function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function (6.5.2.2).\nFunctions that are appropriately declared (as in DCL40-C. Do not create incompatible declarations of the same function or object) will typically generate a compiler diagnostic message if they are supplied with the wrong number or types of arguments. However, there are cases in which supplying the incorrect arguments to a function will, at best, generate compiler warnings. Although such warnings should be resolved, they do not prevent program compilation. (See MSC00-C. Compile cleanly at high warning levels.)\nNoncompliant Code Example\nThe header <tgmath.h> provides type-generic macros for math functions. Although most functions from the <math.h> header have a complex counterpart in <complex.h>, several functions do not. Calling any of the following type-generic functions with complex values is undefined behavior 205.\nFunctions That Should Not Be Called with Complex Values\natan2() erf() fdim() fmin() ilogb() llround() logb() nextafter() rint() tgamma()\ncbrt() erfc() floor() fmod() ldexp() log10() lrint() nexttoward() round() trunc()\nceil() exp2() fma() frexp() lgamma() log1p() lround() remainder() scalbn()\ncopysign() expm1() fmax() hypot() llrint() log2() nearbyint() remquo() scalbln()\n\nThis noncompliant code example attempts to take the base-2 logarithm of a complex number, resulting in undefined behavior:\n#include <tgmath.h>\n \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log2(c);\n}\nCompliant Solution (Complex Number)\nIf the clog2() function is not available for an implementation as an extension, the programmer can take the base-2 logarithm of a complex number, using log() instead of log2(), because log() can be used on complex arguments, as shown in this compliant solution:\n#include <tgmath.h>\n \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log(c)/log(2);\n}\nCompliant Solution (Real Number)\nThe programmer can use this compliant solution if the intent is to take the base-2 logarithm of the real part of the complex number:\n#include <tgmath.h>\n \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log2(creal(c));\n}\nNoncompliant Code Example\nIn this noncompliant example, the C standard library function strchr() is called through the function pointer fp declared with a prototype with incorrectly typed arguments. According to the C Standard, 6.3.2.3, paragraph 8 [ISO/IEC 9899:2024]\nA pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined.\nSee undefined behavior 25.\n#include <stdio.h>\n#include <string.h>\n\nchar *(*fp)();\n\nint main(void) {\n  const char *c;\n  fp = strchr;\n  c = fp('e', \"Hello\");\n  printf(\"%s\\n\", c);\n  return 0;\n}\nCompliant Solution\nIn this compliant solution, the function pointer fp, which points to the C standard library function strchr(), is declared with the correct parameters and is invoked with the correct number and type of arguments:\n#include <stdio.h>\n#include <string.h>\n\nchar *(*fp)(const char *, int);\n\nint main(void) {\n  const char *c;\n  fp = strchr;\n  c = fp(\"Hello\",'e');\n  printf(\"%s\\n\", c);\n  return 0;\n}\nNoncompliant Code Example\nIn this noncompliant example, the function f() is defined to take an argument of type long but f() is called from another file with an argument of type int:\n/* In another source file */\nlong f(long x) {\n  return x < 0 ? -x : x;\n}\n\n/* In this source file, no f prototype in scope */\nlong f();\n \nlong g(int x) {\n  return f(x);\n}\nCompliant Solution\nIn this compliant solution, the prototype for the function f() is included in the source file in the scope of where it is called, and the function f() is correctly called with an argument of type long:\n/* In another source file */\n \nlong f(long x) {\n  return x < 0 ? -x : x;\n}\n\n/* f prototype in scope in this source file */\n\nlong f(long x); \n\nlong g(int x) {\n  return f((long)x);  \n}\nNoncompliant Code Example (POSIX)\nThe POSIX function open() [IEEE Std 1003.1:2013] is a variadic function with the following prototype:\nint open(const char *path, int oflag, ... );\nThe open() function accepts a third argument to determine a newly created file's access mode. If open() is used to create a new file and the third argument is omitted, the file may be created with unintended access permissions. (See FIO06-C. Create files with appropriate access permissions.)\nIn this noncompliant code example from a vulnerability in the useradd() function of the shadow-utils package CVE-2006-1174, the third argument to open() is accidentally omitted:\nfd = open(ms, O_CREAT | O_EXCL | O_WRONLY | O_TRUNC);\nTechnically, it is incorrect to pass a third argument to open() when not creating a new file (that is, with the O_CREAT flag not set).\nCompliant Solution (POSIX)\nIn this compliant solution, a third argument is specified in the call to open():\n#include <fcntl.h>\n \nvoid func(const char *ms, mode_t perms) {\n  /* ... */\n  int fd;\n  fd = open(ms, O_CREAT | O_EXCL | O_WRONLY | O_TRUNC, perms);\n  if (fd == -1) {\n    /* Handle error */\n  }\n}\nRisk Assessment\nCalling a function with incorrect arguments can result in unexpected or unintended program behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP37-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool Version Checker Description\nAstr\u00e9e\n24.04\nincompatible-argument-type\nparameter-match\nparameter-match-computed\nparameter-match-type\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP37\nCodeSonar\n9.1p0\nLANG.FUNCS.APM\nArray parameter mismatch\nCompass/ROSE\n\nCan detect some violations of this rule. In particular, it ensures that all calls to open() supply exactly two arguments if the second argument does not involve O_CREAT, and exactly three arguments if the second argument does involve O_CREAT\nCoverity\n2017.07\nMISRA C 2012 Rule 8.2\nMISRA C 2012 Rule 17.3\nImplemented\nRelies on functions declared with prototypes, allow compiler to check\nCppcheck Premium\n24.11.0\npremium-cert-exp37-c\nECLAIR\n1.2\nCC2.EXP37\nPartially implemented\nEDG\n\n\nGCC\n4.3.5\n\nCan detect violation of this rule when the -Wstrict-prototypes flag is used. However, it cannot detect violations involving variadic functions, such as the open() example described earlier\nHelix QAC\n2025.2\nC1331, C1332, C1333, C3002, C3320, C3335\nC++0403\n\nKlocwork\n2025.2\nMISRA.FUNC.UNMATCHED.PARAMS\nLDRA tool suite\n9.7.1\n41 D, 21 S, 98 S, 170 S, 496 S, 576 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP37-a\nCERT_C-EXP37-b\nCERT_C-EXP37-d\nConversions shall not be performed between non compatible pointer to a function types\nSpecify the access permission bits if a file is created using the 'open' or 'openat' system call\nFunctions shall always have visible prototype at the function call\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP37-C\nChecks for:\nImplicit function declaration\nBad file access mode or status\nUnreliable cast of function pointer\nStandard function call with incorrect arguments\nRule partially covered.\nPVS-Studio\n7.38\nV540, V541, V549, V575, V632, V639, V666, V671, V742, V743, V764, V1004\nSecurity Reviewer - Static Reviewer\n6.02\nC71 Fully implemented\nSonarQube C/C++ Plugin\n3.11\nS930 Detects incorrect argument count\nRuleChecker\n24.04\nparameter-match\nparameter-match-type\nPartially checked\nTrustInSoft Analyzer\n1.38\nunclassified (\"function type matches\") Partially verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard DCL07-C. Include the appropriate type information in function declarators Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard MSC00-C. Compile cleanly at high warning levels Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard FIO06-C. Create files with appropriate access permissions Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Subprogram Signature Mismatch [OTR] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Calling functions with incorrect arguments [argcomp] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 8.2 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 17.3 (mandatory) Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-628, Function Call with Incorrectly Specified Arguments 2017-07-05: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-685 and EXP37-C\nEXP37-C = Union( CWE-685, CWE-686) Intersection( CWE-685, CWE-686) = \u00d8\nCWE-686 and EXP37-C\nIntersection( EXP37-C, FIO47-C) =\n\nInvalid argument types passed to format I/O function\n\nEXP37-C \u2013 FIO47-C =\n\nInvalid argument types passed to non-format I/O function\n\nFIO47-C \u2013 EXP37-C =\n\nInvalid format string, but correctly matches arguments in number and type\n\nEXP37-C = Union( CWE-685, CWE-686)\nIntersection( CWE-685, CWE-686) = \u00d8\nCWE-628 and EXP37-C\nCWE-628 = Union( EXP37-C, list) where list =\n\nImproper ordering of function arguments (that does not violate argument types)\n\n\nWrong argument values or references\n\nBibliography\n[CVE] CVE-2006-1174\n[ISO/IEC 9899:2011] 6.5.2.2, \"Function Calls\"\n[ISO/IEC 9899:2024] 6.3.2.3, \"Pointers\"\n[IEEE Std 1003.1:2013] open()\n[Spinellis 2006] Section 2.6.1, \"Incorrect Routine or Arguments\"",
        "language": "C"
    },
    {
        "rule_id": "EXP39-C",
        "rule_title": "Do not access a variable through a pointer of an incompatible type",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP39-C.+Do+not+access+a+variable+through+a+pointer+of+an+incompatible+type",
        "content": "Modifying a variable through a pointer of an incompatible type (other than unsigned char) can lead to unpredictable results. Subclause 6.2.7 of the C Standard states that two types may be distinct yet compatible and addresses precisely  when two distinct types are compatible.\nThis problem is often caused by a violation of aliasing rules. The C Standard, 6.5, paragraph 7 [ ISO/IEC 9899:2024 ], specifies those circumstances in which an object may or may not be aliased.\nAn object shall have its stored value accessed only by an lvalue expression that has one of the following types:\na type compatible with the effective type of the object,\na qualified version of a type compatible with the effective type of the object, \nthe signed or unsigned type compatible with the underlying type of the effective type of the object,\nthe signed or unsigned type compatible with a qualified version of the underlying type of the effective type of the object, \nan aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union), or \na character type. \nAccessing an object by means of any other lvalue expression (other than unsigned char) is undefined behavior 36.\nNoncompliant Code Example\nIn this noncompliant example, an object of type float is incremented through an int *. The programmer can use the unit in the last place to get the next representable value for a floating-point type.  However, accessing an object through a pointer of an incompatible type is undefined behavior.\n#include <stdio.h>\n  void f(void) {\n  if (sizeof(int) == sizeof(float)) {\n    float f = 0.0f;\n    int *ip = (int *)&f;\n    (*ip)++;\n    printf(\"float is %f\\n\", f);\n  }\n}\nCompliant Solution\nIn this compliant solution, the standard C function nextafterf() is used to round toward the highest representable floating-point value:\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n  void f(void) {\n  float f = 0.0f;\n  f = nextafterf(f, FLT_MAX);\n  printf(\"float is %f\\n\", f);\n}\nNoncompliant Code Example\nIn this noncompliant code example, an array of two values of type short is treated as an integer and assigned an integer value. The resulting values are indeterminate.\n#include <stdio.h>\n  void func(void) {\n  short a[2];\n  a[0]=0x1111;\n  a[1]=0x1111;\n   *(int *)a = 0x22222222;\n   printf(\"%x %x\\n\", a[0], a[1]);\n}\nWhen translating this code, an implementation can assume that no access through an integer pointer can change the array a, consisting of shorts. Consequently, printf() may be called with the original values of a[0] and a[1].\nImplementation Details\nRecent versions of GCC turn on the option -fstrict-aliasing, which allows alias-based optimizations, by default with -O2. Some architectures then print \"1111 1111\" as a result. Without optimization, the executable generates the expected output \"2222 2222.\"\nTo disable optimizations based on alias analysis for faulty legacy code, the option -fno-strict-aliasing can be used as a workaround. The option -Wstrict-aliasing, which is included in -Wall, warns about some, but not all, violations of aliasing rules when -fstrict-aliasing is active.\nWhen GCC 3.4.6 compiles this code with optimization, the assignment through the aliased pointer is effectively eliminated.\nCompliant Solution\nThis compliant solution uses a union type that includes a type compatible with the effective type of the object:\n#include <stdio.h>\n  void func(void) {\n  union {\n    short a[2];\n    int i;\n  } u;\n   u.a[0]=0x1111;\n  u.a[1]=0x1111;\n  u.i = 0x22222222;\n   printf(\"%x %x\\n\", u.a[0], u.a[1]);\n   /* ... */\n}\nThe C standard states:\nIf the member used to read the contents of a union object is not the same as the member last used to store a value in the object, the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called \u201ctype punning\u201d). This might be a trap representation\nThe call to printf() typically outputs \"2222 2222\". However, there is no guarantee that this will be true; the object representations of a and i are unspecified and need not be compatible in this way, despite this operation being commonly accepted as an implementation extension. (See unspecified behavior 11.)\nNoncompliant Code Example\nIn this noncompliant code example, a gadget object is allocated, then realloc() is called to create a widget object using the memory from the gadget object. Although reusing memory to change types is acceptable, accessing the memory copied from the original object is undefined behavior.\n#include <stdlib.h>\n  struct gadget {\n  int i;\n  double d;\n  char *p;\n};\n  struct widget {\n  char *q;\n  int j;\n  double e;\n};\n  void func(void) {\n  struct gadget *gp;\n  struct widget *wp;\n    gp = (struct gadget *)malloc(sizeof(struct gadget));\n  if (!gp) {\n    /* Handle error */\n  }\n  /* ... Initialize gadget ... */\n  wp = (struct widget *)realloc(gp, sizeof(struct widget));\n  if (!wp) {\n    free(gp);\n    /* Handle error */\n  }\n  if (wp->j == 12) {\n    /* ... */\n  }\n  /* ... */\n  free(wp);\n}\nCompliant Solution\nThis compliant solution reuses the memory from the gadget object but reinitializes the memory to a consistent state before reading from it:\n#include <stdlib.h>\n#include <string.h>\n  struct gadget {\n  int i;\n  double d;\n  char *p;\n};\n  struct widget {\n  char *q;\n  int j;\n  double e;\n};\n  void func(void) {\n  struct gadget *gp;\n  struct widget *wp;\n    gp = (struct gadget *)malloc(sizeof (struct gadget));\n  if (!gp) {\n    /* Handle error */\n  }\n  /* ... */\n  wp = (struct widget *)realloc(gp, sizeof(struct widget));\n  if (!wp) {\n    free(gp);\n    /* Handle error */\n  }\n  memset(wp, 0, sizeof(struct widget));\n  /* ... Initialize widget ... */\n   if (wp->j == 12) {\n    /* ... */\n  }\n  /* ... */\n  free(wp);\n}\nNoncompliant Code Example\nAccording to the C Standard, 6.7.7.3 [ISO/IEC 9899:2024], using two or more incompatible arrays in an expression is undefined behavior. (See also undefined behavior 73.)\nFor two array types to be compatible, both should have compatible underlying element types, and both size specifiers should have the same constant value. If either of these properties is violated, the resulting behavior is undefined.\nIn this noncompliant code example, the two arrays a and b fail to satisfy the equal size specifier criterion for array compatibility. Because a and b are not equal, writing to what is believed to be a valid member of a might exceed its defined memory boundary, resulting in an arbitrary memory overwrite.\nenum { ROWS = 10, COLS = 15 };\n  void func(void) {\n  int a[ROWS][COLS];\n  int (*b)[ROWS] = a;\n}\nMost compilers will produce a warning diagnostic if the two array types used in an expression are incompatible.\nCompliant Solution\nIn this compliant solution, b is declared to point to an array with the same number of elements as a, satisfying the size specifier criterion for array compatibility:\nenum { ROWS = 10, COLS = 15 };\n  void func(void) {\n  int a[ROWS][COLS];\n  int (*b)[COLS] = a;\n}\nRisk Assessment\nOptimizing for performance can lead to aliasing errors that can be quite difficult to detect. Furthermore, as in the preceding example, unexpected results can lead to buffer overflow attacks, bypassing security checks, or unexpected execution.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP39-C\nMedium\nUnlikely\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCppcheck Premium\n24.11.0\npremium-cert-exp39-c\nHelix QAC\n2025.2\nC0310, C0751, C3305\nC++3017, C++3030, C++3033\n\nKlocwork\n2025.2\nMISRA.CAST.FUNC_PTR.2012\nMISRA.CAST.INCOMPLETE_PTR_TO_ANY.2012\nMISRA.CAST.OBJ_PTR_TO_NON_INT.2012\nMISRA.CAST.OBJ_PTR_TO_OBJ_PTR.2012\n\nLDRA tool suite\n9.7.1\n94 S, 554 S Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP39-a\nCERT_C-EXP39-b\nCERT_C-EXP39-c\nCERT_C-EXP39-d\nCERT_C-EXP39-e\nCERT_C-EXP39-f\nThere shall be no implicit conversions from integral to floating type\nA cast should not be performed between a pointer to object type and a different pointer to object type\nAvoid accessing arrays and pointers out of bounds\nAvoid buffer overflow from tainted data due to defining incorrect format limits\nAvoid buffer read overflow from tainted data\nAvoid buffer write overflow from tainted data\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP39-C\nChecks for cast to pointer pointing to object of different type (rule partially covered)\nPVS-Studio\n7.38\nV580\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TS 17961 Accessing an object through a pointer to an incompatible type [ptrcomp] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-125, Out-of-bounds Read 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-704 2017-06-14: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-119 and EXP39-C\nIndependent( ARR30-C, ARR38-C, ARR32-C, INT30-C, INT31-C, EXP39-C, EXP33-C, FIO37-C) STR31-C = Subset( Union( ARR30-C, ARR38-C)) STR32-C = Subset( ARR38-C)\nIntersection( EXP39-C, CWE-119) =\n\nReading memory assigned to one type, but being accessed through a pointer to a larger type.\n\nEXP39-C \u2013 CWE-119 =\n\nWriting to memory assigned to one type, but accessed through a pointer to a larger type\n\n\nReading memory assigned to one type, but being accessed through a pointer to a smaller (or equal-sized) type\n\nCWE-119 \u2013 EXP39-C =\n\nReading beyond a buffer using a means other than accessing a variable through an incompatible pointer.\n\nCWE-123 and EXP39-C\nIntersection( CWE-123, EXP39-C) = \u00d8\nEXP39-C allows overflowing a (small) buffer, but not arbitrary memory writes. (Possibly an arbitrary-memory write exploit could be devised using a \u201cperfect storm\u201d of incompatible types, but this would be uncommon in practice.)\nCWE-125 and EXP39-C\nIndependent( ARR30-C, ARR38-C, EXP39-C, INT30-C) STR31-C = Subset( Union( ARR30-C, ARR38-C)) STR32-C = Subset( ARR38-C)\nIntersection( EXP39-C, CWE-125) =\n\nReading memory assigned to one type, but being accessed through a pointer to a larger type.\n\nESP39-C \u2013 CWE-125 =\n\nReading memory assigned to one type, but being accessed through a pointer to a smaller (or equal-sized) type\n\nCWE-125 \u2013 EXP39-C =\n\nReading beyond a buffer using a means other than accessing a variable through an incompatible pointer.\n\nCWE-188 and EXP39-C\nIntersection( CWE-188, EXP39-C) = \u00d8\nCWE-188 appears to be about making assumptions about the layout of memory between distinct variables (that are not part of a larger struct or array). Such assumptions typically involve pointer arithmetic (which violates ARR30-C). EXP39-C involves only one object in memory being (incorrectly) interpreted as if it were another object. EG a float being treated as an int (usually via pointers and typecasting)\nCWE-704 and EXP39-C\nCWE-704 = Union( EXP39-C, list) where list =\n\nIncorrect (?) typecast that is not incompatible\n\nBibliography\n[Acton 2006] \"Understanding Strict Aliasing\"\nGCC Known Bugs \"C Bugs, Aliasing Issues while Casting to Incompatible Types\"\n[ISO/IEC 9899:2024] 6.5, \"Expressions\"\n6.7.7.3, \"Array Declarators\"\n[Walfridsson 2003] Aliasing, Pointer Casts and GCC 3.3",
        "language": "C"
    },
    {
        "rule_id": "EXP40-C",
        "rule_title": "Do not modify constant objects",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP40-C.+Do+not+modify+constant+objects",
        "content": "The C Standard, 6.7.4, paragraph 7 [ISO/IEC 9899:2024], states\nIf an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined.\nSee also undefined behavior 61.\nThere are existing compiler implementations that allow const-qualified objects to be modified without generating a warning message.\nAvoid casting away const qualification because doing so makes it possible to modify const-qualified objects without issuing diagnostics. (See EXP05-C. Do not cast away a const qualification and STR30-C. Do not attempt to modify string literals for more details.)\nNoncompliant Code Example\nThis noncompliant code example allows a constant object to be modified:\nconst int **ipp;\nint *ip;\nconst int i = 42;\n void func(void) {\n  ipp = &ip; /* Constraint violation */\n  *ipp = &i; /* Valid */\n  *ip = 0;   /* Modifies constant i (was 42) */\n}\nThe first assignment is unsafe because it allows the code that follows it to attempt to change the value of the const object i.\nImplementation Details\nIf ipp, ip, and i are declared as automatic variables, this example compiles without warning with Microsoft Visual Studio 2013 when compiled in C mode (/TC) and the resulting program changes the value of i. GCC 4.8.1 generates a warning but compiles, and the resulting program changes the value of i.\nIf ipp, ip, and i are declared with static storage duration, this program compiles without warning and terminates abnormally with Microsoft Visual Studio 2013, and compiles with warning and terminates abnormally with GCC 4.8.1.\nCompliant Solution\nThe compliant solution depends on the intent of the programmer. If the intent is that the value of i is modifiable, then it should not be declared as a constant, as in this compliant solution:\nint **ipp;\nint *ip;\nint i = 42;\n void func(void) {\n  ipp = &ip; /* Valid */\n  *ipp = &i; /* Valid */\n  *ip = 0; /* Valid */\n}\nIf the intent is that the value of i is not meant to change, then do not write noncompliant code that attempts to modify it.  \nRisk Assessment\nModifying constant objects through nonconstant references is undefined behavior 61.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP40-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nassignment-to-non-modifiable-lvalue\npointer-qualifier-cast-const\npointer-qualifier-cast-const-implicit\nwrite-to-constant-memory\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP40\nCoverity\n2017.07\nPW\nMISRA C 2004 Rule 11.5\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-exp40-c\nHelix QAC\n2025.2\nC0563\nLDRA tool suite\n9.7.1\n582 S Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP40-a\nA cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP40-C Checks for write operations on const qualified objects (rule fully covered)\nRuleChecker\n24.04\nassignment-to-non-modifiable-lvalue\npointer-qualifier-cast-const\npointer-qualifier-cast-const-implicit\nPartially checked\nSecurity Reviewer - Static Reviewer\n6.02\nC73\nFully implemented\nTrustInSoft Analyzer\n1.38\nmem_access\nExhaustively verified (see the compliant and the non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard EXP05-C. Do not cast away a const qualification Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard STR30-C. Do not attempt to modify string literals Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] Subclause 6.7.4, \"Type Qualifiers\"",
        "language": "C"
    },
    {
        "rule_id": "EXP42-C",
        "rule_title": "Do not compare padding data",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP42-C.+Do+not+compare+padding+data",
        "content": "The C Standard, 6.7.3.2 paragraph 19 [ISO/IEC 9899:2024], states\nThere may be unnamed padding within a structure object, but not at its beginning. . . . There may be unnamed padding at the end of a structure or union.\nSubclause 6.7.11, paragraph 10, states that\nunnamed members of objects of structure and union type do not participate in initialization. Unnamed members of structure objects have indeterminate representation even after initialization.\nThe only exception is that padding bits are set to zero when a static or thread-local object is implicitly initialized (paragraph 11): \nIf an object that has static or thread storage duration is not initialized explicitly, or any object is initialized with an empty initializer, then it is subject to default initialization, which initializes an object as follows:\n\u2014  if it is an aggregate, every member is initialized (recursively) according to these rules, and any padding is initialized to zero bits;\n\u2014  if it is a union, the first named member is initialized (recursively) according to these rules, and any padding is initialized to zero bits. \n\nBecause these padding values are unspecified, attempting a byte-by-byte comparison between structures can lead to incorrect results [Summit 1995]. \nNoncompliant Code Example\nIn this noncompliant code example, memcmp() is used to compare the contents of two structures, including any padding bytes:\n#include <string.h>\n  struct s {\n  char c;\n  int i;\n  char buffer[13];\n};\n  void compare(const struct s *left, const struct s *right) { \n  if ((left && right) &&\n      (0 == memcmp(left, right, sizeof(struct s)))) {\n    /* ... */\n  }\n}\nCompliant Solution\nIn this compliant solution, all of the fields are compared manually to avoid comparing any padding bytes:\n#include <string.h>\n  struct s {\n  char c;\n  int i;\n  char buffer[13];\n};\n  void compare(const struct s *left, const struct s *right) { \n  if ((left && right) &&\n      (left->c == right->c) &&\n      (left->i == right->i) &&\n      (0 == memcmp(left->buffer, right->buffer, 13))) {\n    /* ... */\n  }\n}\nExceptions\nEXP42-C-EX1: A structure can be defined such that the members are aligned properly or the structure is packed using implementation-specific packing instructions. This is true only when the members' data types have no padding bits of their own and when their object representations are the same as their value representations. This frequently is not true for the _Bool type or floating-point types and need not be true for pointers. In such cases, the compiler does not insert padding, and use of functions such as memcmp() is acceptable.\nThis compliant example uses the #pragma pack compiler extension from Microsoft Visual Studio to ensure the structure members are packed as tightly as possible:\n#include <string.h>\n  #pragma pack(push, 1)\nstruct s {\n  char c;\n  int i;\n  char buffer[13];\n};\n#pragma pack(pop)\n  void compare(const struct s *left, const struct s *right) { \n  if ((left && right) &&\n      (0 == memcmp(left, right, sizeof(struct s)))) {\n    /* ... */\n  }\n}\nRisk Assessment\nComparing padding bytes, when present, can lead to unexpected program behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP42-C\nMedium\nProbable\nYes\nYes\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nmemcpy-with-padding Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP42\nCodeSonar\n9.1p0\nBADFUNC.MEMCMP\nUse of memcmp\nCppcheck Premium\n24.11.0\npremium-cert-exp42-c\nHelix QAC\n2025.2\nDF4726, DF4727, DF4728, DF4729\n\nKlocwork\n2025.2\nMISRA.STDLIB.MEMCMP.PTR_ARG_TYPES\nLDRA tool suite\n9.7.1\n618 S Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP42-a\nDon't memcpy or memcmp non-PODs\nPC-lint Plus\n1.4\n958, 959\nAssistance provided: reports structures which require padding between members or after the last member\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP42-C\n\nChecks for memory comparison of padding data (rule fully covered)\nPVS-Studio\n7.38\nV1103\nRuleChecker\n24.04\nmemcpy-with-padding Partially checked\nTrustInSoft Analyzer\n1.38\ncomparable_char_blocks\nExhaustively verified (see the compliant and the non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TS 17961 Comparison of padding data [padcomp] Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C EXP62-CPP. Do not access the bits of an object representation that are not part of the object's value representation Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 6.7.3.2, \"Structure and Union Specifiers\"\n6.7.11, \"Initialization\"\n[Summit 1995] Question 2.8\nQuestion 2.12",
        "language": "C"
    },
    {
        "rule_id": "EXP43-C",
        "rule_title": "Avoid undefined behavior when using restrict-qualified pointers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP43-C.+Avoid+undefined+behavior+when+using+restrict-qualified+pointers",
        "content": "An object that is accessed through a restrict-qualified pointer has a special association with that pointer. This association requires that all accesses to that object use, directly or indirectly, the value of that particular pointer. The intended use of the restrict qualifier is to promote optimization, and deleting all instances of the qualifier from a program does not change its meaning (that is, observable behavior). In the absence of this qualifier, other pointers can alias this object. Caching the value in an object designated through a restrict-qualified pointer is safe at the beginning of the block in which the pointer is declared because no preexisting aliases may also be used to reference that object. The cached value must be restored to the object by the end of the block, where preexisting aliases again become available. New aliases may be formed within the block, but these must all depend on the value of the restrict-qualified pointer so that they can be identified and adjusted to refer to the cached value. For a restrict-qualified pointer at file scope, the block is the body of each function in the file [Walls 2006]. Developers should be aware that C++ does not support the restrict qualifier, but some C++ compiler implementations support an equivalent qualifier as an extension. \nThe C Standard [ISO/IEC 9899:2024] identifies the following undefined behavior 66:\nA restrict-qualified pointer is assigned a value based on another restricted pointer whose associated block neither began execution before the block associated with this pointer, nor ended before the assignment (6.7.4.2).\nThis is an oversimplification, however, and it is important to review the formal definition of restrict in subclause 6.7.3.1 of the C Standard to properly understand undefined behaviors associated with the use of restrict-qualified pointers.\nOverlapping Objects\nThe restrict qualifier requires that the pointers do not reference overlapping objects. If the objects referenced by arguments to functions overlap (meaning the objects share some common memory addresses), the behavior is undefined.\nNoncompliant Code Example\nThis code example is noncompliant because an assignment is made between two restrict-qualified pointers in the same scope: \nint *restrict a;\nint *restrict b;\n extern int c[];\n  int main(void) {\n  c[0] = 17;\n  c[1] = 18;\n  a = &c[0];\n  b = &c[1];\n  a = b; /* Undefined behavior */\n  /* ... */\n}\nNote that undefined behavior occurs only when a is assigned to b. It is valid for a and b to point into the same array object, provided the range of elements accessed through one of the pointers does not overlap with the range of elements accessed through the other pointer.\nCompliant Solution\nOne way to eliminate the undefined behavior is simply to remove the restrict-qualification from the affected pointers:\nint *a;\nint *b;\n extern int c[];\n  int main(void) {\n  c[0] = 17;\n  c[1] = 18;\n  a = &c[0];\n  b = &c[1];\n  a = b; /* Defined behavior */\n  /* ... */\n}\nrestrict-Qualified Function Parameters\nWhen calling functions that have restrict-qualified function parameters, it is important that the pointer arguments do not reference overlapping objects if one or more of the pointers are used to modify memory. Consequently, it is important to understand the semantics of the function being called.\nNoncompliant Code Example\nIn this noncompliant code example, the function f() accepts three parameters. The function copies n integers from the int array referenced by the restrict-qualified pointer p to the int array referenced by the restrict-qualified pointer q. Because the destination array is modified during each execution of the function (for which n is nonzero), if the array is accessed through one of the pointer parameters, it cannot also be accessed through the other. Declaring these function parameters as restrict-qualified pointers allows aggressive optimization by the compiler but can also result in undefined behavior if these pointers refer to overlapping objects.\n#include <stddef.h>\nvoid f(size_t n, int *restrict p, const int *restrict q) {\n  while (n-- > 0) {\n    *p++ = *q++;\n  }\n}\n  void g(void) {\n  extern int d[100];\n  /* ... */\n  f(50, d + 1, d); /* Undefined behavior */\n}\nThe function g() declares an array d consisting of 100 int values and then invokes f() to copy memory from one area of the array to another. This call has undefined behavior because each of d[1] through d[49] is accessed through both p and q.\nCompliant Solution\nIn this compliant solution, the function f() is unchanged but the programmer has ensured that none of the calls to f() result in undefined behavior. The call to f() in g() is valid because the storage allocated to d is effectively divided into two disjoint objects.\n#include <stddef.h>\nvoid f(size_t n, int *restrict p, const int *restrict q) {\n  while (n-- > 0) {\n    *p++ = *q++;\n  }\n}\n  void g(void) {\n  extern int d[100];\n  /* ... */\n  f(50, d + 50, d); /* Defined behavior  */\n}\nNoncompliant Code Example\nIn this noncompliant code example, the function add() adds the integer array referenced by the restrict-qualified pointers lhs to the integer array referenced by the restrict-qualified pointer rhs and stores the result in the restrict-qualified pointer referenced by res. The function f() declares an array a consisting of 100 int values and then invokes add() to copy memory from one area of the array to another. The call add(100, a, a, a) has undefined behavior because the object modified by res is accessed by lhs and rhs.\n#include <stddef.h>\n  void add(size_t n, int *restrict res, const int *restrict lhs,\n       const int *restrict rhs) {\n  for (size_t i = 0; i < n; ++i) {\n    res[i] = lhs[i] + rhs[i];\n  }\n}\n  void f(void) {\n  int a[100];\n  add(100, a, a, a); /* Undefined behavior */\n}\nCompliant Solution\nIn this compliant solution, an unmodified object is aliased through two restricted pointers. Because a and b are disjoint arrays, a call of the form add(100, a, b, b) has defined behavior, because array b is not modified within function add.\n#include <stddef.h>\nvoid add(size_t n, int *restrict res, const int *restrict lhs,\n         const int *restrict rhs) {\n  for (size_t i = 0; i < n; ++i) {\n    res[i] = lhs[i] + rhs[i];\n  }\n}\n  void f(void) {\n   int a[100];\n   int b[100];\n   add(100, a, b, b); /* Defined behavior  */\n}\nInvoking Library Functions with restrict-Qualified Pointers\nEnsure that restrict-qualified source and destination pointers do not reference overlapping objects when invoking library functions. For example, the following table lists C standard library functions that copy memory from a source object referenced by a restrict-qualified pointer to a destination object that is also referenced by a restrict-qualified pointer: \nStandard C\nstrcpy()\nstrncpy()\nstrcat()\nstrncat()\nmemcpy()\nIf the objects referenced by arguments to functions overlap (meaning the objects share some common memory addresses), the behavior is undefined. (See also undefined behavior 65.) The result of the functions is unknown, and data may be corrupted. As a result, these functions must never be passed pointers to overlapping objects. If data must be copied between objects that share common memory addresses, a copy function guaranteed to work on overlapping memory, such as memmove(), should be used.\nNoncompliant Code Example\nIn this noncompliant code example, the values of objects referenced by ptr1 and ptr2 become unpredictable after the call to memcpy() because their memory areas overlap:\n#include <string.h>\n  void func(void) {\n  char c_str[]= \"test string\";\n  char *ptr1 = c_str;\n  char *ptr2;\n   ptr2 = ptr1 + 3;\n  /* Undefined behavior because of overlapping objects */\n  memcpy(ptr2, ptr1, 6); \n  /* ... */\n}\nCompliant Solution\nIn this compliant solution, the call to memcpy() is replaced with a call to memmove(). The memmove() function performs the same operation as memcpy() when the memory regions do not overlap. When the memory regions do overlap, the n characters from the object pointed to by the source (ptr1) are first copied into a temporary array of n characters that does not overlap the objects pointed to by the destination (ptr2) or the source. The n characters from the temporary array are then copied into the object pointed to by the destination.\n#include <string.h>\n void func(void) {\n  char c_str[]= \"test string\";\n  char *ptr1 = c_str;\n  char *ptr2;\n   ptr2 = ptr1 + 3;\n  memmove(ptr2, ptr1, 6);  /* Replace call to memcpy() */\n  /* ... */\n}\nSimilar solutions using memmove() can replace the string functions as long as care is taken regarding the byte size of the characters and proper null-termination of the copied string.\nCalling Functions with restrict-Qualified Pointer to a const-Qualified Type \nEnsure that functions that accept a restrict-qualified pointer to a const-qualified type do not modify the object referenced by that pointer. Formatted input and output standard library functions frequently fit this description. The following table lists of some of the common functions for which the format argument is a restrict-qualified pointer to a const-qualified type.\nStandard C\nprintf()\nscanf()\nsprintf()\nsnprintf()\nFor formatted output functions such as printf(), it is unlikely that a programmer would modify the format string. However, an attacker may attempt to do so if a program violates FIO30-C. Exclude user input from format strings and passes tainted values as part of the format string. \nNoncompliant Code Example\nIn this noncompliant code example, the programmer is attempting to overwrite the format string with a string value read in from stdin such as \"%d%f 1 3.3\" and use the resulting modified string of \"%s%d%f\" to input the subsequent values of 1 and 3.3:\n#include <stdio.h>\n  void func(void) {\n  int i;\n  float x;\n  char format[100] = \"%s\";\n  /* Undefined behavior */\n  int n = scanf(format, format + 2, &i, &x); \n  /* ... */\n}\nCompliant Solution\nThe intended results are achieved by this compliant solution:\n#include <stdio.h>\n  void func(void) {\n  int i;\n  float x;\n  int n = scanf(\"%d%f\", &i, &x); /* Defined behavior  */ \n  /* ... */\n}\nOuter-to-Inner Assignments between Restricted Pointers\nThe assignment between restrict-qualified pointers declared in an inner nested block from an outer block has defined behavior.\nNoncompliant Code Example\nThe assignment of restrict-qualified pointers to other restrict-qualified pointers within the same block has undefined behavior:\nvoid func(void) {\n  int *restrict p1;\n  int *restrict q1;\n   int *restrict p2 = p1; /* Undefined behavior */\n  int *restrict q2 = q1; /* Undefined behavior */\n }\nCompliant Solution \nThe intended results can be achieved using an inner nested block, as shown in this compliant solution:\nvoid func(void) {\n  int *restrict p1;  \n  int *restrict q1;\n  {  /* Added inner block */\n    int *restrict p2 = p1; /* Valid, well-defined behavior */   \n    int *restrict q2 = q1; /* Valid, well-defined behavior */\n  }\n}\nRisk Assessment\nThe incorrect use of restrict-qualified pointers can result in undefined behavior 66\n that might be exploited to cause data integrity violations.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP43-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nrestrict Supported indirectly via MISRA C 2012 Rule 8.14.\nCodeSonar\n9.1p0\nLANG.TYPE.RESTRICT Restrict qualifier used\nCoverity\n2017.07\nMISRA C 2012 Rule 8.14\nPartially implemented\nCppcheck Premium\n24.11.0\npremium-cert-exp43-c\nGCC 8.1 -Wrestrict Fully implemented\nHelix QAC\n2025.2\nC1057\nKlocwork\n2025.2\nMISRA.TYPE.RESTRICT.QUAL.2012\nLDRA tool suite\n9.7.1\n480 S, 489 S, 613 S\nEnhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-EXP43-a\nThe restrict type qualifier shall not be used\nPC-lint Plus\n1.4\n586\nAssistance provided: reports use of the restrict keyword\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP43-C\nChecks for copy of overlapping memory (rule partially covered)\nRuleChecker\n24.04\nrestrict Supported indirectly via MISRA C 2012 Rule 8.14.\nSonarQube C/C++ Plugin\n3.11\nS1836 Implements MISRA C:2012 Rule 8.14 to flag uses of restrict\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard FIO30-C. Exclude user input from format strings Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Passing Parameters and Return Values [CSJ] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Passing pointers into the same object as arguments to different restrict-qualified parameters [restrict] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 8.14 (required)1 Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA Rule 8.14 prohibits the use of the restrict keyword except in C standard library functions. \nBibliography\n[ISO/IEC 9899:2024] 6.7.4.2, \"Formal Definition of restrict\" \n[Walls 2006]",
        "language": "C"
    },
    {
        "rule_id": "EXP44-C",
        "rule_title": "Do not rely on side effects in operands to sizeof, _Alignof, or _Generic",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP44-C.+Do+not+rely+on+side+effects+in+operands+to+sizeof%2C+_Alignof%2C+or+_Generic",
        "content": "Some operators do not evaluate their operands beyond the type information the operands provide. When using one of these operators, do not pass an operand that would otherwise yield a side effect since the side effect will not be generated.\nThe sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type.  In most cases, the operand is not evaluated.  A possible exception is when the type of the operand is a variable length array type (VLA); then the expression is evaluated. When part of the operand of the sizeof operator is a VLA type and when changing the value of the VLA's size expression would not affect the result of the operator, it is unspecified whether or not the size expression is evaluated. (See unspecified behavior 22.)\nThe operand passed to_Alignof is never evaluated, despite not being an expression. For instance, if the operand is a VLA type and the VLA's size expression contains a side effect, that side effect is never evaluated.\nThe operand used in the controlling expression of a _Generic selection expression is never evaluated.\nProviding an expression that appears to produce side effects may be misleading to programmers who are not aware that these expressions are not evaluated, and in the case of a VLA used in sizeof, have unspecified results. As a result, programmers may make invalid assumptions about program state, leading to errors and possible software vulnerabilities.\nThis rule is similar to PRE31-C. Avoid side effects in arguments to unsafe macros.\nNoncompliant Code Example (sizeof)\nIn this noncompliant code example, the expression a++ is not evaluated:\n#include <stdio.h>\n  void func(void) {\n  int a = 14;\n  int b = sizeof(a++);\n  printf(\"%d, %d\\n\", a, b);\n}\nConsequently, the value of a after b has been initialized is 14.\nCompliant Solution (sizeof)\nIn this compliant solution, the variable a is incremented outside of the sizeof operation:\n#include <stdio.h>\n  void func(void) {\n  int a = 14;\n  int b = sizeof(a);\n  ++a;\n  printf(\"%d, %d\\n\", a, b);\n}\nNoncompliant Code Example (sizeof, VLA)\nIn this noncompliant code example, the expression ++n in the initialization expression of a must be evaluated because its value affects the size of the VLA operand of the sizeof operator. However, in the initialization expression of b, the expression ++n % 1 evaluates to 0. This means that the value of n does not affect the result of the sizeof operator. Consequently, it is unspecified whether or not n will be incremented when initializing b.\n#include <stddef.h>\n#include <stdio.h>\n   void f(size_t n) {\n  /* n must be incremented */\n  size_t a = sizeof(int[++n]);\n    /* n need not be incremented */\n  size_t b = sizeof(int[++n % 1 + 1]);\n   printf(\"%zu, %zu, %zu\\n\", a, b, n);\n  /* ... */\n}\nCompliant Solution (sizeof, VLA)\nThis compliant solution avoids changing the value of the variable n used in each sizeof expression and instead increments n safely afterwards:\n#include <stddef.h>\n#include <stdio.h>\n   void f(size_t n) {\n  size_t a = sizeof(int[n + 1]);\n  ++n;\n   size_t b = sizeof(int[n % 1 + 1]);\n  ++n;\n  printf(\"%zu, %zu, %zu\\n\", a, b, n);\n  /* ... */\n}\nNoncompliant Code Example (_Generic)\nThis noncompliant code example attempts to modify a variable's value as part of the _Generic selection control expression. The programmer may expect that a is incremented, but because _Generic does not evaluate its control expression, the value of a is not modified.\n#include <stdio.h>\n #define S(val) _Generic(val, int : 2, \\\n                             short : 3, \\\n                             default : 1)\nvoid func(void) {\n  int a = 0;\n  int b = S(a++);\n  printf(\"%d, %d\\n\", a, b);\n}\nCompliant Solution (_Generic)\nIn this compliant solution, a is incremented outside of the _Generic selection expression:\n#include <stdio.h>\n #define S(val) _Generic(val, int : 2, \\\n                             short : 3, \\\n                             default : 1)\nvoid func(void) {\n  int a = 0;\n  int b = S(a);\n  ++a;\n  printf(\"%d, %d\\n\", a, b);\n} \nNoncompliant Code Example (_Alignof)\nThis noncompliant code example attempts to modify a variable while getting its default alignment value. The user may have expected val to be incremented as part of the _Alignof expression, but because _Alignof does not evaluate its operand, val is unchanged.\n#include <stdio.h>\n  void func(void) {\n  int val = 0;\n  /* ... */ \n  size_t align = _Alignof(int[++val]);\n  printf(\"%zu, %d\\n\", align, val);\n  /* ... */\n}\nCompliant Solution (_Alignof)\n This compliant solution moves the expression out of the _Alignof operator:\n#include <stdio.h>\nvoid func(void) {\n  int val = 0; \n  /* ... */ \n  ++val;\n  size_t align = _Alignof(int[val]);\n  printf(\"%zu, %d\\n\", align, val);\n  /* ... */\n}\nExceptions\nEXP44-C-EX1: Reading a volatile-qualified value is a side-effecting operation. However, accessing a value through a volatile-qualified type does not guarantee side effects will happen on the read of the value unless the underlying object is also volatile-qualified. Idiomatic reads of a volatile-qualified object are permissible as an operand to a sizeof(), _Alignof(), or _Generic expression, as in the following example:\nvoid f(void) {\n  int * volatile v;\n  (void)sizeof(*v);\n}\nRisk Assessment\nIf expressions that appear to produce side effects are supplied to an operator that does not evaluate its operands, the results may be different than expected. Depending on how this result is used, it can lead to unintended program behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP44-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nalignof-side-effect\ngeneric-selection-side-effect\nsizeof\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP44\nClang\n3.9\n-Wunevaluated-expression Can diagnose some instance of this rule, but not all (such as the _Alignof NCCE).\nCodeSonar\n9.1p0\nLANG.STRUCT.SE.SIZEOF\nLANG.STRUCT.SE.CGEN\nSide effects in sizeof\nSide Effects in C Generic Selection\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nMISRA C 2004 Rule 12.3\nPartially implemented\nECLAIR\n1.2\nCC2.EXP06\nFully implemented\nHelix QAC\n2025.2\nC3307\nKlocwork\n2025.2\nMISRA.SIZEOF.SIDE_EFFECT\nLDRA tool suite\n9.7.1\n54 S, 653 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP44-a\nCERT_C-EXP44-b\nObject designated by a volatile lvalue should not be accessed in the operand of the sizeof operator\nThe function call that causes the side effect shall not be the operand of the sizeof operator\nPC-lint Plus\n1.4\n9006\nPartially supported: reports use of sizeof with an expression that would have side effects\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP44-C\n\nChecks for situations when side effects of specified expressions are ignored (rule fully covered)\nPVS-Studio\n7.38\nV568\nRuleChecker\n24.04\nalignof-side-effect\ngeneric-selection-side-effect\nsizeof\nFully checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C EXP52-CPP. Do not rely on side effects in unevaluated operands Prior to 2018-01-12: CERT: Unspecified Relationship",
        "language": "C"
    },
    {
        "rule_id": "EXP45-C",
        "rule_title": "Do not perform assignments in selection statements",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP45-C.+Do+not+perform+assignments+in+selection+statements",
        "content": "Do not use the assignment operator in the contexts listed in the following table because doing so typically indicates programmer error and can result in unexpected behavior.\nOperator\nContext \nif Controlling expression\nwhile Controlling expression\ndo ... while Controlling expression\nfor Second operand\n?: First operand\n?: Second or third operands, where the ternary expression is used in any of these contexts\n&&  Either operand \n||  either operand \n,\nSecond operand, when the comma expression is used in any of these contexts\n\n Performing assignment statements in other contexts do not violate this rule. However, they may violate other rules, such as EXP30-C. Do not depend on the order of evaluation for side effects.\n\nNoncompliant Code Example\nIn this noncompliant code example, an assignment expression is the outermost expression in an if statement:\nif (a = b) {\n  /* ... */\n}\nAlthough the intent of the code may be to assign b to a and test the value of the result for equality to 0, it is frequently a case of the programmer mistakenly using the assignment operator = instead of the equals operator ==. Consequently, many compilers will warn about this condition, making this coding error detectable by adhering to MSC00-C. Compile cleanly at high warning levels.\nCompliant Solution (Unintentional Assignment)\nWhen the assignment of b to a is not intended, the conditional block is now executed when a is equal to b:\nif (a == b) {\n  /* ... */\n}\nCompliant Solution (Intentional Assignment)\nWhen the assignment is intended, this compliant solution explicitly uses inequality as the outermost expression while performing the assignment in the inner expression:\nif ((a = b) != 0) {\n  /* ... */\n}\nIt is less desirable in general, depending on what was intended, because it mixes the assignment in the condition, but it is clear that the programmer intended the assignment to occur.\nNoncompliant Code Example\nIn this noncompliant code example, the expression x = y is used as the controlling expression of the while statement:\n do { /* ... */ } while (foo(), x = y);\nCompliant Solution (Unintentional Assignment)\nWhen the assignment of y to x is not intended, the conditional block should be executed only when x is equal to y, as in this compliant solution:\ndo { /* ... */ } while (foo(), x == y);\nCompliant Solution (Intentional Assignment)\nWhen the assignment is intended, this compliant solution can be used:\ndo { /* ... */ } while (foo(), (x = y) != 0);\nCompliant Solution (for statement)\nThe same result can be obtained using the for statement, which is specifically designed to evaluate an expression on each iteration of the loop, just before performing the test in its controlling expression. Remember that its controlling expression is the second operand, where the assignment occurs in its third operand:\nfor (; x; foo(), x = y) { /* ... */ }\nNoncompliant Code Example\nIn this noncompliant example, the expression p = q is used as the controlling expression of the while statement:\n do { /* ... */ } while (x = y, p = q);\nCompliant Solution\nIn this compliant solution, the expression x = y is not used as the controlling expression of the while statement:\ndo { /* ... */ } while (x = y, p == q);\nNoncompliant Code Example\nThis noncompliant code example has a typo that results in an assignment rather than a comparison.\nwhile (ch = '\\t' || ch == ' ' || ch == '\\n') {\n  /* ... */\n}\nMany compilers will warn about this condition. This coding error would typically be eliminated by adherence to MSC00-C. Compile cleanly at high warning levels. Although this code compiles, it will cause unexpected behavior to an unsuspecting programmer. If the intent was to verify a string such as a password, user name, or group user ID, the code may produce significant vulnerabilities and require significant debugging.\nCompliant Solution (RHS Variable)\nWhen comparisons are made between a variable and a literal or const-qualified variable, placing the variable on the right of the comparison operation can prevent a spurious assignment.\nIn this code example, the literals are placed on the left-hand side of each comparison. If the programmer were to inadvertently use an assignment operator, the statement would assign ch to '\\t', which is invalid and produces a diagnostic message.\nwhile ('\\t' = ch || ' ' == ch || '\\n' == ch) {\n  /* ... */\n}\nDue to the diagnostic, the typo will be easily spotted and fixed.\nwhile ('\\t' == ch || ' ' == ch || '\\n' == ch) {\n  /* ... */\n}\nAs a result, any mistaken use of the assignment operator that could otherwise create a vulnerability for operations such as string verification will result in a compiler diagnostic regardless of compiler, warning level, or implementation.\nExceptions\nEXP45-C-EX1: Assignment can be used where the result of the assignment is itself an operand to a comparison expression or relational expression. In this compliant example, the expression x = y  is itself an operand to a comparison operation:\nif ((x = y) != 0) { /* ... */ }\nEXP45-C-EX2: Assignment can be used where the expression consists of a single primary expression. The following code is compliant because the expression  x = y is a single primary expression:\nif ((x = y)) { /* ... */ }\nThe following controlling expression is noncompliant because && is not a comparison or relational operator and the entire expression is not primary:\nif ((v = w) && flag) { /* ... */ }\nWhen the assignment of v to w is not intended, the following controlling expression can be used to execute the conditional block when v is equal to w:\nif ((v == w) && flag) { /* ... */ };\nWhen the assignment is intended, the following controlling expression can be used:\nif (((v = w) != 0) && flag) { /* ... */ };\nEXP45-C-EX3: Assignment can be used in a function argument or array index. In this compliant solution, the expression x = y is used in a function argument:\n\nif (foo(x = y)) { /* ... */ }\n\nRisk Assessment\nErrors of omission can result in unintended program flow.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nEXP45-C\nLow\nLikely\nYes\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nassignment-conditional Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP45\nClang\n3.9\n-Wparentheses Can detect some instances of this rule, but does not detect all\nCodeSonar\n9.1p0\nLANG.STRUCT.CONDASSIG\nLANG.STRUCT.SE.COND\nLANG.STRUCT.USEASSIGN Assignment in conditional\nCondition contains side effects\nAssignment result in expression\nCompass/ROSE\n\n\nCould detect violations of this recommendation by identifying any assignment expression as the top-level expression in an if or while statement\nCppcheck Premium\n24.11.0\npremium-cert-exp45-c\nECLAIR\n1.2\nCC2.EXP18\nCC2.EXP21\nFully implemented\nGCC\n4.3.5\n\nCan detect violations of this recommendation when the -Wall flag is used\nHelix QAC\n2025.2\nC3314, C3326, C3344, C3416\nC++4071, C++4074\n\nKlocwork\n2025.2\nASSIGCOND.CALL\nASSIGCOND.GEN\nMISRA.ASSIGN.COND\n\nLDRA tool suite\n9.7.1\n114 S, 132 S\nEnhanced Enforcement\nParasoft C/C++test\n2024.2\nCERT_C-EXP45-b\nCERT_C-EXP45-d\nAssignment operators shall not be used in conditions without brackets\nAssignment operators shall not be used in expressions that yield a Boolean value\nPC-lint Plus\n1.4\n720\nPartially supported: reports Boolean test of unparenthesized assignment\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP45-C Checks for invalid use of = (assignment) operator (rule fully covered)\nPVS-Studio\n7.38\nV559, V633, V699\nRuleChecker\n24.04\nassignment-conditional Fully checked\nSonarQube C/C++ Plugin\n3.11\nAssignmentInSubExpression\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C EXP19-CPP. Do not perform assignments in conditional expressions Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java EXP51-J. Do not perform assignments in conditional expressions Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Likely Incorrect Expression [KOA] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 No assignment in conditional expressions [boolasgn] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-480, Use of Incorrect Operator 2017-07-05: CERT: Rule subset of CWE\nCWE 2.11 CWE-481 2017-07-05: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-480 and EXP45-C\nIntersection( EXP45-C, EXP46-C) = \u00d8\nCWE-480 = Union( EXP45-C, list) where list =\nUsage of incorrect operator besides s/=/==/\nCWE-569 and EXP45-C\nCWE-480 = Subset( CWE-569)\nBibliography\n[Dutta 03] \"Best Practices for Programming in C\"\n[Hatton 1995] Section 2.7.2, \"Errors of Omission and Addition\"",
        "language": "C"
    },
    {
        "rule_id": "EXP46-C",
        "rule_title": "Do not use a bitwise operator with a Boolean-like operand",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP46-C.+Do+not+use+a+bitwise+operator+with+a+Boolean-like+operand",
        "content": "Mixing bitwise and relational operators in the same full expression can be a sign of a logic error in the expression where a logical operator is usually the intended operator. Do not use the bitwise AND (&), bitwise OR (|), or bitwise XOR (^) operators with an operand of type _Bool, or the result of a relational-expression or equality-expression. If the bitwise operator is intended, it should be indicated with use of a parenthesized expression.\nNoncompliant Code Example\nIn this noncompliant code example, a bitwise & operator is used with the results of two equality-expressions:\nif (getuid() == 0 & getgid() == 0) { \n  /* ... */ \n} \nCompliant Solution\nThis compliant solution uses the && operator for the logical operation within the conditional expression:\nif (getuid() == 0 && getgid() == 0) {\n  /* ... */\n}\nRisk Assessment\nRule\nSeverity\nLikelihood\nRemediation Cost\nPriority\nLevel\nEXP46-C\nLow\nLikely\nLow\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ninappropriate-bool Supported indirectly via MISRA C:2012 Rule 10.1\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP46\nCodeSonar\n9.1p0\nLANG.TYPE.IOT Inappropriate operand type\nCoverity\n2017.07\nCONSTANT_EXPRESSION_RESULT\nPartially implemented\nCppcheck\n 2.15\nbitwiseOnBoolean\nCppcheck Premium\n24.11.0\nbitwiseOnBoolean\nHelix QAC\n2025.2\nC3344, C4502\nC++3709\n\nKlocwork\n2025.2\nMISRA.LOGIC.OPERATOR.NOT_BOOL\nLDRA tool suite\n9.7.1\n136 S Fully Implemented\nParasoft C/C++test\n2024.2\nCERT_C-EXP46-b\nExpressions that are effectively Boolean should not be used as operands to operators other than (&&, ||, !, =, ==, !=, ?:)\nPC-lint Plus\n1.4\n514\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP46-C\nChecks for bitwise operations on boolean operands (rule fully covered)\nPVS-Studio\n7.38\nV564, V1015\n\nRuleChecker\n24.04\ninappropriate-bool Supported indirectly via MISRA C:2012 Rule 10.1\nSecurity Reviewer - Static Reviewer\n6.02\nC73 Fully implemented\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TR 24772:2013 Likely Incorrect Expression [KOA] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-480, Use of incorrect operator 2017-07-05: CERT: Rule subset of CWE\nCWE 2.11 CWE-569 2017-07-06: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-480 and EXP46-C\nIntersection( EXP45-C, EXP46-C) = \u00d8\nCWE-480 = Union( EXP46-C, list) where list =\nUsage of incorrect operator besides s/&/&&/ or s/|/||/\nBibliography\n[Hatton 1995] Section 2.7.2, \"Errors of Omission and Addition\"",
        "language": "C"
    },
    {
        "rule_id": "EXP47-C",
        "rule_title": "Do not call va_arg with an argument of the incorrect type",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/EXP47-C.+Do+not+call+va_arg+with+an+argument+of+the+incorrect+type",
        "content": "The variable arguments passed to a variadic function are accessed by calling the va_arg() macro. This macro accepts the va_list representing the variable arguments of the function invocation and the type denoting the expected argument type for the argument being retrieved. The macro is typically invoked within a loop, being called once for each expected argument. However, there are no type safety guarantees that the type passed to va_arg matches the type passed by the caller, and there are generally no compile-time checks that prevent the macro from being invoked with no argument available to the function call.\nThe C Standard, 7.16.1.1, states [ISO/IEC 9899:2024], in part:\nIf type is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined, except for the following cases:\n\u2014  both types are pointers to qualified or unqualified versions of compatible types;\n\u2014  one type is compatible with a signed integer type, the other type is compatible with the corresponding unsigned integer type, and the value is representable in both types;\n\u2014  one type is pointer to qualified or unqualified void and the other is a pointer to a qualified or unqualified character type;\n\u2014  or, the type of the next argument is nullptr_t and type is a pointer type that has the same representation and alignment requirements as a pointer to a character type.\nEnsure that an invocation of the va_arg() macro does not attempt to access an argument that was not passed to the variadic function. Further, the type passed to the va_arg() macro must match the type passed to the variadic function after default argument promotions have been applied. Either circumstance results in undefined behavior 141.\nNoncompliant Code Example\nThis noncompliant code example attempts to read a variadic argument of type unsigned char with va_arg(). However, when a value of type unsigned char is passed to a variadic function, the value undergoes default argument promotions, resulting in a value of type int being passed.\n#include <stdarg.h>\n#include <stddef.h>\n void func(size_t num_vargs, ...) {\n  va_list ap; \n  va_start(ap, num_vargs);\n  if (num_vargs > 0) {\n    unsigned char c = va_arg(ap, unsigned char);\n    // ...\n  }\n  va_end(ap);\n}\n  void f(void) {\n  unsigned char c = 0x12;\n  func(1, c);\n}\nCompliant Solution\nThe compliant solution accesses the variadic argument with type int, and then casts the resulting value to type unsigned char:\n#include <stdarg.h>\n#include <stddef.h>\n void func(size_t num_vargs, ...) {\n  va_list ap; \n  va_start(ap, num_vargs);\n  if (num_vargs > 0) {\n    unsigned char c = (unsigned char) va_arg(ap, int);\n    // ...\n  }\n  va_end(ap);\n}\n void f(void) {\n  unsigned char c = 0x12;\n  func(1, c);\n}\nNoncompliant Code Example\nThis noncompliant code example assumes that at least one variadic argument is passed to the function, and attempts to read it using the va_arg() macro. This pattern arises frequently when a variadic function uses a sentinel value to denote the end of the variable argument list. However, the caller passes no variadic arguments to the function, which results in undefined behavior.\n#include <stdarg.h>\n  void func(const char *cp, ...) {\n  va_list ap; \n  va_start(ap, cp);\n  int val = va_arg(ap, int);\n  // ...\n  va_end(ap);\n}\n  void f(void) {\n  func(\"The only argument\");\n}\nCompliant Solution\nStandard C provides no mechanism to enable a variadic function to determine how many variadic arguments are actually provided to the function call. That information must be passed in an out-of-band manner. Oftentimes this results in the information being encoded in the initial parameter, as in this compliant solution:\n#include <stdarg.h>\n#include <stddef.h>\n void func(size_t num_vargs, const char *cp, ...) {\n  va_list ap; \n  va_start(ap, cp);\n  if (num_vargs > 0) {\n    int val = va_arg(ap, int);\n    // ...\n  }\n  va_end(ap);\n}\n  void f(void) {\n  func(0, \"The only argument\");\n}\nRisk Assessment\nIncorrect use of va_arg() results in undefined behavior that can include accessing stack memory.\nRule\nSeverity\nLikelihood\nRemediation Cost\nPriority\nLevel\nEXP47-C\nMedium\nLikely\nHigh\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\n\n\n\nAxivion Bauhaus Suite\n7.2.0\nCertC-EXP47\n\n\n\nClang\n3.9\n-Wvarargs Can detect some instances of this rule, such as promotable types.\nCannot detect mismatched types or incorrect number of variadic arguments.\n\n\nCodeSonar\n9.1p0\nBADMACRO.STDARG_H Use of <stdarg.h> feature\n\n\nHelix QAC\n2025.2\nDF4901, DF4902, DF4903, DF4904\n\n\n\n\nKlocwork\n2025.2\nCERT.VA_ARG.TYPE\n\n\n\n\nLDRA tool suite\n9.7.1\n44 S\nEnhanced Enforcement\n\n\n\nParasoft C/C++test\n2024.2\nCERT_C-EXP47-a Do not call va_arg with an argument of the incorrect type\n\n\nPC-lint Plus\n1.4\n917\nAssistance provided: reports argument promotion to match prototype\n\n\n\nPolyspace Bug Finder\nR2025b\nCERT C: Rule EXP47-C\n\nChecks for:\nIncorrect data type passed to va_arg\nToo many va_arg calls for current argument list\nRule fully covered\n\n\n\nSecurity Reviewer - Static Reviewer\n6.02\nC75\nFully implemented\n\n\n\nTrustInSoft Analyzer\n1.38\nunclassified (variadic)\nExhaustively verified (see one compliant and one non-compliant example).\n\n\n\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2024] Subclause 7.16, \"Variable Arguments <stdarg.h>\"",
        "language": "C"
    },
    {
        "rule_id": "FLP01-C",
        "rule_title": "Take care in rearranging floating-point expressions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FLP01-C.+Take+care+in+rearranging+floating-point+expressions",
        "content": "Be careful when rearranging floating-point expressions to ensure the greatest accuracy of the result.\nSubclause 5.1.2.3, paragraph 14, of the C Standard [ISO/IEC 9899:2011], states:\nRearrangement for floating-point expressions is often restricted because of limitations in precision as well as range. The implementation cannot generally apply the mathematical associative rules for addition or multiplication, nor the distributive rule, because of roundoff error, even in the absence of overflow and underflow. Likewise, implementations cannot generally replace decimal constants to rearrange expressions. In the following fragment, rearrangements suggested by mathematical rules for real numbers are often not valid.\ndouble x, y, z;\n/* ... */\nx = (x * y) * z; /* not equivalent to x *= y * z; */\nz = (x - y) + y ; /* not equivalent to z = x; */\nz = x + x * y; /* not equivalent to z = x * (1.0 + y); */\ny = x / 5.0; /* not equivalent to y = x * 0.2; */\nRisk Assessment\nFailure to understand the limitations in precision of floating-point-represented numbers and their implications on the arrangement of expressions can cause unexpected arithmetic results.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFLP01-C\nLow\nProbable\nNo\nNo\nP2\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this recommendation on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard FLP01-CPP. Take care in rearranging floating-point expressions\nISO/IEC TR 24772:2013 Floating-point Arithmetic [PLF]\nBibliography\n[ISO/IEC 9899:2011] Subclause 5.1.2.3, \"Program Execution\"",
        "language": "C"
    },
    {
        "rule_id": "PRE01-C",
        "rule_title": "Use parentheses within macros around parameter names",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/PRE01-C.+Use+parentheses+within+macros+around+parameter+names",
        "content": "Parenthesize all parameter names in macro definitions. See also PRE00-C. Prefer inline or static functions to function-like macros and PRE02-C. Macro replacement lists should be parenthesized.\nNoncompliant Code Example\nThis CUBE() macro definition is noncompliant because it fails to parenthesize the parameter names:\n#define CUBE(I) (I * I * I)\nAs a result, the invocation\nint a = 81 / CUBE(2 + 1);\nexpands to\nint a = 81 / (2 + 1 * 2 + 1 * 2 + 1);  /* Evaluates to 11 */\nwhich is clearly not the desired result.\nCompliant Solution\nParenthesizing all parameter names in the CUBE() macro allows it to expand correctly (when invoked in this manner):\n#define CUBE(I) ( (I) * (I) * (I) )\nint a = 81 / CUBE(2 + 1);\nExceptions\nPRE01-C-EX1: When the parameter names are surrounded by commas in the replacement text, regardless of how complicated the actual arguments are, there is no need for parenthesizing the macro parameters. Because commas have lower precedence than any other operator, there is no chance of the actual arguments being parsed in a surprising way. Comma separators, which separate arguments in a function call, also have lower precedence than other operators, although they are technically different from comma operators.\n#define FOO(a, b, c) bar(a, b, c)\n/* ... */\nFOO(arg1, arg2, arg3);\nPRE01-C-EX2: Macro parameters cannot be individually parenthesized when concatenating tokens using the ## operator, converting macro parameters to strings using the # operator, or concatenating adjacent string literals. The following JOIN() macro concatenates both arguments to form a new token. The SHOW() macro converts the single argument into a string literal, which is then passed as a parameter to printf() and as a string and as a parameter to the %d specifier. For example, if SHOW() is invoked as SHOW(66);, the macro would be expanded to printf(\"66\" \" = %d\\n\", 66);.\n#define JOIN(a, b) (a ## b)\n#define SHOW(a) printf(#a \" = %d\\n\", a)\nSee PRE05-C. Understand macro replacement when concatenating tokens or performing stringification for more information on using the ## operator to concatenate tokens.\nRisk Assessment\nFailing to parenthesize the parameter names in a macro can result in unintended program behavior.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPRE01-C\nMedium\nProbable\nYes\nYes\nP12\nL1\nAutomated Detection\nTool Version Checker Description\nAstr\u00e9e\n24.04\nmacro-parameter-parentheses Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-PRE01 Fully implemented\nCppcheck Premium\n24.11.0\npremium-cert-pre01-c  \nECLAIR\n1.2\nCC2.PRE01 Fully implemented\nHelix QAC\n2025.2\nC3410\nKlocwork\n2025.2\nMISRA.DEFINE.NOPARS\nLDRA tool suite\n9.7.1\n78 S\nEnhanced Enforcement\nParasoft C/C++test\n2024.2\nCERT_C-PRE01-a\nIn the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##\nPC-lint Plus\n1.4\n9022\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. PRE01-C Checks for expanded macro parameters not enclosed in parentheses (rule partially supported)\n\nPVS-Studio\n7.38\nV733\nRuleChecker\n24.04\nmacro-parameter-parentheses Fully checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID PRE01-CPP. Use parentheses within macros around parameter names\nISO/IEC TR 24772:2013 Operator Precedence/Order of Evaluation [JCW]\nPre-processor Directives [NMP]\nMISRA C:2012\nRule 20.7 (required)\nBibliography\n[Plum 1985]\n[Summit 2005] Question 10.1",
        "language": "C"
    },
    {
        "rule_id": "PRE02-C",
        "rule_title": "Macro replacement lists should be parenthesized",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/PRE02-C.+Macro+replacement+lists+should+be+parenthesized",
        "content": "Macro replacement lists should be parenthesized to protect any lower-precedence operators from the surrounding expression. See also PRE00-C. Prefer inline or static functions to function-like macros and PRE01-C. Use parentheses within macros around parameter names.\nNoncompliant Code Example\nThis CUBE() macro definition is noncompliant because it fails to parenthesize the replacement list:\n#define CUBE(X) (X) * (X) * (X)\nint i = 3;\nint a = 81 / CUBE(i);\nAs a result, the invocation\nint a = 81 / CUBE(i);\nexpands to\nint a = 81 / i * i * i;\nwhich evaluates as\nint a = ((81 / i) * i) * i);  /* Evaluates to 243 */\nwhich is not the desired behavior.\nCompliant Solution\nWith its replacement list parenthesized, the CUBE() macro expands correctly for this type of invocation.\n#define CUBE(X) ((X) * (X) * (X))\nint i = 3;\nint a = 81 / CUBE(i);\nThis compliant solution violates PRE00-C. Prefer inline or static functions to function-like macros. Consequently, this solution would be better implemented as an inline function.\nNoncompliant Code Example\nIn this noncompliant code example, END_OF_FILE is defined as -1. The macro replacement list consists of a unary negation operator followed by an integer literal 1:\n#define END_OF_FILE -1\n/* ... */\nif (getchar() END_OF_FILE) {\n   /* ... */\n}\nIn this example, the programmer has mistakenly omitted the comparison operator from the conditional statement, which should be getchar() != END_OF_FILE. (See void MSC02-C. Avoid errors of omission.) After macro expansion, the conditional expression is incorrectly evaluated as a binary operation: getchar()-1. This statement is syntactically correct, even though it is certainly not what the programmer intended. Note that this example also violates DCL00-C. Const-qualify immutable objects.\nParenthesizing the -1 in the declaration of END_OF_FILE ensures that the macro expansion is evaluated correctly:\n#define END_OF_FILE (-1)\nOnce this modification is made, the noncompliant code example no longer compiles because the macro expansion results in the conditional expression getchar() (-1), which is no longer syntactically valid. Note that there must be a space after END_OF_FILE because, otherwise, it becomes a function-like macro (and one that is incorrectly formed because \u22121 cannot be a formal parameter).\nCompliant Solution\nIn this compliant solution, the macro definition is replaced with an enumeration constant in compliance with DCL00-C. Const-qualify immutable objects. In addition, because EOF is a reserved macro defined in the <stdio.h> header, the compliant solution must also use a different indentifier in order to comply with DCL37-C. Do not declare or define a reserved identifier.\nenum { END_OF_FILE = -1 };\n/* ... */\nif (getchar() != END_OF_FILE) {\n   /* ... */\n}\nExceptions\nPRE02-C-EX1: A macro that expands to a single identifier or function call is not affected by the precedence of any operators in the surrounding expression, so its replacement list need not be parenthesized.\n#define MY_PID getpid()\nPRE02-C-EX2: A macro that expands to an array reference using the array-subscript operator [], or an expression designating a member of a structure or union object using either the member-access . or -> operators is not affected by the precedence of any operators in the surrounding expression, so its replacement list need not be parenthesized.\n#define NEXT_FREE block->next_free\n#define CID customer_record.account.cid\n#define TOOFAR array[MAX_ARRAY_SIZE]\nRisk Assessment\nFailing to parenthesize macro replacement lists can cause unexpected results.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPRE02-C\nMedium\nProbable\nYes\nYes\nP12\nL1\nAutomated Detection\nTool Version Checker Description\nAxivion Bauhaus Suite\n7.2.0\nCertC-PRE02\nCodeSonar\n9.1p0\nLANG.PREPROC.MACROEND\nLANG.PREPROC.MACROSTART\nMacro Does Not End With ) or }\nMacro Does Not Start With ( or {\nECLAIR\n1.2\nCC2.PRE02\nFully implemented\nHelix QAC\n2025.2\nC3409\nKlocwork\n2025.2\nMISRA.DEFINE.BADEXP\nLDRA tool suite\n9.7.1\n77 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-PRE02-a\nEnclose the entire definition of a function-like macro in parentheses\nPC-lint Plus\n1.4\n773, 973\nFully supported\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID PRE02-CPP. Macro replacement lists should be parenthesized\nISO/IEC TR 24772:2013 Operator Precedence/Order of Evaluation [JCW]\nPre-processor Directives [NMP]\nBibliography\n[Plum 1985] Rule 1-1\n[Summit 2005] Question 10.1",
        "language": "C"
    },
    {
        "rule_id": "INT30-C",
        "rule_title": "Ensure that unsigned integer operations do not wrap",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT30-C.+Ensure+that+unsigned+integer+operations+do+not+wrap",
        "content": "The C Standard, 6.2.5, paragraph 11 [ISO/IEC 9899:2024], states\nA computation involving unsigned operands can never produce an overflow, because arithmetic for the unsigned type is performed modulo 2^N .\nThis behavior is more informally called unsigned integer wrapping. Unsigned integer operations can wrap if the resulting value cannot be represented by the underlying representation of the integer. The following table indicates which operators can result in wrapping:\nOperator\nWrap\nOperator\nWrap\nOperator\nWrap\nOperator\nWrap\n+\nYes\n-=\nYes\n<<\nYes\n<\nNo\n-\nYes\n*=\nYes\n>>\nNo\n>\nNo\n*\nYes\n/=\nNo\n&\nNo\n>=\nNo\n/\nNo\n%=\nNo\n|\nNo\n<=\nNo\n%\nNo\n<<=\nYes\n^\nNo\n==\nNo\n++\nYes\n>>=\nNo\n~\nNo\n!=\nNo\n--\nYes\n&=\nNo\n!\nNo\n&&\nNo\n=\nNo\n|=\nNo\nun +\nNo\n||\nNo\n+=\nYes\n^=\nNo\nun -\nYes\n?:\nNo\n\nThe following sections examine specific operations that are susceptible to unsigned integer wrap. When operating on integer types with less precision than int, integer promotions are applied. The usual arithmetic conversions may also be applied to (implicitly) convert operands to equivalent types before arithmetic operations are performed. Programmers should understand integer conversion rules before trying to implement secure arithmetic operations. (See INT02-C. Understand integer conversion rules.)\nInteger values must not be allowed to wrap, especially if they are used in any of the following ways:\nInteger operands of any pointer arithmetic, including array indexing\nThe assignment expression for the declaration of a variable length array\nThe postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object\nFunction arguments of type size_t or rsize_t (for example, an argument to a memory allocation function)\nIn security-critical code\nThe C Standard defines arithmetic on atomic integer types as read-modify-write operations with the same representation as regular integer types. As a result, wrapping of atomic unsigned integers is identical to regular unsigned integers and should also be prevented or detected.\nAddition\nAddition is between two operands of arithmetic type or between a pointer to an object type and an integer type. This rule applies only to addition between two operands of arithmetic type. (See ARR37-C. Do not add or subtract an integer to a pointer to a non-array object and ARR30-C. Do not form or use out-of-bounds pointers or array subscripts.)\nIncrementing is equivalent to adding 1.\nNoncompliant Code Example\nThis noncompliant code example can result in an unsigned integer wrap during the addition of the unsigned operands ui_a and ui_b. If this behavior is unexpected, the resulting value may be used to allocate insufficient memory for a subsequent operation or in some other manner that can lead to an exploitable vulnerability.\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int usum = ui_a + ui_b;\n  /* ... */\n}\nCompliant Solution (Precondition Test)\nThis compliant solution performs a precondition test of the operands of the addition to guarantee there is no possibility of unsigned wrap:\n#include <limits.h>\n  void func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int usum;\n  if (UINT_MAX - ui_a < ui_b) {\n    /* Handle error */\n  } else {\n    usum = ui_a + ui_b;\n  }\n  /* ... */\n}\nCompliant Solution (Postcondition Test)\nThis compliant solution performs a postcondition test to ensure that the result of the unsigned addition operation usum is not less than the first operand:\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int usum = ui_a + ui_b;\n  if (usum < ui_a) {\n    /* Handle error */\n  }\n  /* ... */\n}\nCompliant Solution (C23, Checked Integers)\nThis compliant solution uses the new-to-C23 checked integer arithmetic to safely perform integer addition:\n#include <stdckdint.h>\n void func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int usum;\n  if (ckd_add(&usum, ui_a, ui_b)) {\n    /* Handle error */\n  }\n  /* ... */\n}\nSubtraction\nSubtraction is between two operands of arithmetic type, two pointers to qualified or unqualified versions of compatible object types, or a pointer to an object type and an integer type. This rule applies only to subtraction between two operands of arithmetic type. (See ARR36-C. Do not subtract or compare two pointers that do not refer to the same array, ARR37-C. Do not add or subtract an integer to a pointer to a non-array object, and ARR30-C. Do not form or use out-of-bounds pointers or array subscripts for information about pointer subtraction.)\nDecrementing is equivalent to subtracting 1.\nNoncompliant Code Example\nThis noncompliant code example can result in an unsigned integer wrap during the subtraction of the unsigned operands ui_a and ui_b. If this behavior is unanticipated, it may lead to an exploitable vulnerability.\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int udiff = ui_a - ui_b;\n  /* ... */\n}\nCompliant Solution (Precondition Test)\nThis compliant solution performs a precondition test of the unsigned operands of the subtraction operation to guarantee there is no possibility of unsigned wrap:\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int udiff;\n  if (ui_a < ui_b){\n    /* Handle error */\n  } else {\n    udiff = ui_a - ui_b;\n  }\n  /* ... */\n}\nCompliant Solution (Postcondition Test)\nThis compliant solution performs a postcondition test that the result of the unsigned subtraction operation udiff is not greater than the minuend:\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int udiff = ui_a - ui_b;\n  if (udiff > ui_a) {\n    /* Handle error */\n  }\n  /* ... */\n}\nCompliant Solution (C23, Checked Integers)\nThis compliant solution uses the new-to-C23 checked integer arithmetic to safely perform integer subtraction:\n#include <stdckdint.h>\n void func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int udiff;\n  if (ckd_sub(&udiff, ui_a, ui_b)) {\n    /* Handle error */\n  }\n  /* ... */\n}\nMultiplication\nMultiplication is between two operands of arithmetic type.\nNoncompliant Code Example\nThe Mozilla Foundation Security Advisory 2007-01 describes a heap buffer overflow vulnerability in the Mozilla Scalable Vector Graphics (SVG) viewer resulting from an unsigned integer wrap during the multiplication of the signed int value pen->num_vertices and the size_t value sizeof(cairo_pen_vertex_t) [VU#551436]. The signed int operand is converted to size_t prior to the multiplication operation so that the multiplication takes place between two size_t integers, which are unsigned. (See INT02-C. Understand integer conversion rules.)\npen->num_vertices = _cairo_pen_vertices_needed(\n  gstate->tolerance, radius, &gstate->ctm\n);\npen->vertices = malloc(\n  pen->num_vertices * sizeof(cairo_pen_vertex_t)\n);\nThe unsigned integer wrap can result in allocating memory of insufficient size.\nCompliant Solution\nThis compliant solution tests the operands of the multiplication to guarantee that there is no unsigned integer wrap:\npen->num_vertices = _cairo_pen_vertices_needed(\n  gstate->tolerance, radius, &gstate->ctm\n);\n if (pen->num_vertices > SIZE_MAX / sizeof(cairo_pen_vertex_t)) {\n  /* Handle error */\n}\npen->vertices = malloc(\n  pen->num_vertices * sizeof(cairo_pen_vertex_t)\n);\nCompliant Solution (C23, Checked Integers)\nThis compliant solution uses the new-to-C23 checked integer arithmetic to safely perform integer multiplication:\n#include <stdckdint.h>\n /* ... */\n pen->num_vertices = _cairo_pen_vertices_needed(\n  gstate->tolerance, radius, &gstate->ctm\n);\n size_t product;\nif (ckd_mul(&product, pen->num_vertices, sizeof(cairo_pen_vertex_t))) {\n  /* Handle error */\n}\n pen->vertices = malloc(product);\nExceptions\nINT30-C-EX1: Unsigned integers can exhibit modulo behavior (wrapping) when necessary for the proper execution of the program. It is recommended that the variable declaration be clearly commented as supporting modulo behavior and that each operation on that integer also be clearly commented as supporting modulo behavior.\nINT30-C-EX2: Checks for wraparound can be omitted when it can be determined at compile time that wraparound will not occur. As such, the following operations on unsigned integers require no validation:\nOperations on two compile-time constants\nOperations on a variable and 0 (except division or remainder by 0)\nSubtracting any variable from its type's maximum; for example, any unsigned int may safely be subtracted from UINT_MAX\nMultiplying any variable by 1\nDivision or remainder, as long as the divisor is nonzero\nRight-shifting any type maximum by any number no larger than the type precision; for example, UINT_MAX >> x is valid as long as 0 <=  x < 32 (assuming that the precision of unsigned int is 32 bits)\nINT30-C-EX3. The left-shift operator takes two operands of integer type. Unsigned left shift << can exhibit modulo behavior (wrapping).  This exception is provided because of common usage, because this behavior is usually expected by the programmer, and because the behavior is well defined. For examples of usage of the left-shift operator, see INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand.\nRisk Assessment\nInteger wrap can lead to buffer overflows and the execution of arbitrary code by an attacker. Note that this rule is not automatically repairable in contrast to INT32-C. Ensure that operations on signed integers do not result in overflow. This is because integer wrapping is occasionally intended (see INT30-C-EX1), and repairing such wrapping would turn correct code into code that spuriously signals wraparound errors.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT30-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ninteger-overflow Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-INT30 Implemented\nCodeSonar\n9.1p0\nALLOC.SIZE.ADDOFLOW\nALLOC.SIZE.IOFLOW\nALLOC.SIZE.MULOFLOW\nALLOC.SIZE.SUBUFLOW\nMISC.MEM.SIZE.ADDOFLOW\nMISC.MEM.SIZE.BAD\nMISC.MEM.SIZE.MULOFLOW\nMISC.MEM.SIZE.SUBUFLOW\nAddition overflow of allocation size\nInteger overflow of allocation size\nMultiplication overflow of allocation size\nSubtraction underflow of allocation size\nAddition overflow of size\nUnreasonable size argument\nMultiplication overflow of size\nSubtraction underflow of size\nCompass/ROSE\n\n\nCan detect violations of this rule by ensuring that operations are checked for overflow before being performed (Be mindful of exception INT30-EX2 because it excuses many operations from requiring validation, including all the operations that would validate a potentially dangerous operation. For instance, adding two unsigned ints together requires validation involving subtracting one of the numbers from UINT_MAX, which itself requires no validation because it cannot wrap.)\nCoverity\n2017.07\nINTEGER_OVERFLOW Implemented\nCppcheck Premium\n24.11.0\npremium-cert-int30-c\nHelix QAC\n2025.2\nC2910, C3383, C3384, C3385, C3386\nC++2910\nDF2911, DF2912, DF2913,\n\nKlocwork\n2025.2\nNUM.OVERFLOW\nCWARN.NOEFFECT.OUTOFRANGE\nNUM.OVERFLOW.DF\n\nLDRA tool suite\n9.7.1\n493 S, 494 S Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-INT30-a\nCERT_C-INT30-b\nCERT_C-INT30-c\nAvoid wraparounds when performing arithmetic integer operations\nInteger overflow or underflow in constant expression in '+', '-', '*' operator\nInteger overflow or underflow in constant expression in '<<' operator\nPolyspace Bug Finder\nR2025b\nCERT C: Rule INT30-C\nChecks for:\nUnsigned integer overflow\nUnsigned integer constant overflow\nRule partially covered.\nPVS-Studio\n7.38\nV658, V1012, V1028, V5005, V5011 \n\nTrustInSoft Analyzer\n1.38\nunsigned overflow Exhaustively verified.\nRelated Vulnerabilities\nCVE-2009-1385 results from a violation of this rule. The value performs an unchecked subtraction on the length of a buffer and then adds those many bytes of data to another buffer [xorl 2009]. This can cause a buffer overflow, which allows an attacker to execute arbitrary code.\nA Linux Kernel vmsplice exploit, described by Rafal Wojtczuk [Wojtczuk 2008], documents a vulnerability and exploit arising from a buffer overflow (caused by unsigned integer wrapping).\nDon Bailey [Bailey 2014] describes an unsigned integer wrap vulnerability in the LZO compression algorithm, which can be exploited in some implementations.\nCVE-2014-4377 describes a vulnerability in iOS 7.1 resulting from a multiplication operation that wraps, producing an insufficiently small value to pass to a memory allocation routine, which is subsequently overflowed.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C INT02-C. Understand integer conversion rules Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C ARR30-C. Do not form or use out-of-bounds pointers or array subscripts Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C ARR36-C. Do not subtract or compare two pointers that do not refer to the same array Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C ARR37-C. Do not add or subtract an integer to a pointer to a non-array object Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C CON08-C. Do not assume that a group of calls to independently atomic methods is atomic Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Arithmetic Wrap-Around Error [FIF] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-190, Integer Overflow or Wraparound 2016-12-02: CERT: Rule subset of CWE\nCWE 2.11 CWE-131 2017-05-16: CERT: Partial overlap\nCWE 2.11 CWE-191 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-680 2017-05-18: CERT: Partial overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-131 and INT30-C\n\nIntersection( INT30-C, MEM35-C) = \u00d8\n\n\nIntersection( CWE-131, INT30-C) =\n\n\nCalculating a buffer size such that the calculation wraps. This can happen, for example, when using malloc() or operator new[] to allocate an array, multiplying the array item size with the array dimension. An untrusted dimension could cause wrapping, resulting in a too-small buffer being allocated, and subsequently overflowed when the array is initialized.\n\n\nCWE-131 \u2013 INT30-C =\n\n\nIncorrect calculation of a buffer size that does not involve wrapping. This includes off-by-one errors, for example.\n\nINT30-C \u2013 CWE-131 =\n\nInteger wrapping where the result is not used to allocate memory.\n\n\n\nCWE-680 and INT30-C\nIntersection( CWE-680, INT30-C) =\n\nUnsigned integer overflows that lead to buffer overflows\n\nCWE-680 - INT30-C =\n\nSigned integer overflows that lead to buffer overflows\n\nINT30-C \u2013 CWE-680 =\n\nUnsigned integer overflows that do not lead to buffer overflows\n\nCWE-191 and INT30-C\nUnion( CWE-190, CWE-191) = Union( INT30-C, INT32-C) Intersection( INT30-C, INT32-C) == \u00d8\nIntersection(CWE-191, INT30-C) =\n\nUnderflow of unsigned integer operation\n\nCWE-191 \u2013 INT30-C =\n\nUnderflow of signed integer operation\n\nINT30-C \u2013 CWE-191 =\n\nOverflow of unsigned integer operation\n\nBibliography\n[Bailey 2014] Raising Lazarus - The 20 Year Old Bug that Went to Mars\n[Dowd 2006] Chapter 6, \"C Language Issues\" (\"Arithmetic Boundary Conditions,\" pp. 211\u2013223)\n[ISO/IEC 9899:2024] Subclause 6.2.5, \"Types\"\n[Seacord 2013b] Chapter 5, \"Integer Security\"\n[Viega 2005] Section 5.2.7, \"Integer Overflow\"\n[VU#551436]\n[Warren 2002] Chapter 2, \"Basics\"\n[Wojtczuk 2008]\n[xorl 2009] \"CVE-2009-1385: Linux Kernel E1000 Integer Underflow\"",
        "language": "C"
    },
    {
        "rule_id": "INT31-C",
        "rule_title": "Ensure that integer conversions do not result in lost or misinterpreted data",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT31-C.+Ensure+that+integer+conversions+do+not+result+in+lost+or+misinterpreted+data",
        "content": "Integer conversions, both implicit and explicit (using a cast), must be guaranteed not to result in lost or misinterpreted data. This rule is particularly true for integer values that originate from untrusted sources and are used in any of the following ways:\nInteger operands of any pointer arithmetic, including array indexing\nThe assignment expression for the declaration of a variable length array\nThe postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object\nFunction arguments of type size_t or rsize_t (for example, an argument to a memory allocation function)\nThis rule also applies to arguments passed to the following library functions that are converted to unsigned char:\nmemset()\nmemset_s()\nfprintf() and related functions (For the length modifier c, if no l length modifier is present, the int argument is converted to an unsigned char, and the resulting character is written.)\nfputc()\nungetc()\nmemchr()\nand to arguments to the following library functions that are converted to char:\nstrchr()\nstrrchr()\nAll of the functions listed in <ctype.h>\nThe only integer type conversions that are guaranteed to be safe for all data values and all possible conforming implementations are conversions of an integral value to a wider type of the same signedness.\nThe C Standard, subclause 6.3.1.3 [ISO/IEC 9899:2024], says\nWhen a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.\nOtherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.\nOtherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.\nTypically, converting an integer to a smaller type results in truncation of the high-order bits.\nNoncompliant Code Example (Unsigned to Signed)\nType range errors, including loss of data (truncation) and loss of sign (sign errors), can occur when converting from a value of an unsigned integer type to a value of a signed integer type. This noncompliant code example results in a truncation error on most implementations:\n#include <limits.h>\n  void func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  signed char sc;\n  sc = (signed char)u_a; /* Cast eliminates warning */\n  /* ... */\n}\nCompliant Solution (Unsigned to Signed)\nValidate ranges when converting from an unsigned type to a signed type. This compliant solution can be used to convert a value of unsigned long int type to a value of signed char type:\n#include <limits.h>\n  void func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  signed char sc;\n  if (u_a <= SCHAR_MAX) {\n    sc = (signed char)u_a;  /* Cast eliminates warning */\n  } else {\n    /* Handle error */\n  }\n}\nNoncompliant Code Example (Signed to Unsigned)\nType range errors, including loss of data (truncation) and loss of sign (sign errors), can occur when converting from a value of a signed type to a value of an unsigned type. This noncompliant code example results in a negative number being misinterpreted as a large positive number.\n#include <limits.h>\n void func(signed int si) {\n  /* Cast eliminates warning */\n  unsigned int ui = (unsigned int)si;\n   /* ... */\n}\n /* ... */\n func(INT_MIN);\nCompliant Solution (Signed to Unsigned)\nValidate ranges when converting from a signed type to an unsigned type. This compliant solution converts a value of a signed int type to a value of an unsigned int type:\n#include <limits.h>\n void func(signed int si) {\n  unsigned int ui;\n  if (si < 0) {\n    /* Handle error */\n  } else {\n    ui = (unsigned int)si;  /* Cast eliminates warning */\n  }\n  /* ... */\n}\n/* ... */\n func(INT_MIN + 1);\nSubclause 6.2.5, paragraph 11, of the C Standard [ISO/IEC 9899:2024] provides the necessary guarantees to ensure this solution works on a conforming implementation:\nThe range of nonnegative values of a signed integer type is a subrange of the corresponding unsigned integer type, and the representation of the same value in each type is the same.\nNoncompliant Code Example (Signed, Loss of Precision)\nA loss of data (truncation) can occur when converting from a value of a signed integer type to a value of a signed type with less precision. This noncompliant code example results in a truncation error on most implementations:\n#include <limits.h>\n void func(void) {\n  signed long int s_a = LONG_MAX;\n  signed char sc = (signed char)s_a; /* Cast eliminates warning */\n  /* ... */\n}\nCompliant Solution (Signed, Loss of Precision)\nValidate ranges when converting from a signed type to a signed type with less precision. This compliant solution converts a value of a signed long int type to a value of a signed char type:\n#include <limits.h>\n void func(void) {\n  signed long int s_a = LONG_MAX;\n  signed char sc;\n  if ((s_a < SCHAR_MIN) || (s_a > SCHAR_MAX)) {\n    /* Handle error */\n  } else {\n    sc = (signed char)s_a; /* Use cast to eliminate warning */\n  }\n  /* ... */\n}\nConversions from a value of a signed integer type to a value of a signed integer type with less precision requires that both the upper and lower bounds are checked.\nNoncompliant Code Example (Unsigned, Loss of Precision)\nA loss of data (truncation) can occur when converting from a value of an unsigned integer type to a value of an unsigned type with less precision. This noncompliant code example results in a truncation error on most implementations:\n#include <limits.h>\n void func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  unsigned char uc = (unsigned char)u_a; /* Cast eliminates warning */\n  /* ... */\n}\nCompliant Solution (Unsigned, Loss of Precision)\nValidate ranges when converting a value of an unsigned integer type to a value of an unsigned integer type with less precision. This compliant solution converts a value of an unsigned long int type to a value of an unsigned char type:\n#include <limits.h>\n void func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  unsigned char uc;\n  if (u_a > UCHAR_MAX) {\n    /* Handle error */\n  } else {\n    uc = (unsigned char)u_a; /* Cast eliminates warning */\n  }\n  /* ... */\n}\nConversions from unsigned types with greater precision to unsigned types with less precision require only the upper bounds to be checked.\nNoncompliant Code Example (time_t Return Value)\nThe time() function returns the value (time_t)(-1) to indicate that the calendar time is not available. The C Standard requires that the time_t type is only a real type capable of representing time. (The integer and real floating types are collectively called real types.) It is left to the implementor to decide the best real type to use to represent time. If time_t is implemented as an unsigned integer type with less precision than a signed int, the return value of time() will never compare equal to the integer literal -1.\n#include <time.h>\n  void func(void) {\n  time_t now = time(NULL);\n  if (now != -1) {\n    /* Continue processing */\n  }\n}\nCompliant Solution (time_t Return Value)\nTo ensure the comparison is properly performed, the return value of time() should be compared against -1 cast to type time_t:\n#include <time.h>\n  void func(void) {\n  time_t now = time(NULL);\n  if (now != (time_t)-1) {\n    /* Continue processing */\n  }\n}\nThis solution is in accordance with INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size. Note that (time_+t)-1 also complies with INT31-C-EX3.\nNoncompliant Code Example (memset())\nFor historical reasons, certain C Standard functions accept an argument of type int and convert it to either unsigned char or plain char. This conversion can result in unexpected behavior if the value cannot be represented in the smaller type. The second argument to memset() is an example; it indicates what byte to store in the range of memory indicated by the first and third arguments.  If the second argument is outside the range of a signed char or plain char, then its higher order bits will typically be truncated. Consequently, this noncompliant solution unexpectedly sets all elements in the array to 0, rather than 4096:\n#include <string.h>\n#include <stddef.h>\n  int *init_memory(int *array, size_t n) {\n  return memset(array, 4096, n); \n} \nCompliant Solution (memset())\nIn general, the memset() function should not be used to initialize an integer array unless it is to set or clear all the bits, as in this compliant solution:\n#include <string.h>\n#include <stddef.h>\n int *init_memory(int *array, size_t n) {\n  return memset(array, 0, n); \n} \nExceptions\nINT31-C-EX1: The C Standard defines minimum ranges for standard integer types. For example, the minimum range for an object of type unsigned short int is 0 to 65,535, whereas the minimum range for int is \u221232,767 to +32,767. Consequently, it is not always possible to represent all possible values of an unsigned short int as an int. However, on the IA-32 architecture, for example, the actual integer range is from \u22122,147,483,648 to +2,147,483,647, meaning that it is quite possible to represent all the values of an unsigned short int as an int for this architecture. As a result, it is not necessary to provide a test for this conversion on IA-32. It is not possible to make assumptions about conversions without knowing the precision of the underlying types. If these tests are not provided, assumptions concerning precision must be clearly documented, as the resulting code cannot be safely ported to a system where these assumptions are invalid. A good way to document these assumptions is to use static assertions. (See DCL03-C. Use a static assertion to test the value of a constant expression.)\nINT31-C-EX2: Conversion from any integer type with a value between SCHAR_MIN and UCHAR_MAX to a character type is permitted provided the value represents a character and not an integer.\nConversions to unsigned character types are well defined by C to have modular behavior. A character's value is not misinterpreted by the loss of sign or conversion to a negative number. For example, the Euro symbol \u20ac is sometimes represented by bit pattern 0x80 which can have the numerical value 128 or \u2212127 depending on the signedness of the type.\nConversions to signed character types are more problematic.\nThe C Standard, subclause 6.3.1.3, paragraph 3 [ISO/IEC 9899:2024], says, regarding conversions\nOtherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.\nFurthermore, subclause 6.2.6.2, paragraph 2, says, regarding integer modifications\nEach bit that is a value bit shall have the same value as the same bit in the object representation of the corresponding unsigned type. If the sign bit is zero, it shall not affect the resulting value. If the sign bit is one, it has value \u2212(2N\u22121). There may or may not be any padding bits signed char shall not have any padding bits. \n\nConsequently, the standard allows for this code to trap:\nint i = 128; /* 1000 0000 in binary */\nassert(SCHAR_MAX == 127);\nsigned char c = i; /* can trap */\nHowever, platforms where this code traps or produces an unexpected value are rare. According to The New C Standard: An Economic and Cultural Commentary by Derek Jones [Jones 2008],\nImplementations with such trap representations are thought to have existed in the past. Your author was unable to locate any documents describing such processors.\nINT31-C-EX3: The C Standard, subclause 7.29.2.5, paragraph 3 [ISO/IEC 9899:2024] says:\nThe time function returns the implementation\u2019s best approximation to the current calendar time. The value (time_t)(-1) is returned if the calendar time is not available.\nIf time_t is an unsigned type, then the expression ((time_t) (-1)) is guaranteed to yield a large positive value.\nTherefore, conversion of a negative compile-time constant to an unsigned value with the same or larger width is permitted by this rule. This exception does not apply to conversion of unsigned to signed values, nor does it apply if the resulting value would undergo truncation.\nRisk Assessment\nInteger truncation errors can lead to buffer overflows and the execution of arbitrary code by an attacker.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT31-C\nHigh\nProbable\nNo\nYes\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported via MISRA C:2012 Rules 10.1, 10.3, 10.4, 10.6 and 10.7\nCodeSonar\n9.1p0\nLANG.CAST.PC.AV\nLANG.CAST.PC.CONST2PTR\nLANG.CAST.PC.INT\nLANG.CAST.COERCE\nLANG.CAST.VALUE\nALLOC.SIZE.TRUNC\nMISC.MEM.SIZE.TRUNC\nLANG.MEM.TBA\nCast: arithmetic type/void pointer\nConversion: integer constant to pointer\nConversion: pointer/integer\nCoercion alters value\nCast alters value\nTruncation of allocation size\nTruncation of size\nTainted buffer access\nCompass/ROSE\n\nCan detect violations of this rule. However, false warnings may be raised if limits.h is included\nCoverity*\n2017.07\nNEGATIVE_RETURNS\nREVERSE_NEGATIVE\nMISRA_CAST\nCan find array accesses, loop bounds, and other expressions that may contain dangerous implied integer conversions that would result in unexpected behavior\nCan find instances where a negativity check occurs after the negative value has been used for something else\nCan find instances where an integer expression is implicitly converted to a narrower integer type, where the signedness of an integer value is implicitly converted, or where the type of a complex expression is implicitly converted\n Cppcheck\n  2.15\nmemsetValueOutOfRange\n\nCppcheck Premium\n24.11.0\nmemsetValueOutOfRange\npremium-cert-int31-c\n\nHelix QAC\n2025.2\nC2850, C2855, C2890, C2895, C2900, C2905,\nC++2850, C++2855, C++2890, C++2895, C++2900, C++2905,  C++3000, C++3010\n\nDF2851, DF2852, DF2853,  DF2856, DF2857, DF2858, DF2891, DF2892, DF2893, DF2896, DF2897, DF2898, DF2901, DF2902, DF2903, DF2906, DF2907, DF2908\n\nKlocwork\n2025.2\nPORTING.CAST.SIZE\n\nLDRA tool suite\n9.7.1\n93 S, 433 S, 434 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-INT31-a\nCERT_C-INT31-b\nCERT_C-INT31-c\nCERT_C-INT31-d\nCERT_C-INT31-e\nCERT_C-INT31-f\nCERT_C-INT31-g\nCERT_C-INT31-h\nCERT_C-INT31-i\nCERT_C-INT31-j\nCERT_C-INT31-k\nCERT_C-INT31-l\nCERT_C-INT31-m\nCERT_C-INT31-n\nCERT_C-INT31-o\nCERT_C-INT31-p\nAn expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value\nAn operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value\nAn operand of essentially character type should not be used where an operand is interpreted as a numeric value\nAn operand of essentially enum type should not be used in an arithmetic operation\nShift and bitwise operations should not be performed on operands of essentially signed or enum type\nAn operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator\nAn operand of essentially unsigned type should not be used as the operand to the unary minus operator\nThe value of an expression shall not be assigned to an object with a narrower essential type\nThe value of an expression shall not be assigned to an object of a different essential type category\nBoth operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category\nThe second and third operands of the ternary operator shall have the same essential type category\nThe value of a composite expression shall not be assigned to an object with wider essential type\nIf a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type\nIf a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type\nAvoid data loss when converting between integer types\nAvoid value change when converting between integer types\nPolyspace Bug Finder\nR2025b\nCERT C: Rule INT31-C\n\nChecks for:\nInteger conversion overflow\nCall to memset with unintended value\nSign change integer conversion overflow\nTainted sign change conversion\nUnsigned integer conversion overflow\nRule partially covered.\nPVS-Studio\n7.38\nV562, V569, V642, V676, V716, V721, V724, V732, V739, V784, V793, V1019,  V1029, V1046\n\nRuleChecker\n24.04\n\nSupported via MISRA C:2012 Rules 10.1, 10.3, 10.4, 10.6 and 10.7\nSecurity Reviewer - Static Reviewer\n\n6.02\n\nClRVNU\nCmAD\nCmemleakOnRealloc\nCmissingReturn\nCMR\nCmVOOR\nCnAS Fully implemented\nTrustInSoft Analyzer\n1.38\nsigned_downcast Exhaustively verified.\n* Coverity Prevent cannot discover all violations of this rule, so further verification is necessary.\nRelated Vulnerabilities\nCVE-2009-1376 results from a violation of this rule. In version 2.5.5 of Pidgin, a size_t offset is set to the value of a 64-bit unsigned integer, which can lead to truncation [xorl 2009] on platforms where a size_t is implemented as a 32-bit unsigned integer. An attacker can execute arbitrary code by carefully choosing this value and causing a buffer overflow.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C DCL03-C. Use a static assertion to test the value of a constant expression Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C FIO34-C. Distinguish between characters read from a file and EOF or WEOF Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java NUM12-J. Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Numeric Conversion Errors [FLC] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 10.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 10.3 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 10.4 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 10.6 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 10.7 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-192, Integer Coercion Error 2017-07-17: CERT: Exact\nCWE 2.11 CWE-197, Numeric Truncation Error 2017-06-14: CERT: Rule subset of CWE\nCWE 2.11 CWE-681, Incorrect Conversion between Numeric Types 2017-07-17: CERT: Rule subset of CWE\nCWE 2.11 CWE-704 2017-07-17: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-195 and INT31-C\nCWE-195 = Subset( CWE-192)\nINT31-C = Union( CWE-195, list) where list =\nUnsigned-to-signed conversion error\nTruncation that does not change sign\nCWE-197 and INT31-C\nSee CWE-197 and FLP34-C\nCWE-194 and INT31-C\nCWE-194 = Subset( CWE-192)\nINT31-C = Union( CWE-194, list) where list =\nInteger conversion that truncates significant data, but without loss of sign\nCWE-20 and INT31-C\nSee CWE-20 and ERR34-C\nCWE-704 and INT31-C\nCWE-704 = Union( INT31-C, list) where list =\nImproper type casts where either the source or target type is not an integral type\nCWE-681 and INT31-C\nCWE-681 = Union( INT31-C, FLP34-C)\nIntersection( INT31-C, FLP34-C) = \u00d8\nBibliography\n[Dowd 2006] Chapter 6, \"C Language Issues\" (\"Type Conversions,\" pp. 223\u2013270)\n[ISO/IEC 9899:2024]\n6.3.1.3, \"Signed and Unsigned Integers\"\n6.2.5, \"Types\"\n7.29.2.5, \"The time function\"\n[Jones 2008] Section 6.2.6.2, \"Integer Types\"\n[Seacord 2013b] Chapter 5, \"Integer Security\"\n[Viega 2005] Section 5.2.9, \"Truncation Error\"\nSection 5.2.10, \"Sign Extension Error\"\nSection 5.2.11, \"Signed to Unsigned Conversion Error\"\nSection 5.2.12, \"Unsigned to Signed Conversion Error\"\n[Warren 2002] Chapter 2, \"Basics\"\n[xorl 2009] \"CVE-2009-1376: Pidgin MSN SLP Integer Truncation\"",
        "language": "C"
    },
    {
        "rule_id": "INT32-C",
        "rule_title": "Ensure that operations on signed integers do not result in overflow",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow",
        "content": "Signed integer overflow is undefined behavior 36. Consequently, implementations have considerable latitude in how they deal with signed integer overflow. (See MSC15-C. Do not depend on undefined behavior.) An implementation that defines signed integer types as being modulo, for example, need not detect integer overflow. Implementations may also trap on signed arithmetic overflows, or simply assume that overflows will never happen and generate object code accordingly.  It is also possible for the same conforming implementation to emit code that exhibits different behavior in different contexts. For example, an implementation may determine that a signed integer loop control variable declared in a local scope cannot overflow and may emit efficient code on the basis of that determination, while the same implementation may determine that a global variable used in a similar context will wrap.\nFor these reasons, it is important to ensure that operations on signed integers do not result in overflow. Of particular importance are operations on signed integer values that originate from a tainted source and are used as\nInteger operands of any pointer arithmetic, including array indexing\nThe assignment expression for the declaration of a variable length array\nThe postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object\nFunction arguments of type size_t or rsize_t (for example, an argument to a memory allocation function)\nInteger operations will overflow if the resulting value cannot be represented by the underlying representation of the integer. The following table indicates which operations can result in overflow.\nOperator\nOverflow\nOperator\nOverflow\nOperator\nOverflow\nOperator\nOverflow\n+\nYes\n-=\nYes\n<<\nYes\n<\nNo\n-\nYes\n*=\nYes\n>>\nNo\n>\nNo\n*\nYes\n/=\nYes\n&\nNo\n>=\nNo\n/\nYes\n%=\nYes\n|\nNo\n<=\nNo\n%\nYes\n<<=\nYes\n^\nNo\n==\nNo\n++\nYes\n>>=\nNo\n~\nNo\n!=\nNo\n--\nYes\n&=\nNo\n!\nNo\n&&\nNo\n=\nNo\n|=\nNo\nunary +\nNo\n||\nNo\n+=\nYes\n^=\nNo\nunary -\nYes\n?:\nNo\nThe following sections examine specific operations that are susceptible to integer overflow. When operating on integer types with less precision than int, integer promotions are applied. The usual arithmetic conversions may also be applied to (implicitly) convert operands to equivalent types before arithmetic operations are performed. Programmers should understand integer conversion rules before trying to implement secure arithmetic operations. (See INT02-C. Understand integer conversion rules.)\nImplementation Details\nGNU GCC invoked with the -fwrapv command-line option defines the same modulo arithmetic for both unsigned and signed integers.\nGNU GCC invoked with the -ftrapv command-line option causes a trap to be generated when a signed integer overflows, which will most likely abnormally exit. On a UNIX system, the result of such an event may be a signal sent to the process.\nGNU GCC invoked without either the -fwrapv or the -ftrapv option may simply assume that signed integers never overflow and may generate object code accordingly.\nAtomic Integers\nThe C Standard defines the behavior of arithmetic on atomic signed integer types to use two's complement representation with silent wraparound on overflow; there are no undefined results. Although defined, these results may be unexpected and therefore carry similar risks to unsigned integer wrapping. (See INT30-C. Ensure that unsigned integer operations do not wrap.) Consequently, signed integer overflow of atomic integer types should also be prevented or detected. \nAddition\nAddition is between two operands of arithmetic type or between a pointer to an object type and an integer type. This rule applies only to addition between two operands of arithmetic type. (See ARR37-C. Do not add or subtract an integer to a pointer to a non-array object and ARR30-C. Do not form or use out-of-bounds pointers or array subscripts.)\nIncrementing is equivalent to adding 1.\nNoncompliant Code Example\nThis noncompliant code example can result in a signed integer overflow during the addition of the signed operands si_a and si_b:\nvoid func(signed int si_a, signed int si_b) {\n  signed int sum = si_a + si_b;\n  /* ... */\n}\nCompliant Solution\nThis compliant solution ensures that the addition operation cannot overflow, regardless of representation:\n#include <limits.h>\n \nvoid f(signed int si_a, signed int si_b) {\n  signed int sum;\n  if (((si_b > 0) && (si_a > (INT_MAX - si_b))) ||\n      ((si_b < 0) && (si_a < (INT_MIN - si_b)))) {\n    /* Handle error */\n  } else {\n    sum = si_a + si_b;\n  }\n  /* ... */\n}\nCompliant Solution (C23, Checked Integers)\nThis compliant solution uses the new-to-C23 checked integer arithmetic to safely perform integer addition:\n#include <stdckdint.h>\n\nvoid f(signed int si_a, signed int si_b) {\n  int sum;\n  if (ckd_add(&sum, si_a, si_b)) {\n    /* Handle error */\n  }\n  /* ... */\n}\nSubtraction\nSubtraction is between two operands of arithmetic type, two pointers to qualified or unqualified versions of compatible object types, or a pointer to an object type and an integer type. This rule applies only to subtraction between two operands of arithmetic type. (See ARR36-C. Do not subtract or compare two pointers that do not refer to the same array, ARR37-C. Do not add or subtract an integer to a pointer to a non-array object, and ARR30-C. Do not form or use out-of-bounds pointers or array subscripts for information about pointer subtraction.)\nDecrementing is equivalent to subtracting 1.\nNoncompliant Code Example\nThis noncompliant code example can result in a signed integer overflow during the subtraction of the signed operands si_a and si_b:\nvoid func(signed int si_a, signed int si_b) {\n  signed int diff = si_a - si_b;\n  /* ... */\n}\nCompliant Solution\nThis compliant solution tests the operands of the subtraction to guarantee there is no possibility of signed overflow, regardless of representation:\n#include <limits.h>\n \nvoid func(signed int si_a, signed int si_b) {\n  signed int diff;\n  if ((si_b > 0 && si_a < INT_MIN + si_b) ||\n      (si_b < 0 && si_a > INT_MAX + si_b)) {\n    /* Handle error */\n  } else {\n    diff = si_a - si_b;\n  }\n\n  /* ... */\n}\nCompliant Solution (C23, Checked Integers)\nThis compliant solution uses the new-to-C23 checked integer arithmetic to safely perform integer subtraction:\n#include <stdckdint.h>\n\nvoid f(signed int si_a, signed int si_b) {\n  int diff;\n  if (ckd_sub(&diff, si_a, si_b)) {\n    /* Handle error */\n  }\n  /* ... */\n}\nMultiplication\nMultiplication is between two operands of arithmetic type.\nNoncompliant Code Example\nThis noncompliant code example can result in a signed integer overflow during the multiplication of the signed operands si_a and si_b:\nvoid func(signed int si_a, signed int si_b) {\n  signed int result = si_a * si_b;\n  /* ... */\n}\nCompliant Solution\nThe product of two operands can always be represented using twice the number of bits than exist in the precision of the larger of the two operands. This compliant solution eliminates signed overflow on systems where long long is at least twice the precision of int:\n#include <stddef.h>\n#include <assert.h>\n#include <limits.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value) \n  \nvoid func(signed int si_a, signed int si_b) {\n  signed int result;\n  signed long long tmp;\n  assert(PRECISION(ULLONG_MAX) >= 2 * PRECISION(UINT_MAX));\n  tmp = (signed long long)si_a * (signed long long)si_b;\n \n  /*\n   * If the product cannot be represented as a 32-bit integer,\n   * handle as an error condition.\n   */\n  if ((tmp > INT_MAX) || (tmp < INT_MIN)) {\n    /* Handle error */\n  } else {\n    result = (int)tmp;\n  }\n  /* ... */\n}\nThe assertion fails if long long has less than twice the precision of int. The  PRECISION() macro and popcount() function provide the correct precision for any integer type. (See INT35-C. Use correct integer precisions.)\nCompliant Solution\nThe following portable compliant solution can be used with any conforming implementation, including those that do not have an integer type that is at least twice the precision of int:\n#include <limits.h>\n \nvoid func(signed int si_a, signed int si_b) {\n  signed int result;  \n  if (si_a > 0) {  /* si_a is positive */\n    if (si_b > 0) {  /* si_a and si_b are positive */\n      if (si_a > (INT_MAX / si_b)) {\n        /* Handle error */\n      }\n    } else { /* si_a positive, si_b nonpositive */\n      if (si_b < (INT_MIN / si_a)) {\n        /* Handle error */\n      }\n    } /* si_a positive, si_b nonpositive */\n  } else { /* si_a is nonpositive */\n    if (si_b > 0) { /* si_a is nonpositive, si_b is positive */\n      if (si_a < (INT_MIN / si_b)) {\n        /* Handle error */\n      }\n    } else { /* si_a and si_b are nonpositive */\n      if ( (si_a != 0) && (si_b < (INT_MAX / si_a))) {\n        /* Handle error */\n      }\n    } /* End if si_a and si_b are nonpositive */\n  } /* End if si_a is nonpositive */\n\n  result = si_a * si_b;\n}\nCompliant Solution (C23, Checked Integers)\nThis compliant solution uses the new-to-C23 checked integer arithmetic to safely perform integer subtraction:\n#include <stdckdint.h>\n\nvoid func(signed int si_a, signed int si_b) {\n  int product;\n  if (ckd_mul(&product, si_a, si_b)) {\n    /* Handle error */\n  }\n  /* ... */\n}\nDivision\nDivision is between two operands of arithmetic type. Overflow can occur during two's complement signed integer division when the dividend is equal to the minimum (negative) value for the signed integer type and the divisor is equal to \u22121. Division operations are also susceptible to divide-by-zero errors. (See INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors.)\nNoncompliant Code Example\nThis noncompliant code example prevents divide-by-zero errors in compliance with  INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors but does not prevent a signed integer overflow error in two's-complement. \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if (s_b == 0) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\nImplementation Details\nOn the x86-32 architecture, overflow results in a fault, which can be exploited as a  denial-of-service attack.\nCompliant Solution\nThis compliant solution eliminates the possibility of divide-by-zero errors or signed overflow:\n#include <limits.h>\n \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\nRemainder\nThe remainder operator provides the remainder when two operands of integer type are divided. Because many platforms implement remainder and division in the same instruction, the remainder operator is also susceptible to arithmetic overflow and division by zero. (See INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors.)\nNoncompliant Code Example\nMany hardware architectures implement remainder as part of the division operator, which can overflow. Overflow can occur during a remainder operation when the dividend is equal to the minimum (negative) value for the signed integer type and the divisor is equal to \u22121. It occurs even though the result of such a remainder operation is mathematically 0. This noncompliant code example prevents divide-by-zero errors in compliance with INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors but does not prevent integer overflow:\nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if (s_b == 0) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  }\n  /* ... */\n}\nImplementation Details\nOn x86-32 platforms, the remainder operator for signed integers is implemented by the idiv instruction code, along with the divide operator. Because LONG_MIN / \u22121 overflows, it results in a software exception with LONG_MIN % \u22121 as well.\nCompliant Solution\nThis compliant solution also tests the remainder operands to guarantee there is no possibility of an overflow:\n#include <limits.h>\n \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0 ) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  }  \n  /* ... */\n}\n\nLeft-Shift Operator\nThe left-shift operator takes two integer operands. The result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. \nThe C Standard, 6.5.8, paragraph 4 [ISO/IEC 9899:2024], states\nIf E1 has a signed type and nonnegative value, and E1 \u00d7 2E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.\nIn almost every case, an attempt to shift by a negative number of bits or by more bits than exist in the operand indicates a logic error. These issues are covered by INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand.\nNoncompliant Code Example\nThis noncompliant code example performs a left shift, after verifying that the number being shifted is not negative, and the number of bits to shift is valid.  The PRECISION() macro and popcount() function provide the correct precision for any integer type. (See INT35-C. Use correct integer precisions.) However, because this code does no overflow check, it can result in an unrepresentable value. \n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value) \n\nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX))) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  } \n  /* ... */\n}\nCompliant Solution\nThis compliant solution eliminates the possibility of overflow resulting from a left-shift operation:\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value) \n\nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) ||\n      (si_a > (LONG_MAX >> si_b))) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  } \n  /* ... */\n}\nUnary Negation\nThe unary negation operator takes an operand of arithmetic type. Overflow can occur during two's complement unary negation when the operand is equal to the minimum (negative) value for the signed integer type.\nNoncompliant Code Example\nThis noncompliant code example can result in a signed integer overflow during the unary negation of the signed operand s_a:\nvoid func(signed long s_a) {\n  signed long result = -s_a;\n  /* ... */\n}\nCompliant Solution\nThis compliant solution tests the negation operation to guarantee there is no possibility of signed overflow:\n#include <limits.h>\n \nvoid func(signed long s_a) {\n  signed long result;\n  if (s_a == LONG_MIN) {\n    /* Handle error */\n  } else {\n    result = -s_a;\n  }\n  /* ... */\n}\nRisk Assessment\nInteger overflow can lead to buffer overflows and the execution of arbitrary code by an attacker.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT32-C\nHigh\nLikely\nNo\nYes\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ninteger-overflow\nFully checked\nCodeSonar\n9.1p0\nALLOC.SIZE.ADDOFLOW\nALLOC.SIZE.IOFLOW\nALLOC.SIZE.MULOFLOW\nALLOC.SIZE.SUBUFLOW\nMISC.MEM.SIZE.ADDOFLOW\nMISC.MEM.SIZE.BAD\nMISC.MEM.SIZE.MULOFLOW\nMISC.MEM.SIZE.SUBUFLOW\nAddition overflow of allocation size\nInteger overflow of allocation size\nMultiplication overflow of allocation size\nSubtraction underflow of allocation size\nAddition overflow of size\nUnreasonable size argument\nMultiplication overflow of size\nSubtraction underflow of size\nCoverity\n2017.07\nTAINTED_SCALAR\nBAD_SHIFT\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-int32-c\nHelix QAC\n2025.2\nC2800, C2860\nC++2800, C++2860\nDF2801, DF2802, DF2803, DF2861, DF2862, DF2863\n\nKlocwork\n2025.2\nNUM.OVERFLOW\nCWARN.NOEFFECT.OUTOFRANGE\nNUM.OVERFLOW.DF\n\nLDRA tool suite\n9.7.1\n493 S, 494 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-INT32-a\nCERT_C-INT32-b\nCERT_C-INT32-c\nAvoid signed integer overflows\nInteger overflow or underflow in constant expression in '+', '-', '*' operator\nInteger overflow or underflow in constant expression in '<<' operator\nParasoft Insure++\n\nRuntime analysis\nPolyspace Bug Finder\nR2025b\nCERT C: Rule INT32-C\n\nChecks for:\nInteger overflow\nTainted division operand\nTainted modulo operand\nRule partially covered.\nPVS-Studio\n7.38\nV1026, V1070, V1081, V1083, V1085, V5010\nSecurity Reviewer - Static Reviewer\n6.02\nCNI Fully implemented\nTrustInSoft Analyzer\n1.38\nsigned_overflow\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C INT02-C. Understand integer conversion rules Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C INT35-C. Use correct integer precisions Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C ARR30-C. Do not form or use out-of-bounds pointers or array subscripts Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C ARR36-C. Do not subtract or compare two pointers that do not refer to the same array Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C ARR37-C. Do not add or subtract an integer to a pointer to a non-array object Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C MSC15-C. Do not depend on undefined behavior Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C CON08-C. Do not assume that a group of calls to independently atomic methods is atomic Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java INT00-J. Perform explicit range checking to avoid integer overflow Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Arithmetic Wrap-Around Error [FIF] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Overflowing signed integers [intoflow] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-190, Integer Overflow or Wraparound 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-191 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-680 2017-05-18: CERT: Partial overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-20 and INT32-C\nSee CWE-20 and ERR34-C\nCWE-680 and INT32-C\nIntersection( INT32-C, MEM35-C) = \u00d8\nIntersection( CWE-680, INT32-C) =\nSigned integer overflows that lead to buffer overflows\nCWE-680 - INT32-C =\nUnsigned integer overflows that lead to buffer overflows\nINT32-C \u2013 CWE-680 =\nSigned integer overflows that do not lead to buffer overflows\nCWE-191 and INT32-C\nUnion( CWE-190, CWE-191) = Union( INT30-C, INT32-C)\nIntersection( INT30-C, INT32-C) == \u00d8\nIntersection(CWE-191, INT32-C) =\nUnderflow of signed integer operation\nCWE-191 \u2013 INT32-C =\nUnderflow of unsigned integer operation\nINT32-C \u2013 CWE-191 =\nOverflow of signed integer operation\nCWE-190 and INT32-C\nUnion( CWE-190, CWE-191) = Union( INT30-C, INT32-C)\nIntersection( INT30-C, INT32-C) == \u00d8\nIntersection(CWE-190, INT32-C) =\nOverflow (wraparound) of signed integer operation\nCWE-190 \u2013 INT32-C =\nOverflow of unsigned integer operation\nINT32-C \u2013 CWE-190 =\nUnderflow of signed integer operation\nBibliography\n[Dowd 2006] Chapter 6, \"C Language Issues\" (\"Arithmetic Boundary Conditions,\" pp. 211\u2013223)\n[ISO/IEC 9899:2024] Subclause 6.5.8, \"Bitwise shift operators\"\n[Seacord 2013b] Chapter 5, \"Integer Security\"\n[Viega 2005] Section 5.2.7, \"Integer Overflow\"\n[Warren 2002] Chapter 2, \"Basics\"",
        "language": "C"
    },
    {
        "rule_id": "INT33-C",
        "rule_title": "Ensure that division and remainder operations do not result in divide-by-zero errors",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT33-C.+Ensure+that+division+and+remainder+operations+do+not+result+in+divide-by-zero+errors",
        "content": "The C Standard identifies the following condition under which division and remainder operations result in undefined behavior (UB):\nUB Description\n41\nThe value of the second operand of the / or % operator is zero (6.5.5).\nEnsure that division and remainder operations do not result in divide-by-zero errors.\nDivision\nThe result of the / operator is the quotient from the division of the first arithmetic operand by the second arithmetic operand. Division operations are susceptible to divide-by-zero errors. Overflow can also occur during two's complement signed integer division when the dividend is equal to the minimum (most negative) value for the signed integer type and the divisor is equal to \u22121. (See INT32-C. Ensure that operations on signed integers do not result in overflow.)\nNoncompliant Code Example\nThis noncompliant code example prevents signed integer overflow in compliance with INT32-C. Ensure that operations on signed integers do not result in overflow but fails to prevent a divide-by-zero error during the division of the signed operands s_a and s_b:\n#include <limits.h>\n  void func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_a == LONG_MIN) && (s_b == -1)) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\nCompliant Solution\nThis compliant solution tests the division operation to guarantee there is no possibility of divide-by-zero errors or signed overflow:\n#include <limits.h>\n  void func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\nRemainder\nThe remainder operator provides the remainder when two operands of integer type are divided. \nNoncompliant Code Example\nThis noncompliant code example prevents signed integer overflow in compliance with INT32-C. Ensure that operations on signed integers do not result in overflow but fails to prevent a divide-by-zero error during the remainder operation on the signed operands s_a and s_b:\n#include <limits.h>\n  void func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_a == LONG_MIN) && (s_b == -1)) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  }\n  /* ... */\n}\nCompliant Solution\nThis compliant solution tests the remainder operand to guarantee there is no possibility of a divide-by-zero error or an overflow error:\n#include <limits.h>\n  void func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0 ) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  }\n  /* ... */\n}\nRisk Assessment\nA divide-by-zero error can result in abnormal program termination and denial of service.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT33-C\nLow\nLikely\nNo\nYes\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nint-division-by-zero\nint-modulo-by-zero\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-INT33\nCodeSonar\n9.1p0\nLANG.ARITH.DIVZERO\nLANG.ARITH.FDIVZERO\nDivision by zero\nFloat Division By Zero\nCompass/ROSE\n\nCan detect some violations of this rule (In particular, it ensures that all operations involving division or modulo are preceded by a check ensuring that the second operand is nonzero.)\nCoverity\n2017.07\nDIVIDE_BY_ZERO\nFully implemented\nCppcheck\n 2.15\nzerodiv\nzerodivcond\n\nCppcheck Premium\n24.11.0\nzerodiv\nzerodivcond\npremium-cert-int33-c\n\nHelix QAC\n2025.2\nC2830\nC++2830\nDF2831, DF2832, DF2833\n\nKlocwork\n2025.2\nDBZ.CONST\nDBZ.CONST.CALL\nDBZ.GENERAL\nDBZ.ITERATOR\nDBZ.ITERATOR.CALL\n\nLDRA tool suite\n9.7.1\n43 D, 127 D, 248 S, 629 S, 80 X\nPartially implemented\nParasoft C/C++test 2024.2\nCERT_C-INT33-a\nAvoid division by zero\nParasoft Insure++\n\nRuntime analysis\nPolyspace Bug Finder\nR2025b\nCERT C: Rule INT33-C\n\nChecks for:\nInteger division by zero\nTainted division operand\nTainted modulo operand\nRule fully covered.\nSecurity Reviewer - Static Reviewer\n6.02\nCPP_02\nFully implemented\nSonarQube C/C++ Plugin\n3.11\nS3518\nPVS-Studio\n7.38\nV609\nTrustInSoft Analyzer\n1.38\ndivision_by_zero\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C INT32-C. Ensure that operations on signed integers do not result in overflow Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java NUM02-J. Ensure that division and remainder operations do not result in divide-by-zero errors Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Integer division errors [diverr] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-369, Divide By Zero 2017-07-07: CERT: Exact\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-682 and INT33-C\nCWE-682 = Union( INT33-C, list) where list =\n\nIncorrect calculations that do not involve division by zero\n\nBibliography\n[Seacord 2013b] Chapter 5, \"Integer Security\"\n[Warren 2002] Chapter 2, \"Basics\"",
        "language": "C"
    },
    {
        "rule_id": "INT34-C",
        "rule_title": "Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT34-C.+Do+not+shift+an+expression+by+a+negative+number+of+bits+or+by+greater+than+or+equal+to+the+number+of+bits+that+exist+in+the+operand",
        "content": "Bitwise shifts include left-shift operations of the form shift-expression << additive-expression and right-shift operations of the form shift-expression >> additive-expression. The standard integer promotions are first performed on the operands, each of which has an integer type. The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined. (See undefined behavior 48.)\nDo not shift an expression by a negative number of bits or by a number greater than or equal to the precision of the promoted left operand. The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits. For unsigned integer types, the width and the precision are the same; whereas for signed integer types, the width is one greater than the precision. This rule uses precision instead of width because, in almost every case, an attempt to shift by a number of bits greater than or equal to the precision of the operand indicates a bug (logic error). A logic error is different from overflow, in which there is simply a representational deficiency.  In general, shifts should be performed only on unsigned operands. (See INT13-C. Use bitwise operators only on unsigned operands.)\nNoncompliant Code Example (Left Shift, Unsigned Type)\nThe result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. The following diagram illustrates the left-shift operation.\nAccording to the C Standard, if E1 has an unsigned type, the value of the result is E1 * 2E2, reduced modulo 1 more than the maximum value representable in the result type. \nThis noncompliant code example fails to ensure that the right operand is less than the precision of the promoted left operand:\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = ui_a << ui_b;\n  /* ... */\n}\nCompliant Solution (Left Shift, Unsigned Type)\nThis compliant solution eliminates the possibility of shifting by greater than or equal to the number of bits that exist in the precision of the left operand:\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n\nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = 0;\n  if (ui_b >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  } else {\n    uresult = ui_a << ui_b;\n  }\n  /* ... */\n}\nThe PRECISION() macro and popcount() function provide the correct precision for any integer type. (See INT35-C. Use correct integer precisions.)\nModulo behavior resulting from left-shifting an unsigned integer type is permitted by exception INT30-EX3 to INT30-C. Ensure that unsigned integer operations do not wrap.\nNoncompliant Code Example (Left Shift, Signed Type)\nThe result of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are filled with zeros. If E1 has a signed type and nonnegative value, and E1 * 2E2 is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined (See undefined behavior 48.).\nThis noncompliant code example fails to ensure that left and right operands have nonnegative values and that the right operand is less than the precision of the promoted left operand. This example does check for signed integer overflow in compliance with INT32-C. Ensure that operations on signed integers do not result in overflow.\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n\nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if (si_a > (LONG_MAX >> si_b)) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\nShift operators and other bitwise operators should be used only with unsigned integer operands in accordance with INT13-C. Use bitwise operators only on unsigned operands.\nCompliant Solution (Left Shift, Signed Type)\nIn addition to the check for overflow, this compliant solution ensures that both the left and right operands have nonnegative values and that the right operand is less than the precision of the promoted left operand:\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) ||\n      (si_a > (LONG_MAX >> si_b))) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n\nNoncompliant Code Example (Right Shift)\nThe result of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed type and a nonnegative value, the value of the result is the integral part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the resulting value is implementation-defined and can be either an arithmetic (signed) shift\nor a logical (unsigned) shift\nThis noncompliant code example fails to test whether the right operand is greater than or equal to the precision of the promoted left operand, allowing undefined behavior (See undefined behavior 48.):\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = ui_a >> ui_b;\n  /* ... */\n}\nWhen working with signed operands, making assumptions about whether a right shift is implemented as an arithmetic (signed) shift or a logical (unsigned) shift can also lead to vulnerabilities. (See INT13-C. Use bitwise operators only on unsigned operands.)\nCompliant Solution (Right Shift)\nThis compliant solution eliminates the possibility of shifting by greater than or equal to the number of bits that exist in the precision of the left operand:\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n\nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = 0;\n  if (ui_b >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  } else {\n    uresult = ui_a >> ui_b;\n  }\n  /* ... */\n}\nImplementation Details\nGCC has no options to handle shifts by negative amounts or by amounts outside the width of the type predictably or to trap on them; they are always treated as undefined. Processors may reduce the shift amount modulo the width of the type. For example, 32-bit right shifts are implemented using the following instruction on x86-32:\nsarl   %cl, %eax\nThe sarl instruction takes a bit mask of the least significant 5 bits from %cl to produce a value in the range [0, 31] and then shift %eax that many bits:\n// 64-bit right shifts on IA-32 platforms become\nshrdl  %edx, %eax\nsarl   %cl, %edx\nwhere %eax stores the least significant bits in the doubleword to be shifted, and %edx stores the most significant bits.\nRisk Assessment\nAlthough shifting a negative number of bits or shifting a number of bits greater than or equal to the width of the promoted left operand is undefined behavior in C, the risk is generally low because processors frequently reduce the shift amount modulo the width of the type.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT34-C\nLow\nUnlikely\nNo\nYes\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nprecision-shift-width\nprecision-shift-width-constant\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-INT34 Can detect shifts by a negative or an excessive number of bits and right shifts on negative values.\nCodeSonar\n9.1p0\nLANG.ARITH.BIGSHIFT\nLANG.ARITH.NEGSHIFT\nShift amount exceeds bit width\nNegative shift amount\nCompass/ROSE\n\n\nCan detect violations of this rule. Unsigned operands are detected when checking for INT13-C. Use bitwise operators only on unsigned operands\nCoverity\n2017.07\nBAD_SHIFT\nImplemented\nCppcheck\n 2.15\nshiftNegative, shiftTooManyBits\n\nCppcheck Premium\n24.11.0\nshiftNegative, shiftTooManyBits\npremium-cert-int34-c\n\nECLAIR\n1.2\nCC2.INT34 Partially implemented\nHelix QAC\n2025.2\nC0499, C2790, \nC++2790,  C++3003\nDF2791, DF2792, DF2793\n\nKlocwork\n2025.2\nMISRA.SHIFT.RANGE.2012\n\nLDRA tool suite\n9.7.1\n51 S, 403 S, 479 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-INT34-a\nAvoid incorrect shift operations\nPolyspace Bug Finder\nR2025b\nCERT C: Rule INT34-C\n\nChecks for:\nShift of a negative value\nShift operation overflow\nRule partially covered.\nPVS-Studio\n7.38\nV610\nRuleChecker\n24.04\nprecision-shift-width-constant\nPartially checked\nSecurity Reviewer - Static Reviewer\n6.02\nCPP_03\nFully implemented\nTrustInSoft Analyzer\n1.38\nshift\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C INT13-C. Use bitwise operators only on unsigned operands Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C INT35-C. Use correct integer precisions Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C INT32-C. Ensure that operations on signed integers do not result in overflow Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Arithmetic Wrap-Around Error [FIF] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-682 2017-07-07: CERT: Rule subset of CWE\nCWE 2.11 CWE-758 2017-07-07: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-758 and INT34-C\nIndependent( INT34-C, INT36-C, MEM30-C, MSC37-C, FLP32-C, EXP33-C, EXP30-C, ERR34-C, ARR32-C)\nCWE-758 = Union( INT34-C, list) where list =\n\nUndefined behavior that results from anything other than incorrect bit shifting\n\nCWE-682 and INT34-C\nIndependent( INT34-C, FLP32-C, INT33-C) CWE-682 = Union( INT34-C, list) where list =\n\nIncorrect calculations that do not involve out-of-range bit shifts\n\nBibliography\n[C99 Rationale 2003] 6.5.7, \"Bitwise Shift Operators\"\n[Dowd 2006] Chapter 6, \"C Language Issues\"\n[Seacord 2013b] Chapter 5, \"Integer Security\"\n[Viega 2005] Section 5.2.7, \"Integer Overflow\"",
        "language": "C"
    },
    {
        "rule_id": "INT35-C",
        "rule_title": "Use correct integer precisions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT35-C.+Use+correct+integer+precisions",
        "content": "Integer types in C have both a size and a precision. The size indicates the number of bytes used by an object and can be retrieved for any object or type using the sizeof operator.  The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits.\nPadding bits contribute to the integer's size, but not to its precision. Consequently, inferring the precision of an integer type from its size may result in too large a value, which can then lead to incorrect assumptions about the numeric range of these types.  Programmers should use correct integer precisions in their code, and in particular, should not use the sizeof operator to compute the precision of an integer type on architectures that use padding bits or in strictly conforming (that is, portable) programs.\nNoncompliant Code Example\nThis noncompliant code example illustrates a function that produces 2 raised to the power of the function argument. To prevent undefined behavior (See undefined behavior 48.) in compliance with INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand, the function ensures that the argument is less than the number of bits used to store a value of type unsigned int.\n#include <limits.h>\n \nunsigned int pow2(unsigned int exp) {\n  if (exp >= sizeof(unsigned int) * CHAR_BIT) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}\nHowever, if this code runs on a platform where unsigned int has one or more padding bits, it can still result in values for exp that are too large. For example, on a platform that stores unsigned int in 64 bits, but uses only 48 bits to represent the value, a left shift of 56 bits would result in undefined behavior (See undefined behavior 48.).\nCompliant Solution (popcount())\nThis compliant solution uses a popcount() function, which counts the number of bits set on any unsigned integer, allowing this code to determine the precision of any integer type, signed or unsigned.\n#include <stddef.h>\n#include <stdint.h>\n \n/* Returns the number of set bits */\nsize_t popcount(uintmax_t num) {\n  size_t precision = 0;\n  while (num != 0) {\n    if (num % 2 == 1) {\n      precision++;\n    }\n    num >>= 1;\n  }\n  return precision;\n}\n#define PRECISION(umax_value) popcount(umax_value) \nImplementations can replace the PRECISION() macro with a type-generic macro that returns an integer constant expression that is the precision of the specified type for that implementation. This return value can then be used anywhere an integer constant expression can be used, such as in a static assertion. (See DCL03-C. Use a static assertion to test the value of a constant expression.) The following type generic macro, for example, might be used for a specific implementation targeting the IA-32 architecture:\n#define PRECISION(value)  _Generic(value, \\\n  unsigned char : 8, \\\n  unsigned short: 16, \\\n  unsigned int : 32, \\\n  unsigned long : 32, \\\n  unsigned long long : 64, \\\n  signed char : 7, \\\n  signed short : 15, \\\n  signed int : 31, \\\n  signed long : 31, \\\n  signed long long : 63)\nThe revised version of the pow2() function uses the PRECISION() macro to determine the precision of the unsigned type:\n#include <stddef.h>\n#include <stdint.h>\n#include <limits.h>\nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)  \nunsigned int pow2(unsigned int exp) {\n  if (exp >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}\nImplementation Details\nSome platforms, such as the Cray Linux Environment (CLE; supported on Cray XT CNL compute nodes), provide a _popcnt instruction that can substitute for the popcount() function.\n#define PRECISION(umax_value) _popcnt(umax_value)\nCompliant Solution (C23)\nThe C23 standard provides various *_WIDTH macros that define the number of width bits for each integer type. This is effectively the size of the type (multiplied by 8) less the number of padding bits. The following compliant solution uses the UINT_WIDTH  type to obtain the width of an un\n#include <limits.h>\n\nunsigned int pow2(unsigned int exp) {\n  if (exp >= UINT_WIDTH) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}\nRisk Assessment\nMistaking an integer's size for its precision can permit invalid precision arguments to operations such as bitwise shifts, resulting in undefined behavior.\n\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT35-C\nLow\nUnlikely\nNo\nNo\nP1\nL3\nAutomated Detection\nTool Version Checker Description\nAstr\u00e9e\n24.04\n\nSupported: Astr\u00e9e reports overflows due to insufficient precision.\nCodeSonar\n9.1p0\nLANG.ARITH.BIGSHIFT\nShift Amount Exceeds Bit Width\nCppcheck Premium\n24.11.0\npremium-cert-int35-c\nHelix QAC\n2025.2\nC0582\nC++3115\n\nParasoft C/C++test\n2024.2\nCERT_C-INT35-a\nUse correct integer precisions when checking the right hand operand of the shift operator\nPolyspace Bug Finder\nR2025b\nCERT C: Rule INT35-C Checks for situations when integer precisions are exceeded (rule fully covered)\n Related Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCWE 2.11 CWE-681, Incorrect Conversion between Numeric Types\n2017-10-30:MITRE:Unspecified Relationship\n2018-10-18:CERT:Partial Overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-190 and INT35-C\nIntersection( INT35-C, CWE-190) = \u00d8\nINT35-C used to map to CWE-190 but has been replaced with a new rule that has no overlap with CWE-190.\nCWE-681 and INT35-C\nIntersection(INT35-C, CWE-681) = due to incorrect use of integer precision, conversion from one data type to another causing data to be omitted or translated in a way that produces unexpected values\nCWE-681 - INT35-C = list2, where list2 =\nconversion from one data type to another causing data to be omitted or translated in a way that produces unexpected values, not involving incorrect use of integer precision\nINT35-C - CWE-681 = list1, where list1 = \nincorrect use of integer precision not related to conversion from one data type to another\nBibliography\n[Dowd 2006] Chapter 6, \"C Language Issues\"\n[C99 Rationale 2003] 6.5.7, \"Bitwise Shift Operators\"",
        "language": "C"
    },
    {
        "rule_id": "INT36-C",
        "rule_title": "Converting a pointer to integer or integer to pointer",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT36-C.+Converting+a+pointer+to+integer+or+integer+to+pointer",
        "content": "Although programmers often use integers and pointers interchangeably in C, pointer-to-integer and integer-to-pointer conversions are implementation-defined. \nConversions between integers and pointers can have undesired consequences depending on the implementation.\nAccording to the C Standard, subclause 6.3.2.3 [ISO/IEC 9899:2024],\nAn integer may be converted to any pointer type. Except as previously specified, the result is implementation-defined, might not be correctly aligned, might not point to an entity of the referenced type, and might be a trap representation.\nAny pointer type may be converted to an integer type. Except as previously specified, the result is implementation-defined. If the result cannot be represented in the integer type, the behavior is undefined. The result need not be in the range of values of any integer type.\nDo not convert an integer type to a pointer type if the resulting pointer is incorrectly aligned, does not point to an entity of the referenced type, or is a trap representation.\nDo not convert a pointer type to an integer type if the result cannot be represented in the integer type. (See undefined behavior 23.)\nThe mapping between pointers and integers must be consistent with the addressing structure of the execution environment. Issues may arise, for example, on architectures that have a segmented memory model.\nNoncompliant Code Example\nThe size of a pointer can be greater than the size of an integer, such as in an implementation where pointers are 64 bits and unsigned integers are 32 bits. This code example is noncompliant on such implementations because the result of converting the 64-bit ptr cannot be represented in the 32-bit integer type:\nvoid f(void) {\n  char *ptr;\n  /* ... */\n  unsigned int number = (unsigned int)ptr;\n  /* ... */\n}\nCompliant Solution\nAny valid pointer to void can be converted to intptr_t or uintptr_t and back with no change in value. (See INT36-EX2.) The C Standard guarantees that a pointer to void may be converted to or from a pointer to any object type and back again and that the result must compare equal to the original pointer. Consequently, converting directly from a char * pointer to a uintptr_t, as in this compliant solution, is allowed on implementations that support the uintptr_t type.\n#include <stdint.h>\n \nvoid f(void) {\n  char *ptr;\n  /* ... */\n  uintptr_t number = (uintptr_t)ptr;  \n  /* ... */\n}\nNoncompliant Code Example\nIn this noncompliant code example, the pointer ptr is converted to an integer value. The high-order 9 bits of the number are used to hold a flag value, and the result is converted back into a pointer. This example is noncompliant on an implementation where pointers are 64 bits and unsigned integers are 32 bits because the result of converting the 64-bit ptr cannot be represented in the 32-bit integer type.\nvoid func(unsigned int flag) {\n  char *ptr;\n  /* ... */\n  unsigned int number = (unsigned int)ptr;\n  number = (number & 0x7fffff) | (flag << 23);\n  ptr = (char *)number;\n}\nA similar scheme was used in early versions of Emacs, limiting its portability and preventing the ability to edit files larger than 8MB.\nCompliant Solution\nThis compliant solution uses a struct to provide storage for both the pointer and the flag value. This solution is portable to machines of different word sizes, both smaller and larger than 32 bits, working even when pointers cannot be represented in any integer type. \nstruct ptrflag {\n  char *pointer;\n  unsigned int flag : 9;\n} ptrflag;\n \nvoid func(unsigned int flag) {\n  char *ptr;\n  /* ... */\n  ptrflag.pointer = ptr;\n  ptrflag.flag = flag;\n}\nNoncompliant Code Example\nIt is sometimes necessary to access memory at a specific location, requiring a literal integer to pointer conversion. In this noncompliant code, a pointer is set directly to an integer constant, where it is unknown whether the result will be as intended:\nunsigned int *g(void) {\n  unsigned int *ptr = 0xdeadbeef;\n  /* ... */\n  return ptr;\n} \nThe result of this assignment is implementation-defined, might not be correctly aligned, might not point to an entity of the referenced type, and might be a trap representation.\nCompliant Solution\nUnfortunately this code cannot be made safe while strictly conforming to ISO C.\nA particular platform (that is, hardware, operating system, compiler, and Standard C library) might guarantee that a memory address is correctly aligned for the pointer type, and actually contains a value for that type. A common practice is to use addresses that are known to point to hardware that provides valid values.\nExceptions\nINT36-C-EX1: The integer value 0 can be converted to a pointer; it becomes the null pointer.\nINT36-C-EX2: Any valid pointer to void can be converted to intptr_t or uintptr_t or their underlying types and back again with no change in value. Use of underlying types instead of intptr_t or uintptr_t is discouraged, however, because it limits portability.\n#include <assert.h>\n#include <stdint.h>\n \nvoid h(void) {\n  intptr_t i = (intptr_t)(void *)&i;\n  uintptr_t j = (uintptr_t)(void *)&j;\n \n  void *ip = (void *)i;\n  void *jp = (void *)j;\n \n  assert(ip == &i);\n  assert(jp == &j);\n}\nINT36-C-EX3: An integer may be converted to a void* and back as long as the pointer is not dereferenced, and the integer is in range (that is, the appropriate range for an intptr_t or uintptr_t).\nThe following POSIX code passes an integer, cast as a void* to a thread, and the thread prints the integer.\n#include <stdio.h>\n#include <pthread.h>\n\n\nvoid *print_int(void *ptr) {\n  intptr_t i = (intptr_t) ptr;\n  printf(\"The number is %jd\\n\", i);\n  return NULL;\n}\n\nint main(void) {\n  pthread_t thr1;\n  intptr_t i = 123;\n  int result;\n\n   if ((result = pthread_create(&thr1, NULL, print_int, (void *)i)) != 0) {\n    /* Handle error */\n  }\n\n  pthread_exit(NULL);\n  return 0;\n}\nRisk Assessment\nConverting from pointer to integer or vice versa results in code that is not portable and may create unexpected pointers to invalid memory locations.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT36-C\nLow\nProbable\nYes\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\npointer-integral-cast\npointer-integral-cast-implicit\nfunction-pointer-integer-cast\nfunction-pointer-integer-cast-implicit\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-INT36 Fully implemented\nClang\n3.9\n-Wint-to-pointer-cast, -Wint-conversion Can detect some instances of this rule, but does not detect all\nCodeSonar\n9.1p0\nLANG.CAST.PC.CONST2PTR\nLANG.CAST.PC.INT\nPARSE.PCLB\nPARSE.PCTSSI\nConversion: integer constant to pointer\nConversion: pointer/integer\nPointer conversion loses bits\nPointer conversion to same size integer\nCompass/ROSE\n\n\nCoverity\n2017.07\nPW.POINTER_CONVERSION_LOSES_BITS Fully implemented\nCppcheck Premium\n24.11.0\npremium-cert-int36-c\nHelix QAC\n2025.2\nC0303, C0305, C0306, C0309, C0324, C0326, C0360, C0361, C0362\nC++3040, C++3041, C++3042, C++3043, C++3044, C++3045, C++3046, C++3047, C++3048\n\nKlocwork\n2025.2\nMISRA.CAST.OBJ_PTR_TO_INT.2012\nLDRA tool suite\n9.7.1\n439 S, 440 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-INT36-b\nA conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'\nPC-lint Plus\n1.4\n4287\nPartially supported: reports casts from pointer types to smaller integer types which lose information\nPolyspace Bug Finder\nR2025b\nCERT C: Rule INT36-C\n\nChecks for unsafe conversion between pointer and integer (rule partially covered)\nPVS-Studio\n7.38\nV527, V528, V542, V566, V601, V647, V1091\nRuleChecker\n24.04\npointer-integral-cast\npointer-integral-cast-implicit\nfunction-pointer-integer-cast\nfunction-pointer-integer-cast-implicit\nFully checked\nSecurity Reviewer - Static Reviewer\n6.02\nCPP_05\nFully implemented\nSonarQube C/C++ Plugin\n3.11\nS1767 Partially implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C INT11-CPP. Take care when converting from pointer to integer or integer to pointer Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Pointer Casting and Pointer Type Changes [HFC] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Converting a pointer to integer or integer to pointer [intptrconv] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-587, Assignment of a Fixed Address to a Pointer 2017-07-07: CERT: Partial overlap\nCWE 2.11 CWE-704 2017-06-14: CERT: Rule subset of CWE\nCWE 2.11 CWE-758 2017-07-07: CERT: Rule subset of CWE\nCWE 3.1 CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer 2018-10-19:CERT:None\nCWE 3.1 CWE-466, Return of Pointer Value Outside of Expected Range 2018-10-19:CERT:None\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-758 and INT36-C\nIndependent( INT34-C, INT36-C, MEM30-C, MSC37-C, FLP32-C, EXP33-C, EXP30-C, ERR34-C, ARR32-C)\nCWE-758 = Union( INT36-C, list) where list =\nUndefined behavior that results from anything other than integer <-> pointer conversion\nCWE-704 and INT36-C\nCWE-704 = Union( INT36-C, list) where list =\nIncorrect (?) typecast that is not between integers and pointers\nCWE-587 and INT36-C\nIntersection( CWE-587, INT36-C) =\nSetting a pointer to an integer value that is ill-defined (trap representation, improperly aligned, mis-typed, etc)\nCWE-587 \u2013 INT36-C =\nSetting a pointer to a valid integer value (eg points to an object of the correct t ype)\nINT36-C \u2013 CWE-587 =\nIllegal pointer-to-integer conversion\nIntersection(INT36-C,CWE-466) =  \u2205  \nIntersection(INT36-C,CWE-466) =  \u2205\nAn example explaining the above two equations follows:\nstatic char x[3];\nchar* foo() {\n  int x_int = (int) x; // x_int = 999 eg\n  return x_int + 5; // returns 1004 , violates CWE 466\n}\n...\nint y_int = foo(); // violates CWE-466\nchar* y = (char*) y_int; //  // well-defined but y may be invalid, violates INT36-C\nchar c = *y; // indeterminate value, out-of-bounds read, violates CWE-119\nBibliography\n[ISO/IEC 9899:2024] 6.3.2.3, \"Pointers\"",
        "language": "C"
    },
    {
        "rule_id": "FIO09-C",
        "rule_title": "Be careful with binary data when transferring data across systems",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO09-C.+Be+careful+with+binary+data+when+transferring+data+across+systems",
        "content": "Portability is a concern when using the fread() and fwrite() functions across multiple, heterogeneous systems. In particular, it is never guaranteed that reading or writing of scalar data types such as integers, let alone aggregate types such as arrays or structures, will preserve the representation or value of the data. Implementations may differ in structure padding, floating-point model, number of bits per byte, endianness, and other attributes that cause binary data formats to be incompatible.\nNoncompliant Code Example\nThis noncompliant code example reads data from a file stream into a data structure:\nstruct myData {\n  char c;\n  long l;\n};\n /* ... */\n FILE *file;\nstruct myData data;\n /* Initialize file */\n if (fread(&data, sizeof(struct myData), 1, file) < sizeof(struct myData)) {\n  /* Handle error */\n}\nHowever, the code makes assumptions about the layout of myData, which may be represented differently on a different platform.\nCompliant Solution\nThe best solution is to use either a text representation or a special library that ensures data integrity:\nstruct myData {\n  char c;\n  long l;\n};\n /* ... */\n FILE *file;\nstruct myData data;\nchar buf[25];\nchar *end_ptr;\n /* Initialize file */\n if (fgets(buf, 1, file) == NULL) {\n  /* Handle error */\n}\n data.c = buf[0];\n if (fgets(buf, sizeof(buf), file) == NULL) {\n  /* Handle Error */\n}\n data.l = strtol(buf, &end_ptr, 10);\n if ((ERANGE == errno)\n || (end_ptr == buf)\n || ('\\n' != *end_ptr && '\\0' != *end_ptr)) {\n    /* Handle Error */\n}\nRisk Assessment\nReading binary data that has a different format than expected may result in unintended program behavior.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO09-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCompass/ROSE\n\n\nCould flag possible violations of this rule by noting any pointer to struct that is passed to fread(), as the noncompliant code example demonstrates\nLDRA tool suite\n9.7.1\n44 S Enhanced Enforcement\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO09-CPP. Be careful with binary data when transferring data across systems\nBibliography\n[Summit 1995] 20.5 on C-FAQ",
        "language": "C"
    },
    {
        "rule_id": "FLP30-C",
        "rule_title": "Do not use floating-point variables as loop counters",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FLP30-C.+Do+not+use+floating-point+variables+as+loop+counters",
        "content": "Because floating-point numbers represent real numbers, it is often mistakenly assumed that they can represent any simple fraction exactly. Floating-point numbers are subject to representational limitations just as integers are, and binary floating-point numbers cannot represent all real numbers exactly, even if they can be represented in a small number of decimal digits.\nIn addition, because floating-point numbers can represent large values, it is often mistakenly assumed that they can represent all significant digits of those values. To gain a large dynamic range, floating-point numbers maintain a fixed number of precision bits (also called the significand) and an exponent, which limit the number of significant digits they can represent.\nDifferent implementations have different precision limitations, and to keep code portable, floating-point variables must not be used as the loop induction variable. See Goldberg's work for an introduction to this topic [Goldberg 1991].\nFor the purpose of this rule, a loop counter is an induction variable that is used as an operand of a comparison expression that is used as the controlling expression of a do, while, or for loop. An induction variable is a variable that gets increased or decreased by a fixed amount on every iteration of a loop [Aho 1986]. Furthermore, the change to the variable must occur directly in the loop body (rather than inside a function executed within the loop).\nNoncompliant Code Example\nIn this noncompliant code example, a floating-point variable is used as a loop counter. The decimal number 0.1 is a repeating fraction in binary and cannot be exactly represented as a binary floating-point number. Depending on the implementation, the loop may iterate 9 or 10 times.\nvoid func(void) {\n  for (float x = 0.1f; x <= 1.0f; x += 0.1f) {\n    /* Loop may iterate 9 or 10 times */\n  }\n}\nFor example, when compiled with GCC or Microsoft Visual Studio 2013 and executed on an x86 processor, the loop is evaluated only nine times.\nCompliant Solution\nIn this compliant solution, the loop counter is an integer from which the floating-point value is derived:\n#include <stddef.h>\n  void func(void) {\n  for (size_t count = 1; count <= 10; ++count) {\n    float x = count / 10.0f;\n    /* Loop iterates exactly 10 times */\n  }\n}\nNoncompliant Code Example\nIn this noncompliant code example, a floating-point loop counter is incremented by an amount that is too small to change its value given its precision:\nvoid func(void) {\n  for (float x = 100000001.0f; x <= 100000010.0f; x += 1.0f) {\n    /* Loop may not terminate */\n  }\n}\nOn many implementations, this produces an infinite loop.\nCompliant Solution\nIn this compliant solution, the loop counter is an integer from which the floating-point value is derived. The variable x is assigned a computed value to reduce compounded rounding errors that are present in the noncompliant code example.\nvoid func(void) {\n  for (size_t count = 1; count <= 10; ++count) {\n    float x = 100000000.0f + (count * 1.0f);\n    /* Loop iterates exactly 10 times */\n  }\n}\nRisk Assessment\nThe use of floating-point variables as loop counters can result in  unexpected behavior .\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFLP30-C\nLow\nProbable\nYes\nYes\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nfor-loop-float Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-FLP30 Fully implemented\nClang\n3.9\ncert-flp30-c Checked by clang-tidy\nCodeSonar\n9.1p0\nLANG.STRUCT.LOOP.FPC Float-typed loop counter\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nMISRA C 2004 Rule 13.4\nMISRA C 2012 Rule 14.1\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-flp30-c\nECLAIR\n1.2\nCC2.FLP30 Fully implemented\nHelix QAC\n2025.2\nC3339, C3340, C3342\nC++4234\n\nKlocwork\n2025.2\nMISRA.FOR.COUNTER.FLT\nLDRA tool suite\n9.7.1\n39 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-FLP30-a\nDo not use floating point variables as loop counters\nPC-lint Plus\n1.4\n9009\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FLP30-C\nChecks for use of float variable as loop counter (rule fully covered)\nPVS-Studio\n7.38\nV1034\nRuleChecker\n24.04\nfor-loop-float Fully checked\nSonarQube C/C++ Plugin\n3.11\nS2193 Fully implemented\nTrustInSoft Analyzer\n1.38\nnon-terminating Exhaustively detects non-terminating statements (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C FLP30-CPP. Do not use floating-point variables as loop counters Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java NUM09-J. Do not use floating-point variables as loop counters Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Floating-Point Arithmetic [PLF] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Directive 1.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 14.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[Aho 1986]\n[Goldberg 1991]\n[Lockheed Martin 05] AV Rule 197",
        "language": "C"
    },
    {
        "rule_id": "FLP32-C",
        "rule_title": "Prevent or detect domain and range errors in math functions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FLP32-C.+Prevent+or+detect+domain+and+range+errors+in+math+functions",
        "content": "The C Standard, 7.12.1 [ISO/IEC 9899:2024], defines three types of errors that relate specifically to math functions in <math.h>.  Paragraph 2 states\nA domain error occurs if an input argument is outside the domain over which the mathematical function is defined.\nParagraph 3 states\nA pole error (also known as a singularity or infinitary) occurs if the mathematical function has an exact infinite result as the finite input argument(s) are approached in the limit.\nParagraph 4 states\na range error occurs if and only if the result overflows or underflows\nAn example of a domain error is the square root of a negative number, such as sqrt(-1.0), which has no meaning in real arithmetic. Contrastingly, 10 raised to the 1-millionth power, pow(10., 1e6), cannot be represented in many floating-point implementations because of the limited range of the type double and consequently constitutes a range error. In both cases, the function will return some value, but the value returned is not the correct result of the computation. An example of a pole error is log(0.0), which results in negative infinity.\nProgrammers can prevent domain and pole errors by carefully bounds-checking the arguments before calling mathematical functions and taking alternative action if the bounds are violated.\nRange errors usually cannot be prevented because they are dependent on the implementation of floating-point numbers as well as on the function being applied. Instead of preventing range errors, programmers should attempt to detect them and take alternative action if a range error occurs.\nThe following table lists the double forms of standard mathematical functions, along with checks that should be performed to ensure a proper input domain, and indicates whether they can also result in range or pole errors, as reported by the C Standard. Both float and long double forms of these functions also exist but are omitted from the table for brevity. If a function has a specific domain over which it is defined, the programmer must check its input values. The programmer must also check for range errors where they might occur. The standard math functions not listed in this table, such as fabs(), have no domain restrictions and cannot result in range or pole errors.\nFunction\nDomain\nRange\nPole \nacos(x)\n-1 <= x && x <= 1\nNo\nNo\nasin(x) -1 <= x && x <= 1 Yes No\natan(x) None Yes No\natan2(y, x)\nNone\nNo\nNo\nacosh(x)\nx >= 1\nYes\nNo\nasinh(x) None Yes No\natanh(x)\n-1 < x && x < 1\nYes\nYes\ncosh(x), sinh(x)\nNone\nYes\nNo\nexp(x), exp2(x), expm1(x)\nNone\nYes\nNo\nldexp(x, exp)\nNone\nYes\nNo\nlog(x), log10(x), log2(x)\nx >= 0\nNo\nYes\nlog1p(x)\nx >= -1\nNo\nYes\nilogb(x)\nx != 0 && !isinf(x) && !isnan(x)\nYes\nNo\nlogb(x) x != 0 Yes  Yes\nscalbn(x, n), scalbln(x, n)\nNone\nYes\nNo\nhypot(x, y)\nNone\nYes\nNo\npow(x,y)\nx > 0 || (x == 0 && y > 0) ||\n(x < 0 && y is an integer)\nYes\nYes\nsqrt(x)\nx >= 0\nNo\nNo\nerf(x) None Yes No\nerfc(x)\nNone\nYes\nNo\nlgamma(x), tgamma(x)\nx != 0 && ! (x < 0 && x is an integer)\nYes\nYes\nlrint(x), lround(x)\nNone\nYes\nNo\nfmod(x, y), remainder(x, y),\nremquo(x, y, quo)\ny != 0\nYes\nNo\nnextafter(x, y),\nnexttoward(x, y)\nNone\nYes\nNo\nfdim(x,y)\nNone\nYes\nNo \nfma(x,y,z)\nNone\nYes\nNo\nDomain and Pole Checking\nThe most reliable way to handle domain and pole errors is to prevent them by checking arguments beforehand, as in the following exemplar:\ndouble safe_sqrt(double x) {\n  if (x < 0) {\n    fprintf(stderr, \"sqrt requires a nonnegative argument\");\n    /* Handle domain / pole error */\n  }\n  return sqrt (x);\n}\nRange Checking\nProgrammers usually cannot prevent range errors, so the most reliable way to handle them is to detect when they have occurred and act accordingly.\nThe exact treatment of error conditions from math functions is tedious. The C Standard, 7.12.1 paragraph 5 [ISO/IEC 9899:2024], defines the following behavior for floating-point overflow:\nA floating result overflows if a finite result value with ordinary accuracy would have magnitude (absolute value) too large for the representation with full precision in the specified type. A result that is exactly an infinity does not overflow. If a floating result overflows and default rounding is in effect, then the function returns the value of the macro HUGE_VAL, HUGE_VALF, or HUGE_VALL according to the return type, with the same sign as the correct value of the function; however, for the types with reduced-precision representations of numbers beyond the overflow threshold, the function may return a representation of the result with less than full precision for the type. If a floating resultoverflowsanddefaultroundingisineffectandtheintegerexpressionmath_errhandling & MATH_ERRNO is nonzero, then the integer expression errno acquires the value ERANGE. If a floating result overflows, and the integer expression math_errhandling & MATH_ERREXCEPT is nonzero, the \"overflow\" floating-point exception is raised (regardless of whether default rounding is in effect).\nIt is preferable not to check for errors by comparing the returned value against HUGE_VAL or 0 for several reasons:\nThese are, in general, valid (albeit unlikely) data values.\nMaking such tests requires detailed knowledge of the various error returns for each math function.\nMultiple results aside from HUGE_VAL and 0 are possible, and programmers must know which are possible in each case.\nDifferent versions of the library have varied in their error-return behavior.\nIt can be unreliable to check for math errors using errno because an implementation might not set errno. For real functions, the programmer determines if the implementation sets errno by checking whether math_errhandling & MATH_ERRNO is nonzero. \nThe C Standard, 7.3.2, paragraph 1 [ISO/IEC 9899:2024],  states:\n an implementation may set errno but is not required to.\nThe obsolete System V Interface Definition (SVID3) [UNIX 1992] provides more control over the treatment of errors in the math library. The programmer can define a function named matherr() that is invoked if errors occur in a math function. This function can print diagnostics, terminate the execution, or specify the desired return value. The matherr() function has not been adopted by C or POSIX, so it is not generally portable.\nThe following error-handing template uses C Standard functions for floating-point errors when the C macro math_errhandling is defined and indicates that they should be used; otherwise, it examines errno:\n#include <math.h>\n#include <fenv.h>\n#include <errno.h>\n \n/* ... */\n/* Use to call a math function and check errors */\n{\n  #pragma STDC FENV_ACCESS ON\n\n  if (math_errhandling & MATH_ERREXCEPT) {\n    feclearexcept(FE_ALL_EXCEPT);\n  }\n  errno = 0;\n\n  /* Call the math function */\n\n  if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n    /* Handle range error */\n  } else if ((math_errhandling & MATH_ERREXCEPT) &&\n             fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                          FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n    /* Handle range error */\n  }\n}\nSee FLP03-C. Detect and handle floating-point errors for more details on how to detect floating-point errors.\nSubnormal Numbers\nA subnormal number is a nonzero number that does not use all of its precision bits [IEEE 754 2006]. These numbers can be used to represent values that are closer to 0 than the smallest normal number (one that uses all of its precision bits). However, the asin(), asinh(), atan(), atanh(), and erf() functions may produce range errors, specifically when passed a subnormal number. When evaluated with a subnormal number, these functions can produce an inexact, subnormal value, which is an underflow error.\nThe C Standard, 7.12.1, paragraph 6 [ISO/IEC 9899:2024], defines the following behavior for floating-point underflow:\nThe result underflows if a nonzero result value with ordinary accuracy would have magnitude (absolute value) less than the minimum normalized number in the type; however a zero result that is specified to be an exact zero does not underflow. Also, a result with ordinary accuracy and the magnitude of the minimum normalized number may underflow.269) If the result underflows, the function returns an implementation-defined value whose magnitude is no greater than the smallest normalized positive number in the specified type; if the integer expression math_errhandling & MATH_ERRNO is nonzero, whether errno acquires the value ERANGE is implementation-defined; if the integer expression math_errhandling & MATH_ERREXCEPT s nonzero, whether the\"underflow\" floating-point exception is raised is implementation-defined. \nImplementations that support floating-point arithmetic but do not support subnormal numbers, such as IBM S/360 hex floating-point or nonconforming IEEE-754 implementations that skip subnormals (or support them by flushing them to zero), can return a range error when calling one of the following families of functions with the following arguments:\nfmod((min+subnorm), min)\nremainder((min+subnorm), min)\nremquo((min+subnorm), min, quo)\nwhere min is the minimum value for the corresponding floating point type and subnorm is a subnormal value.\nIf Annex F is supported and subnormal results are supported, the returned value is exact and a range error cannot occur. The C Standard, F.10.7.1 paragraph 2 [ISO/IEC 9899:2024], specifies the following for the fmod(), remainder(), and remquo() functions:\nWhen subnormal results are supported, the returned value is exact and is independent of the current rounding direction mode.\nAnnex F, subclause F.10.7.2, paragraph 2, and subclause F.10.7.3, paragraph 2, of the C Standard identify when subnormal results are supported.\nNoncompliant Code Example (sqrt())\nThis noncompliant code example determines the square root of x:\n#include <math.h>\n \nvoid func(double x) {\n  double result;\n  result = sqrt(x);\n}\nHowever, this code may produce a domain error if x is negative.\nCompliant Solution (sqrt())\nBecause this function has domain errors but no range errors, bounds checking can be used to prevent domain errors:\n#include <math.h>\n \nvoid func(double x) {\n  double result;\n\n  if (isless(x, 0.0)) {\n    /* Handle domain error */\n  }\n\n  result = sqrt(x);\n}\nNoncompliant Code Example (sinh(), Range Errors)\nThis noncompliant code example determines the hyperbolic sine of x:\n#include <math.h>\n \nvoid func(double x) {\n  double result;\n  result = sinh(x);\n}\nThis code may produce a range error if x has a very large magnitude.\nCompliant Solution (sinh(), Range Errors)\nBecause this function has no domain errors but may have range errors, the programmer must detect a range error and act accordingly:\n#include <math.h>\n#include <fenv.h>\n#include <errno.h>\n \nvoid func(double x) { \n  double result;\n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n\n    result = sinh(x);\n\n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n \n  /* Use result... */\n}\nNoncompliant Code Example (pow())\nThis noncompliant code example raises x to the power of y:\n#include <math.h>\n \nvoid func(double x, double y) {\n  double result;\n  result = pow(x, y);\n}\nThis code may produce a domain error if x is negative and y is not an integer value or if x is 0 and y is 0. A domain error or pole error may occur if x is 0 and y is negative, and a range error may occur if the result cannot be represented as a double.\nCompliant Solution (pow())\nBecause the pow() function can produce domain errors, pole errors, and range errors, the programmer must first check that x and y lie within the proper domain and do not generate a pole error and then detect whether a range error occurs and act accordingly:\n#include <math.h>\n#include <fenv.h>\n#include <errno.h>\n \nvoid func(double x, double y) {\n  double result;\n\n  if (((x == 0.0f) && islessequal(y, 0.0)) || isless(x, 0.0)) {\n    /* Handle domain or pole error */\n  }\n\n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n\n    result = pow(x, y);\n \n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n\n  /* Use result... */\n}\nNoncompliant Code Example (asin(), Subnormal Number)\nThis noncompliant code example determines the inverse sine of x:\n#include <math.h>\n \nvoid func(float x) {\n  float result = asin(x);\n  /* ... */\n}\nCompliant Solution (asin(), Subnormal Number)\nBecause this function has no domain errors but may have range errors, the programmer must detect a range error and act accordingly:\n#include <math.h>\n#include <fenv.h>\n#include <errno.h>\nvoid func(float x) { \n  float result;\n\n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n\n    result = asin(x);\n\n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n\n  /* Use result... */\n}\nRisk Assessment\nFailure to prevent or detect domain and range errors in math functions may cause unexpected results.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFLP32-C\nMedium\nProbable\nYes\nYes\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nstdlib-limits\nPartially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-FLP32 Partially implemented\nCodeSonar\n9.1p0\nMATH.DOMAIN.ATAN\nMATH.DOMAIN.TOOHIGH\nMATH.DOMAIN.TOOLOW\nMATH.DOMAIN\nMATH.RANGE\nMATH.RANGE.GAMMA\nMATH.DOMAIN.LOG\nMATH.RANGE.LOG\nMATH.DOMAIN.FE_INVALID\nMATH.DOMAIN.POW\nMATH.RANGE.COSH.TOOHIGH\nMATH.RANGE.COSH.TOOLOW\nMATH.DOMAIN.SQRT\nArctangent Domain Error\nArgument Too High\nArgument Too Low\nFloating Point Domain Error\nFloating Point Range Error\nGamma on Zero\nLogarithm on Negative Value\nLogarithm on Zero\nRaises FE_INVALID\nUndefined Power of Zero\ncosh on High Number\ncosh on Low Number\nsqrt on Negative Value\nHelix QAC\n2025.2\nC5025\nC++5033\n\nParasoft C/C++test\n2024.2\nCERT_C-FLP32-a\nValidate values passed to library functions\nPC-lint Plus\n1.4\n2423\nPartially supported: reports domain errors for functions with the Semantics *dom_1, *dom_lt0, or *dom_lt1, including standard library math functions\nPolyspace Bug Finder\nR2025b\nCERT-C: Rule FLP32-C Checks for invalid use of standard library floating point routine (rule fully covered)\n\nRuleChecker\n24.04\nstdlib-limits\nPartially checked\nTrustInSoft Analyzer\n1.38\nout-of-range argument Partially verified.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard FLP03-C. Detect and handle floating-point errors Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-682, Incorrect Calculation 2017-07-07: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-391 and FLP32-C\nIntersection( CWE-391, FLP32-C) =\n\nFailure to detect range errors in floating-point calculations\n\nCWE-391 - FLP32-C\n\nFailure to detect errors in functions besides floating-point calculations\n\nFLP32-C \u2013 CWE-391 =\n\nFailure to detect domain errors in floating-point calculations\n\nCWE-682 and FLP32-C\nIndependent( INT34-C, FLP32-C, INT33-C) CWE-682 = Union( FLP32-C, list) where list =\n\nIncorrect calculations that do not involve floating-point range errors\n\nBibliography\n[ISO/IEC 9899:2024]\n7.3.2, \"Conventions\"\n7.12.1, \"Treatment of Error Conditions\"\nF.10.7, \"Remainder Functions\" \n[IEEE 754 2006 ]\n[Plum 1985] Rule 2-2\n[Plum 1989] Topic 2.10, \"conv\u2014Conversions and Overflow\"\n[UNIX 1992] System V Interface Definition (SVID3)",
        "language": "C"
    },
    {
        "rule_id": "FLP34-C",
        "rule_title": "Ensure that floating-point conversions are within range of the new type",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FLP34-C.+Ensure+that+floating-point+conversions+are+within+range+of+the+new+type",
        "content": "If a floating-point value is to be converted to a floating-point value of a smaller range and precision or to an integer type, or if an integer type is to be converted to a floating-point type, the value must be representable in the destination type.\nThe C Standard, 6.3.1.4, paragraph 2 [ISO/IEC 9899:2024], says,\nWhen a finite value of decimal floating type is converted to an integer type other than bool, the fractional part is discarded (i.e. the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the \"invalid\" floating-point exception shall be raised and the result of the conversion is unspecified.\nParagraph 2 of the same subclause says,\nWhen a value of integer type is converted to a standard floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined.\nAnd subclause 6.3.1.5, paragraph 1+2, says,\nWhen a value of real floating type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged.\nWhen a value of real floating type is converted to a standard floating type, if the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined. \nSee undefined behaviors 16 and 17.\nThis rule does not apply to demotions of floating-point types on implementations that support signed infinity, such as IEEE 754, as all values are within range.\nNoncompliant Code Example (float to int)\nThis noncompliant code example leads to undefined behavior 16 if the integral part of f_a cannot be represented as an integer:\nvoid func(float f_a) {\n  int i_a;\n    /* Undefined if the integral part of f_a cannot be represented. */\n  i_a = f_a;\n}\nCompliant Solution (float to int)\nThis compliant solution tests to ensure that the float value will fit within the int variable before performing the assignment.\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n  extern size_t popcount(uintmax_t); /* See INT35-C */\n#define PRECISION(umax_value) popcount(umax_value)\n  void func(float f_a) {\n  int i_a;\n    if (isnan(f_a) ||\n      PRECISION(INT_MAX) < log2f(fabsf(f_a)) ||\n      (f_a != 0.0F && fabsf(f_a) < FLT_MIN)) {\n    /* Handle error */\n  } else {\n    i_a = f_a;\n  }\n}\nNoncompliant Code Example (Narrowing Conversion)\nThis noncompliant code example attempts to perform conversions that may result in truncating values outside the range of the destination types:\nvoid func(double d_a, long double big_d) {\n  double d_b = (float)big_d;\n  float f_a = (float)d_a;\n  float f_b = (float)big_d;\n}\nAs a result of these conversions, it is possible that d_a is outside the range of values that can be represented by a float or that big_d is outside the range of values that can be represented as either a float or a double. If this is the case, the result is undefined behavior 17 on implementations that do not support Annex F, \"IEC 60559 Floating-Point Arithmetic.\"\nCompliant Solution (Narrowing Conversion)\nThis compliant solution checks whether the values to be stored can be represented in the new type:\n#include <float.h>\n#include <math.h>\n  void func(double d_a, long double big_d) {\n  double d_b;\n  float f_a;\n  float f_b;\n   if (d_a != 0.0 &&\n      (isnan(d_a) ||\n       isgreater(fabs(d_a), FLT_MAX) ||\n       isless(fabs(d_a), FLT_MIN))) {\n    /* Handle error */\n  } else {\n    f_a = (float)d_a;\n  }\n  if (big_d != 0.0 &&\n      (isnan(big_d) ||\n       isgreater(fabs(big_d), FLT_MAX) ||\n       isless(fabs(big_d), FLT_MIN))) {\n    /* Handle error */\n  } else {\n    f_b = (float)big_d;\n  }\n  if (big_d != 0.0 &&\n      (isnan(big_d) ||\n       isgreater(fabs(big_d), DBL_MAX) ||\n       isless(fabs(big_d), DBL_MIN))) {\n    /* Handle error */\n  } else {\n    d_b = (double)big_d;\n  } \n}\nRisk Assessment\nConverting a floating-point value to a floating-point value of a smaller range and precision or to an integer type, or converting an integer type to a floating-point type, can result in a value that is not representable in the destination type and is undefined behavior on implementations that do not support Annex F.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFLP34-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported\nAstr\u00e9e reports all potential overflows resulting from floating-point conversions.\nCompass/ROSE\n\n\nCan detect some violations of this rule. However, it does not flag implicit casts, only explicit ones\nCodeSonar\n9.1p0\nLANG.TYPE.IAT\nInappropriate Assignment Type\nCoverity\n2017.07\nMISRA_CAST (needs verification)\nCan detect instances where implicit float conversion is involved: implicitly converting a complex expression with integer type to floating type, implicitly converting a double expression to narrower float type (may lose precision), implicitly converting a complex expression from float to double, implicitly converting from float to double in a function argument, and so on\nCppcheck\n 2.15\nfloatConversionOverflow\nsuspiciousFloatingPointCast\n\nCppcheck Premium\n24.11.0\nfloatConversionOverflow\nsuspiciousFloatingPointCast\n\nHelix QAC\n2025.2\nC4450, C4451, C4452, C4453, C4454, C4462, C4465\nC++3011\n\nKlocwork\n2025.2\nMISRA.CAST.FLOAT.WIDER\nMISRA.CAST.FLOAT.INT\nMISRA.CAST.INT_FLOAT\nMISRA.CONV.FLOAT\n\nLDRA tool suite\n9.7.1\n435 S, 93 S Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-FLP34-a\nCERT_C-FLP34-b\nAvoid implicit conversions from wider to narrower floating type\nAvoid implicit conversions of floating point numbers from wider to narrower floating type\nPC-lint Plus\n1.4\n735, 736,\n915, 922,\n9118, 9227\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FLP34-C\nChecks for float conversion overflow (rule partially covered)\nPVS-Studio\n7.38\nV615, V2003, V2004\nSecurity Reviewer - Static Reviewer\n6.02\nC88 Fully implemented\nTrustInSoft Analyzer\n1.38\nfloat_to_int\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT Oracle Secure Coding Standard for Java NUM12-J. Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Numeric Conversion Errors [FLC] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-681, Incorrect Conversion between Numeric Types 2017-06-29: CERT: Rule subset of CWE\nCWE 2.11 CWE-197 2017-06-14: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-197 and FLP34-C\nIndependent( FLP34-C, INT31-C) FIO34-C = Subset( INT31-C)\nCWE-197 = Union( FLP34-C, INT31-C)\nCWE-195 and FLP34-C\nIntersection( CWE-195, FLP34-C) = \u00d8\nBoth conditions involve type conversion. However, CWE-195 explicitly focuses on conversions between unsigned vs signed types, whereas FLP34-C focuses on floating-point arithmetic.\nCWE-681 and FLP34-C\nCWE-681 = Union( FLP34-C, INT31-C)\nBibliography\n[IEEE 754 2006]\n[ISO/IEC 9899:2024] Subclause 6.3.1.4, \"Real Floating and Integer\"\nSubclause 6.3.1.5, \"Real Floating Types\"",
        "language": "C"
    },
    {
        "rule_id": "FLP36-C",
        "rule_title": "Preserve precision when converting integral values to floating-point type",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FLP36-C.+Preserve+precision+when+converting+integral+values+to+floating-point+type",
        "content": "Narrower arithmetic types can be cast to wider types without any effect on the magnitude of numeric values. However, whereas integer types represent exact values, floating-point types have limited precision. The C Standard, 6.3.1.4 paragraph 3 [ISO/IEC 9899:2024], states\nWhen a value of integer type is converted to a standard floating type, if the value being converted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined. Results of some implicit conversions may be represented in greater range and precision than that required by the new type (see 6.3.1.8 and 6.8.7.5). \nConversion from integral types to floating-point types without sufficient precision can lead to loss of precision (loss of least significant bits). No runtime exception occurs despite the loss.\nNoncompliant Code Example\nIn this noncompliant example, a large value of type long int is converted to a value of type float without ensuring it is representable in the type:\n#include <stdio.h>\n\nint main(void) {\n  long int big = 1234567890L;\n  float approx = big;\n  printf(\"%ld\\n\", (big - (long int)approx));\n  return 0;\n}\nFor most floating-point hardware, the value closest to 1234567890 that is representable in type float is 1234567844; consequently, this program prints the value -46.\nCompliant Solution\nThis compliant solution replaces the type float with a double. Furthermore, it uses an assertion to guarantee that the double type can represent any long int without loss of precision. (See INT35-C. Use correct integer precisions and MSC11-C. Incorporate diagnostic tests using assertions.)\n#include <assert.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n\nextern size_t popcount(uintmax_t); /* See INT35-C */\n#define PRECISION(umax_value) popcount(umax_value) \n\nint main(void) {\n  assert(PRECISION(LONG_MAX) <= DBL_MANT_DIG * log2(FLT_RADIX));\n  long int big = 1234567890L;\n  double approx = big;\n  printf(\"%ld\\n\", (big - (long int)approx));\n  return 0;\n}\nOn the same implementation, this program prints 0, implying that the integer value 1234567890 is representable in type double without change.\nExceptions\nFLP36-C-EX1: Loss of precision can be acceptable when necessary for the proper execution of the program. It is recommended that the conversion be clearly commented as permitting loss of precision.\nRisk Assessment\nConversion from integral types to floating-point types without sufficient precision can lead to loss of precision (loss of least significant bits).\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFLP36-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported: Astr\u00e9e keeps track of all floating point rounding errors and loss of precision and reports code defects resulting from those.\nCodeSonar\n9.1p0\nLANG.TYPE.IAT\nInappropriate Assignment Type\nCoverity\n2017.07\nMISRA C 2004 Rule 10.x (needs investigation)\nNeeds investigation\nCppcheck Premium\n24.11.0\npremium-cert-flp36-c\nHelix QAC\n2025.2\nC1260, C1263, C1298, C1299, C1800, C1802, C1803, C1804, C4117, C4435, C4437, C4445\nC++3011\n\nKlocwork\n2025.2\nPORTING.CAST.FLTPNT\n\nLDRA tool suite\n9.7.1\n435 S Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-FLP36-a\nCERT_C-FLP36-b\nImplicit conversions from integral to floating type which may result in a loss of information shall not be used\nImplicit conversions from integral constant to floating type which may result in a loss of information shall not be used\nPC-lint Plus\n1.4\n915, 922\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT-C: Rule FLP36-C Checks for precision loss in integer to float conversion (rule fully covered)\nPVS-Studio\n7.38\nV674\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard DCL03-C. Use a static assertion to test the value of a constant expression Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java NUM13-J. Avoid loss of precision when converting primitive integers to floating-point Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] Subclause 6.3.1.4, \"Real Floating and Integer\"",
        "language": "C"
    },
    {
        "rule_id": "FLP37-C",
        "rule_title": "Do not use object representations to compare floating-point values",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FLP37-C.+Do+not+use+object+representations+to+compare+floating-point+values",
        "content": "The object representation for floating-point values is implementation defined. However, an implementation that defines the __STDC_IEC_559__ macro shall conform to the IEC 60559 floating-point standard and uses what is frequently referred to as IEEE 754 floating-point arithmetic [ISO/IEC 9899:2024]. The floating-point object representation used by IEC 60559 is one of the most common floating-point object representations in use today.\nAll floating-point object representations use specific bit patterns to encode the value of the floating-point number being represented. However, equivalence of floating-point values is not encoded solely by the bit pattern used to represent the value. For instance, if the floating-point format supports negative zero values (as IEC 60559 does), the values -0.0 and 0.0 are equivalent and will compare as equal, but the bit patterns used in the object representation are not identical. Similarly, if two floating-point values are both (the same) NaN, they will not compare as equal, despite the bit patterns being identical, because they are not equivalent.\nDo not compare floating-point object representations directly, such as by calling memcmp()or its moral equivalents. Instead, the equality operators (== and !=) should be used to determine if two floating-point values are equivalent.\nNoncompliant Code Example\nIn this noncompliant code example, memcmp() is used to compare two structures for equality. However, since the structure contains a floating-point object, this code may not behave as the programmer intended.\n#include <stdbool.h>\n#include <string.h>\n  struct S {\n  int i;\n  float f;\n};\n  bool are_equal(const struct S *s1, const struct S *s2) {\n  if (!s1 && !s2)\n    return true;\n  else if (!s1 || !s2)\n    return false;\n  return 0 == memcmp(s1, s2, sizeof(struct S));\n}\nCompliant Solution\nIn this compliant solution, the structure members are compared individually:\n#include <stdbool.h>\n#include <string.h>\n  struct S {\n  int i;\n  float f;\n};\n  bool are_equal(const struct S *s1, const struct S *s2) {\n  if (!s1 && !s2)\n    return true;\n  else if (!s1 || !s2)\n    return false;\n  return s1->i == s2->i &&\n         s1->f == s2->f;\n}\nRisk Assessment\nUsing the object representation of a floating-point value for comparisons can lead to incorrect equality results, which can lead to unexpected behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFLP37-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nmemcmp-with-float Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-FLP37 Fully implemented\nCppcheck Premium\n24.11.0\npremium-cert-flp37-c\nHelix QAC\n2025.2\nC5026\nC++3118\n\nKlocwork\n2025.2\nMISRA.STDLIB.MEMCMP.PTR_ARG_TYPES\nCERT.MEMCMP.FLOAT_MEMBER\n\nLDRA tool suite\n9.7.1\n618 S Enhanced Enforcement\nParasoft C/C++test\n2024.2\nCERT_C-FLP37-c\nDo not use object representations to compare floating-point values\nPC-lint Plus\n1.4\n2498, 2499\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FLP37-C Checks for memory comparison of floating-point values (rule fully covered)\nPVS-Studio\n7.38\nV1014\nRuleChecker\n24.04\nmemcmp-with-float Partially checked\nTrustInSoft Analyzer\n1.38\n\nExhaustively verified.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2024] Annex F, \"ISO/IEC 60559 floating-point arithmetic\"",
        "language": "C"
    },
    {
        "rule_id": "ARR30-C",
        "rule_title": "Do not form or use out-of-bounds pointers or array subscripts",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ARR30-C.+Do+not+form+or+use+out-of-bounds+pointers+or+array+subscripts",
        "content": "The C Standard identifies the following distinct situations in which undefined behavior (UB) can arise as a result of invalid pointer operations:\nUB\nDescription\nExample Code\n43\nAddition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that does not point into, or just beyond, the same array object.\nForming Out-of-Bounds Pointer, Null Pointer Arithmetic\n44\nAddition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that points just beyond the array object and is used as the operand of a unary * operator that is evaluated.\nDereferencing Past the End Pointer, Using Past the End Index\n46\nAn array subscript is out of range, even if an object is apparently accessible with the given subscript, for example, in the lvalue expression a[1][7] given the declaration int a[4][5]).\nApparently Accessible Out-of-Range Index\n59\nAn attempt is made to access, or generate a pointer to just past, a flexible array member of a structure when the referenced object provides no elements for that array.\nPointer Past Flexible Array Member\nNoncompliant Code Example (Forming Out-of-Bounds Pointer)\nIn this noncompliant code example, the function f() attempts to validate the index before using it as an offset to the statically allocated table of integers. However, the function fails to reject negative index values. When index is less than zero, the behavior of the addition expression in the return statement of the function is undefined behavior 43. On some implementations, the addition alone can trigger a hardware trap. On other implementations, the addition may produce a result that when dereferenced triggers a hardware trap. Other implementations still may produce a dereferenceable pointer that points to an object distinct from table. Using such a pointer to access the object may lead to information exposure or cause the wrong object to be modified.\nenum { TABLESIZE = 100 };\n static int table[TABLESIZE];\n int *f(int index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\nCompliant Solution\nOne compliant solution is to detect and reject invalid values of index if using them in pointer arithmetic would result in an invalid pointer:\nenum { TABLESIZE = 100 };\n static int table[TABLESIZE];\n int *f(int index) {\n  if (index >= 0 && index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\nCompliant Solution\nAnother slightly simpler and potentially more efficient compliant solution is to use an unsigned type to avoid having to check for negative values while still rejecting out-of-bounds positive values of index:\n#include <stddef.h>\n  enum { TABLESIZE = 100 };\n static int table[TABLESIZE];\n int *f(size_t index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\nNoncompliant Code Example (Dereferencing Past-the-End Pointer)\nThis noncompliant code example shows the flawed logic in the Windows Distributed Component Object Model (DCOM) Remote Procedure Call (RPC) interface that was exploited by the W32.Blaster.Worm. The error is that the while loop in the GetMachineName() function (used to extract the host name from a longer string) is not sufficiently bounded. When the character array pointed to by pwszTemp does not contain the backslash character among the first MAX_COMPUTERNAME_LENGTH_FQDN + 1 elements, the final valid iteration of the loop will dereference past the end pointer, resulting in exploitable  undefined behavior 44. In this case, the actual exploit allowed the attacker to inject executable code into a running program. Economic damage from the Blaster worm has been estimated to be at least $525 million [Pethia 2003].\nFor a discussion of this programming error in the Common Weakness Enumeration database, see CWE-119, \"Improper Restriction of Operations within the Bounds of a Memory Buffer,\" and CWE-121, \"Stack-based Buffer Overflow\" [MITRE 2013].\nerror_status_t _RemoteActivation(\n      /* ... */, WCHAR *pwszObjectName, ... ) {\n   *phr = GetServerPath(\n              pwszObjectName, &pwszObjectName);\n    /* ... */\n}\n HRESULT GetServerPath(\n  WCHAR *pwszPath, WCHAR **pwszServerPath ){\n  WCHAR *pwszFinalPath = pwszPath;\n  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];\n  hr = GetMachineName(pwszPath, wszMachineName);\n  *pwszServerPath = pwszFinalPath;\n}\n HRESULT GetMachineName(\n  WCHAR *pwszPath,\n  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])\n{\n  pwszServerName = wszMachineName;\n  LPWSTR pwszTemp = pwszPath + 2;\n  while (*pwszTemp != L'\\\\')\n    *pwszServerName++ = *pwszTemp++;\n  /* ... */\n}\nCompliant Solution\nIn this compliant solution, the while loop in the GetMachineName() function is bounded so that the loop terminates when a backslash character is found, the null-termination character (L'\\0') is discovered, or the end of the buffer is reached. Or, as coded, the while loop continues as long as each character is neither a backslash nor a null character and is not at the end of the buffer. This code does not result in a buffer overflow even if no backslash character is found in wszMachineName.\nHRESULT GetMachineName(\n  wchar_t *pwszPath,\n  wchar_t wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])\n{\n  wchar_t *pwszServerName = wszMachineName;\n  wchar_t *pwszTemp = pwszPath + 2;\n  wchar_t *end_addr\n    = pwszServerName + MAX_COMPUTERNAME_LENGTH_FQDN;\n  while ((*pwszTemp != L'\\\\') &&\n         (*pwszTemp != L'\\0') &&\n         (pwszServerName < end_addr))\n  {\n    *pwszServerName++ = *pwszTemp++;\n  }\n   /* ... */\n}\nThis compliant solution is for illustrative purposes and is not necessarily the solution implemented by Microsoft. This particular solution may not be correct because there is no guarantee that a backslash is found.\nNoncompliant Code Example (Using Past-the-End Index)\nSimilar to the dereferencing-past-the-end-pointer error, the function insert_in_table() in this noncompliant code example uses an otherwise valid index to attempt to store a value in an element just past the end of an array.\nFirst, the function incorrectly validates the index pos against the size of the buffer. When pos is initially equal to size, the function attempts to store value in a memory location just past the end of the buffer.\nSecond, when the index is greater than size, the function modifies size before growing the size of the buffer. If the call to realloc() fails to increase the size of the buffer, the next call to the function with a value of pos equal to or greater than the original value of size will again attempt to store value in a memory location just past the end of the buffer or beyond.\nThird, the function violates INT30-C. Ensure that unsigned integer operations do not wrap, which could lead to wrapping when 1 is added to pos or when size is multiplied by the size of int.\nFor a discussion of this programming error in the Common Weakness Enumeration database, see CWE-122, \"Heap-based Buffer Overflow,\" and CWE-129, \"Improper Validation of Array Index\" [MITRE 2013].\n#include <stdlib.h>\n  static int *table = NULL;\nstatic size_t size = 0;\n int insert_in_table(size_t pos, int value) {\n  if (size < pos) {\n    int *tmp;\n    size = pos + 1;\n    tmp = (int *)realloc(table, sizeof(*table) * size);\n    if (tmp == NULL) {\n      return -1;   /* Failure */\n    }\n    table = tmp;\n  }\n   table[pos] = value;\n  return 0;\n}\nCompliant Solution\nThis compliant solution correctly validates the index pos by using the <= relational operator, ensures the multiplication will not overflow, and avoids modifying size until it has verified that the call to realloc() was successful:\n#include <stdint.h>\n#include <stdlib.h>\n  static int *table = NULL;\nstatic size_t size = 0;\n int insert_in_table(size_t pos, int value) {\n  if (size <= pos) {\n    if ((SIZE_MAX - 1 < pos) ||\n        ((pos + 1) > SIZE_MAX / sizeof(*table))) {\n      return -1;\n    }\n      int *tmp = (int *)realloc(table, sizeof(*table) * (pos + 1));\n    if (tmp == NULL) {\n      return -1;\n    }\n    /* Modify size only after realloc() succeeds */\n    size  = pos + 1;\n    table = tmp;\n  }\n   table[pos] = value;\n  return 0;\n}\nNoncompliant Code Example (Apparently Accessible Out-of-Range Index)\nThis noncompliant code example declares matrix to consist of 7 rows and 5 columns in row-major order. The function init_matrix iterates over all 35 elements in an attempt to initialize each to the value given by the function argument x. However, because multidimensional arrays are declared in C in row-major order, the function iterates over the elements in column-major order, and when the value of j reaches the value COLS during the first iteration of the outer loop, the function attempts to access element matrix[0][5]. Because the type of matrix is int[7][5], the j subscript is out of range, and the access has undefined behavior 46.\n#include <stddef.h>\n#define COLS 5\n#define ROWS 7\nstatic int matrix[ROWS][COLS];\n void init_matrix(int x) {\n  for (size_t i = 0; i < COLS; i++) {\n    for (size_t j = 0; j < ROWS; j++) {\n      matrix[i][j] = x;\n    }\n  }\n}\nCompliant Solution\nThis compliant solution avoids using out-of-range indices by initializing matrix elements in the same row-major order as multidimensional objects are declared in C:\n#include <stddef.h>\n#define COLS 5\n#define ROWS 7\nstatic int matrix[ROWS][COLS];\n void init_matrix(int x) {\n  for (size_t i = 0; i < ROWS; i++) {\n    for (size_t j = 0; j < COLS; j++) {\n      matrix[i][j] = x;\n    }\n  }\n}\nNoncompliant Code Example (Pointer Past Flexible Array Member)\nIn this noncompliant code example, the function find() attempts to iterate over the elements of the flexible array member buf, starting with the second element. However, because function g() does not allocate any storage for the member, the expression first++ in find() attempts to form a pointer just past the end of buf when there are no elements. This attempt is undefined behavior 59. (See MSC21-C. Use robust loop termination conditions for more information.)\n#include <stdlib.h>\n  struct S {\n  size_t len;\n  char buf[];  /* Flexible array member */\n};\n const char *find(const struct S *s, int c) {\n  const char *first = s->buf;\n  const char *last  = s->buf + s->len;\n   while (first++ != last) { /* Undefined behavior */\n    if (*first == c) {\n      return first;\n    }\n  }\n  return NULL;\n}\n  void g(void) {\n  struct S *s = (struct S *)malloc(sizeof(struct S));\n  if (s == NULL) {\n    /* Handle error */\n  }\n  s->len = 0;\n  find(s, 'a');\n}\nCompliant Solution\nThis compliant solution avoids incrementing the pointer unless a value past the pointer's current value is known to exist:\n#include <stdlib.h>\n  struct S {\n  size_t len;\n  char buf[];  /* Flexible array member */\n};\n const char *find(const struct S *s, int c) {\n  const char *first = s->buf;\n  const char *last  = s->buf + s->len;\n   while (first != last) { /* Avoid incrementing here */\n    if (*++first == c) {\n      return first;\n    }\n  }\n  return NULL;\n}\n  void g(void) {\n  struct S *s = (struct S *)malloc(sizeof(struct S));\n  if (s == NULL) {\n    /* Handle error */\n  }\n  s->len = 0;\n  find(s, 'a');\n}\nNoncompliant Code Example (Null Pointer Arithmetic)\nThis noncompliant code example is similar to an Adobe Flash Player vulnerability that was first exploited in 2008. This code allocates a block of memory and initializes it with some data. The data does not belong at the beginning of the block, which is left uninitialized. Instead, it is placed offset bytes within the block. The function ensures that the data fits within the allocated block. \n#include <string.h>\n#include <stdlib.h>\n char *init_block(size_t block_size, size_t offset,\n                 char *data, size_t data_size) {\n  char *buffer = malloc(block_size);\n  if (data_size > block_size || block_size - data_size < offset) {\n    /* Data won't fit in buffer, handle error */\n  }\n  memcpy(buffer + offset, data, data_size);\n  return buffer;\n}\nThis function fails to check if the allocation succeeds, which is a violation of ERR33-C. Detect and handle standard library errors. If the allocation fails, then malloc() returns a null pointer. The null pointer is added to offset and passed as the destination argument to memcpy(). Because a null pointer does not point to a valid object, the result of the pointer arithmetic is undefined behavior 43.\nAn attacker who can supply the arguments to this function can exploit it to execute arbitrary code. This can be accomplished by providing an overly large value for block_size, which causes malloc() to fail and return a null pointer. The offset argument will then serve as the destination address to the call to memcpy(). The attacker can specify the data and data_size arguments to provide the address and length of the address, respectively, that the attacker wishes to write into the memory referenced by offset. The overall result is that the call to memcpy() can be exploited by an attacker to overwrite an arbitrary memory location with an attacker-supplied address, typically resulting in arbitrary code execution.\nCompliant Solution  (Null Pointer Arithmetic)\nThis compliant solution ensures that the call to malloc() succeeds:\n#include <string.h>\n#include <stdlib.h>\n char *init_block(size_t block_size, size_t offset,\n                 char *data, size_t data_size) {\n  char *buffer = malloc(block_size);\n  if (NULL == buffer) {\n    /* Handle error */\n  }\n  if (data_size > block_size || block_size - data_size < offset) {\n    /* Data won't fit in buffer, handle error */\n  }\n  memcpy(buffer + offset, data, data_size);\n  return buffer;\n}\nRisk Assessment\nWriting to out-of-range pointers or array subscripts can result in a buffer overflow and the execution of arbitrary code with the permissions of the vulnerable process. Reading from out-of-range pointers or array subscripts can result in unintended information disclosure.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nARR30-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\narray-index-range\narray-index-range-constant\nnull-dereferencing\npointered-deallocation\nreturn-reference-local\nPartially checked\nCan detect all accesses to invalid pointers as well as array index out-of-bounds accesses and prove their absence.\nThis rule is only partially checked as invalid but unused pointers may not be reported.\nAxivion Bauhaus Suite\n7.2.0\nCertC-ARR30\nCan detect out-of-bound access to array / buffer\nCodeSonar\n9.1p0\nLANG.MEM.BO\nLANG.MEM.BU\nLANG.MEM.TBA\nLANG.MEM.TO\nLANG.MEM.TU\nLANG.STRUCT.PARITH\nLANG.STRUCT.PBB\nLANG.STRUCT.PPE\nBADFUNC.BO.*\nBuffer overrun\nBuffer underrun\nTainted buffer access\nType overrun\nType underrun\nPointer Arithmetic\nPointer before beginning of object\nPointer past end of object\nA collection of warning classes that report uses of library functions prone to internal buffer overflows.\nCompass/ROSE\n\nCould be configured to catch violations of this rule. The way to catch the noncompliant code example is to first hunt for example code that follows this pattern:\n   for (LPWSTR pwszTemp = pwszPath + 2; *pwszTemp != L'\\\\';\n   *pwszTemp++;)\nIn particular, the iteration variable is a pointer, it gets incremented, and the loop condition does not set an upper bound on the pointer. Once this case is handled, ROSE can handle cases like the real noncompliant code example, which is effectively the same semantics, just different syntax\nCoverity\n2017.07\nOVERRUN\nNEGATIVE_RETURNS\nARRAY_VS_SINGLETON\nBUFFER_SIZE\nCan detect the access of memory past the end of a memory buffer/array\nCan detect when the loop bound may become negative\nCan detect the out-of-bound read/write to array allocated statically or dynamically\nCan detect buffer overflows\nCppcheck\n 2.15\narrayIndexOutOfBounds, outOfBounds, negativeIndex, arrayIndexThenCheck, arrayIndexOutOfBoundsCond,  possibleBufferAccessOutOfBounds\n\nCppcheck Premium\n24.11.0\narrayIndexOutOfBounds, outOfBounds, negativeIndex, arrayIndexThenCheck, arrayIndexOutOfBoundsCond,  possibleBufferAccessOutOfBounds\npremium-cert-arr30-c\n\nHelix QAC\n2025.2\nC2840\nDF2820, DF2821, DF2822, DF2823, DF2840, DF2841, DF2842, DF2843, DF2930, DF2931, DF2932, DF2933, DF2935, DF2936, DF2937, DF2938, DF2950, DF2951, DF2952, DF2953\n\nKlocwork\n2025.2\nABV.ANY_SIZE_ARRAY\nABV.GENERAL\nABV.GENERAL.MULTIDIMENSION\nABV.NON_ARRAY\nABV.STACK\nABV.TAINTED\nABV.UNICODE.BOUND_MAP\nABV.UNICODE.FAILED_MAP\nABV.UNICODE.NNTS_MAP\nABV.UNICODE.SELF_MAP\nABV.UNKNOWN_SIZE\nNNTS.MIGHT\nNNTS.MUST\nNNTS.TAINTED\nNPD.FUNC.CALL.MIGHT\nSV.TAINTED.INDEX_ACCESS\nSV.TAINTED.LOOP_BOUND\n\nLDRA tool suite\n 9.7.1\n45 D, 47 S, 476 S, 489 S, 64 X, 66 X, 68 X, 69 X, 70 X, 71 X, 79 X\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-ARR30-a\nAvoid accessing arrays out of bounds\nParasoft Insure++\n\nRuntime analysis\nPC-lint Plus\n1.4\n413, 415, 416, 613, 661, 662, 676\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ARR30-C\nChecks for:\nArray access out of bounds\nPointer access out of bounds\nArray access with tainted index\nUse of tainted pointer\nPointer dereference with tainted offset\nRule partially covered.\nPVS-Studio\n7.38\nV512, V557, V582, V594, V643, V645, V694\nRuleChecker\n24.04\narray-index-range-constant\nreturn-reference-local Partially checked\nSecurity Reviewer - Static Reviewer\n6.02\narrayIndexOutOfBoundsCond\nassignmentInAssert\nautoVariables\nautovarInvalidDeallocation\nC01\nC02\nC03\nC04\nC05\nC06\nC07\nC08\nC08\nC09\nC10\nC49\nFully Implemented\nTrustInSoft Analyzer\n1.38\nindex_in_address\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nCVE-2008-1517 results from a violation of this rule. Before Mac OSX version 10.5.7, the XNU kernel accessed an array at an unverified user-input index, allowing an attacker to execute arbitrary code by passing an index greater than the length of the array and therefore accessing outside memory [xorl 2009].\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TR 24772:2013 Arithmetic Wrap-Around Error [FIF] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Unchecked Array Indexing [XYZ] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Forming or using out-of-bounds pointers or array subscripts [invptr] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer 2017-05-18: CERT: Rule subset of CWE\nCWE 2.11 CWE-123, Write-what-where Condition 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-125, Out-of-bounds Read 2017-05-18: CERT: Partial overlap\nMISRA C:2012 Rule 18.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-119 and ARR30-C\nIndependent( ARR30-C, ARR38-C, ARR32-C, INT30-C, INT31-C, EXP39-C, EXP33-C, FIO37-C)\nSTR31-C = Subset( Union( ARR30-C, ARR38-C))\nSTR32-C = Subset( ARR38-C)\nCWE-119 = Union( ARR30-C, ARR38-C)\nIntersection( ARR30-C, ARR38-C) = \u00d8\nCWE-394 and ARR30-C\nIntersection( ARR30-C, CWE-394) = \u00d8\nCWE-394 deals with potentially-invalid function return values. Which may be used as an (invalid) array index, but validating the return value is a separate operation.\nCWE-125 and ARR30-C\nIndependent( ARR30-C, ARR38-C, EXP39-C, INT30-C)\nSTR31-C = Subset( Union( ARR30-C, ARR38-C))\nSTR32-C = Subset( ARR38-C)\nCWE-125 = Subset( CWE-119) = Union( ARR30-C, ARR38-C)\nIntersection( ARR30-C, CWE-125) =\nReading from an out-of-bounds array index, or off the end of an array\nARR30-C \u2013 CWE-125 =\nWriting to an out-of-bounds array index, or off the end of an array\nCWE-125 \u2013 ARR30-C =\nReading beyond a non-array buffer\nUsing a library function to achieve an out-of-bounds read.\nCWE-123 and ARR30-C\nIndependent(ARR30-C, ARR38-C)\nSTR31-C = Subset( Union( ARR30-C, ARR38-C))\nSTR32-C = Subset( ARR38-C)\nIntersection( CWE-123, ARR30-C) =\nWrite of arbitrary value to arbitrary (probably invalid) array index\nARR30-C \u2013 CWE-123 =\nRead of value from arbitrary (probably invalid) array index\nConstruction of invalid index (pointer arithmetic)\nCWE-123 \u2013 ARR30-C =\nArbitrary writes that do not involve directly constructing an invalid array index\nCWE-129 and ARR30-C\nIndependent( ARR30-C, ARR32-C, INT31-C, INT32-C)\nARR30-C = Union( CWE-129, list), where list =\nDereferencing an out-of-bounds array index, where index is a trusted value\nForming an out-of-bounds array index, without dereferencing it, whether or not index is a trusted value. (This excludes the array\u2019s TOOFAR index, which is one past the final element; this behavior is well-defined in C11.)\nCWE-120 and ARR30-C\nSee CWE-120 and MEM35-C\nCWE-122 and ARR30-C\nIntersection( ARR30-C, CWE-122) = \u00d8\nCWE-122 specifically addresses buffer overflows on the heap operations, which occur in the context of string-copying. ARR30 specifically addresses improper creation or references of array indices. Which might happen as part of a heap buffer overflow, but is on a lower programming level.\nCWE-20 and ARR30-C\nSee CWE-20 and ERR34-C\nCWE-687 and ARR30-C\nIntersection( CWE-687, ARR30-C) = \u00d8\nARR30-C is about invalid array indices which are created through pointer arithmetic, and dereferenced through an operator (* or []). Neither involve function calls, thus CWE-687 does not apply.\nCWE-786 and ARR30-C\nARR30-C = Union( CWE-786, list) where list =\nAccess of memory location after end of buffer\nConstruction of invalid arry reference (pointer). This does not include an out-of-bounds array index (an integer).\nCWE-789 and ARR30-C\nIntersection( CWE-789, ARR30-C) = \u00d8\nCWE-789 is about allocating memory, not array subscripting\nBibliography\n[Finlay 2003]\n[Microsoft 2003]\n[Pethia 2003]\n[Seacord 2013b] Chapter 1, \"Running with Scissors\"\n[Viega 2005] Section 5.2.13, \"Unchecked Array Indexing\"\n[xorl 2009 ] \"CVE-2008-1517: Apple Mac OS X (XNU) Missing Array Index Validation\"",
        "language": "C"
    },
    {
        "rule_id": "ARR32-C",
        "rule_title": "Ensure size arguments for variable length arrays are in a valid range",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ARR32-C.+Ensure+size+arguments+for+variable+length+arrays+are+in+a+valid+range",
        "content": "Variable length arrays (VLAs), a conditionally supported language feature, are essentially the same as traditional C arrays except that they are declared with a size that is not a constant integer expression and can be declared only at block scope or function prototype scope and no linkage. When supported, a variable length array can be declared\n{ /* Block scope */\n  char vla[size];\n}\nwhere the integer expression size and the declaration of vla are both evaluated at runtime. If the size argument supplied to a variable length array is not a positive integer value, the behavior is undefined. (See undefined behavior 72.)  Additionally, if the magnitude of the argument is excessive, the program may behave in an unexpected way. An attacker may be able to leverage this behavior to overwrite critical program data [Griffiths 2006]. The programmer must ensure that size arguments to variable length arrays, especially those derived from untrusted data, are in a valid range.\nBecause variable length arrays are a conditionally supported feature of C11, their use in portable code should be guarded by testing the value of the macro __STDC_NO_VLA__. Implementations that do not support variable length arrays indicate it by setting __STDC_NO_VLA__ to the integer constant 1.\nNoncompliant Code Example\nIn this noncompliant code example, a variable length array of size size is declared. The size is declared as size_t in compliance with INT01-C. Use size_t or rsize_t for all integer values representing the size of an object.\n#include <stddef.h>\n\nextern void do_work(int *array, size_t size);\n \nvoid func(size_t size) {\n  int vla[size];\n  do_work(vla, size);\n}\nHowever, the value of size may be zero or excessive, potentially giving rise to a security vulnerability.\nCompliant Solution\nThis compliant solution ensures the size argument used to allocate vla is in a valid range (between 1 and a programmer-defined maximum); otherwise, it uses an algorithm that relies on dynamic memory allocation. The solution also avoids unsigned integer wrapping that, given a sufficiently large value of size, would cause malloc to allocate insufficient storage for the array.\n#include <stdint.h>\n#include <stdlib.h>\n \nenum { MAX_ARRAY = 1024 };\nextern void do_work(int *array, size_t size);\n \nvoid func(size_t size) {\n  if (0 == size || SIZE_MAX / sizeof(int) < size) {\n    /* Handle error */\n    return;\n  }\n  if (size < MAX_ARRAY) {\n    int vla[size];\n    do_work(vla, size);\n  } else {\n    int *array = (int *)malloc(size * sizeof(int));\n    if (array == NULL) {\n      /* Handle error */\n    }\n    do_work(array, size);\n    free(array);\n  }\n}\nNoncompliant Code Example (sizeof)\nThe following noncompliant code example defines A to be a variable length array and then uses the sizeof operator to compute its size at runtime. When the function is called with an argument greater than SIZE_MAX / (N1 * sizeof (int)), the runtime sizeof expression may wrap around, yielding a result that is smaller than the mathematical product N1 * n2 * sizeof (int). The call to malloc(), when successful, will then allocate storage for fewer than n2 elements of the array, causing one or more of the final memset() calls in the for loop to write past the end of that storage.\n#include <stdlib.h>\n#include <string.h>\n \nenum { N1 = 4096 };\n\nvoid *func(size_t n2) {\n  typedef int A[n2][N1];\n\n  A *array = malloc(sizeof(A));\n  if (!array) {\n    /* Handle error */\n    return NULL;\n  }\n\n  for (size_t i = 0; i != n2; ++i) {\n    memset(array[i], 0, N1 * sizeof(int));\n  }\n\n  return array;\n}\nFurthermore, this code also violates ARR39-C. Do not add or subtract a scaled integer to a pointer, where array is a pointer to the two-dimensional array, where it should really be a pointer to the latter dimension instead. This means that the memset() call does out-of-bounds writes on all of its invocations except the first.\nCompliant Solution (sizeof)\nThis compliant solution prevents sizeof wrapping by detecting the condition before it occurs and avoiding the subsequent computation when the condition is detected. The code also uses an additional typedef to fix the type of array so that memset() never writes past the two-dimensional array.\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n \nenum { N1 = 4096 };\n\nvoid *func(size_t n2) {\n  if (n2 > SIZE_MAX / (N1 * sizeof(int))) {\n    /* Prevent sizeof wrapping */\n    return NULL;\n  }\n\n  typedef int A1[N1];\n  typedef A1 A[n2];\n\n  A1 *array = (A1*) malloc(sizeof(A));\n\n  if (!array) {\n    /* Handle error */\n    return NULL;\n  } \n\n  for (size_t i = 0; i != n2; ++i) {\n    memset(array[i], 0, N1 * sizeof(int));\n  }\n  return array;\n}\nImplementation Details\nMicrosoft\nVariable length arrays are not supported by Microsoft compilers.\nRisk Assessment\nFailure to properly specify the size of a variable length array may allow arbitrary code execution or result in stack exhaustion.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nARR32-C\nHigh\nProbable\nNo\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nALLOC.SIZE.IOFLOW\nALLOC.SIZE.MULOFLOW\nMISC.MEM.SIZE.BAD\nInteger Overflow of Allocation Size\nMultiplication Overflow of Allocation Size\nUnreasonable Size Argument\nCoverity\n2017.07\nREVERSE_NEGATIVE Fully implemented\nCppcheck\n 2.15\nnegativeArraySize\n\nCppcheck Premium\n24.11.0\nnegativeArraySize\npremium-cert-arr32-c\n\nHelix QAC\n2025.2\nC1051\nKlocwork\n2025.2\nMISRA.ARRAY.VAR_LENGTH.2012\n\nLDRA tool suite\n 9.7.1\n621 S Enhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-ARR32-a\nEnsure the size of the variable length array is in valid range\nPC-lint Plus\n1.4\n9035\nAssistance provided\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ARR32-C\nChecks for:\nMemory allocation with tainted size\nTainted size of variable length array\nRule fully covered.\nSecurity Reviewer - Static Reviewer\n6.02\nC101\nFully Implemented\nTrustInSoft Analyzer\n1.38\nalloca_bounds Exhaustively verified.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard INT01-C. Use rsize_t or size_t for all integer values representing the size of an object Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Unchecked Array Indexing [XYZ] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Tainted, potentially mutilated, or out-of-domain integer values are used in a restricted sink [taintsink] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-758 2017-06-29: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-129 and ARR32-C\nIntersection( CWE-188, EXP39-C) = \u00d8\nARR32-C addresses specifying the size of a variable-length array (VLA). CWE-129 addresses invalid array indices, not array sizes.\nCWE-758 and ARR32-C\nIndependent( INT34-C, INT36-C, MSC37-C, FLP32-C, EXP33-C, EXP30-C, ERR34-C, ARR32-C)\nCWE-758 = Union( ARR32-C, list) where list =\n\nUndefined behavior that results from anything other than too large a VLA dimension.\n\nCWE-119 and ARR32-C\n\nIntersection( CWE-119, ARR32-C) = \u00d8\n\n\nARR32-C is not about providing a valid buffer but reading/writing outside it. It is about providing an invalid buffer, or one that exhausts the stack.\n\nBibliography\n[Griffiths 2006]",
        "language": "C"
    },
    {
        "rule_id": "ARR36-C",
        "rule_title": "Do not subtract or compare two pointers that do not refer to the same array",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ARR36-C.+Do+not+subtract+or+compare+two+pointers+that+do+not+refer+to+the+same+array",
        "content": "When two pointers are subtracted, both must point to elements of the same array object or just one past the last element of the array object (C Standard, 6.5.7 [ISO/IEC 9899:2024]); the result is the difference of the subscripts of the two array elements. Otherwise, the operation is undefined behavior. (See undefined behavior 45.)\nSimilarly, comparing pointers using the relational operators <, <=, >=, and > gives the positions of the pointers relative to each other. Subtracting or comparing pointers that do not refer to the same array is undefined behavior. (See undefined behavior 45 and undefined behavior 50.)\nComparing pointers using the equality operators == and != has well-defined semantics regardless of whether or not either of the pointers is null, points into the same object, or points one past the last element of an array object or function.\nNoncompliant Code Example\nIn this noncompliant code example, pointer subtraction is used to determine how many free elements are left in the nums array:\n#include <stddef.h>\n \nenum { SIZE = 32 };\n \nvoid func(void) {\n  int nums[SIZE];\n  int end;\n  int *next_num_ptr = nums;\n  size_t free_elements;\n\n  /* Increment next_num_ptr as array fills */\n\n  free_elements = &end - next_num_ptr;\n}\nThis program incorrectly assumes that the nums array is adjacent to the end variable in memory. A compiler is permitted to insert padding bits between these two variables or even reorder them in memory.\nCompliant Solution\nIn this compliant solution, the number of free elements is computed by subtracting next_num_ptr from the address of the pointer past the nums array. While this pointer may not be dereferenced, it may be used in pointer arithmetic.\n#include <stddef.h>\nenum { SIZE = 32 };\n \nvoid func(void) {\n  int nums[SIZE];\n  int *next_num_ptr = nums;\n  size_t free_elements;\n\n  /* Increment next_num_ptr as array fills */\n\n  free_elements = &(nums[SIZE]) - next_num_ptr;\n}\nExceptions\nARR36-C-EX1: Comparing two pointers to distinct members of the same struct object is allowed. Pointers to structure members declared later in the structure compare greater-than pointers to members declared earlier in the structure.\nRisk Assessment\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nARR36-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\npointer-subtraction Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-ARR36 Can detect operations on pointers that are unrelated\nCodeSonar\n9.1p0\nLANG.STRUCT.CUP\nLANG.STRUCT.SUP\nComparison of Unrelated Pointers\nSubtraction of Unrelated Pointers\nCoverity\n2017.07\nMISRA C 2004 17.2\nMISRA C 2004 17.3\nMISRA C 2012 18.2\nMISRA C 2012 18.3\nImplemented\nCppcheck\n 2.15\ncomparePointers\nCppcheck Premium\n24.11.0\ncomparePointers\nHelix QAC\n2025.2\nC0487, C0513\nDF2668, DF2669, DF2761, DF2762, DF2763, DF2766, DF2767, DF2768, DF2771, DF2772, DF2773\n\nKlocwork\n2025.2\nMISRA.PTR.ARITH\n\nLDRA tool suite\n9.7.1\n437 S, 438 S\nFully implemented\nParasoft C/C++test 2024.2 CERT_C-ARR36-a\nCERT_C-ARR36-b\nDo not subtract two pointers that do not address elements of the same array\nDo not compare two unrelated pointers\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ARR36-C\nChecks for subtraction or comparison between pointers to different arrays (rule partially covered)\nPVS-Studio\n7.38\nV736, V782\nRuleChecker\n24.04\npointer-subtraction\nPartially checked\nSecurity Reviewer - Static Reviewer\n6.02\nC24\nC107 Fully Implemented\nTrustInSoft Analyzer\n1.38\ndiffering_blocks\nExhaustively verified (see the compliant and the non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C CTR54-CPP. Do not subtract iterators that do not refer to the same container Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Subtracting or comparing two pointers that do not refer to the same array [ptrobj] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-469, Use of Pointer Subtraction to Determine Size\n2017-07-10: CERT: Exact\nCWE 3.11 CWE-469, Use of Pointer Subtraction to Determine Size 2018-10-18:CERT:CWE subset of rule\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-469 and ARR36-C\nCWE-469 = Subset(ARR36-C)\nARR36-C = Union(CWE-469, list) where list =\nPointer comparisons using the relational operators <, <=, >=, and >, where the pointers do not refer to the same array\nBibliography\n[Banahan 2003] Section 5.3, \"Pointers\"\nSection 5.7, \"Expressions Involving Pointers\"\n[ISO/IEC 9899:2024]\n6.5.7, \"Additive Operators\"",
        "language": "C"
    },
    {
        "rule_id": "ARR37-C",
        "rule_title": "Do not add or subtract an integer to a pointer to a non-array object",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ARR37-C.+Do+not+add+or+subtract+an+integer+to+a+pointer+to+a+non-array+object",
        "content": "Pointer arithmetic must be performed only on pointers that reference elements of array objects.\nThe C Standard, 6.5.7 [ISO/IEC 9899:2024], states the following about pointer arithmetic:\nWhen an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integer expression.\nNoncompliant Code Example\nThis noncompliant code example attempts to access structure members using pointer arithmetic. This practice is dangerous because structure members are not guaranteed to be contiguous.\nstruct numbers {\n  short num_a, num_b, num_c;\n};\n int sum_numbers(const struct numbers *numb){\n  int total = 0;\n  const short *numb_ptr;\n   for (numb_ptr = &numb->num_a;\n       numb_ptr <= &numb->num_c;\n       numb_ptr++) {\n    total += *(numb_ptr);\n  }\n   return total;\n}\n int main(void) {\n  struct numbers my_numbers = { 1, 2, 3 };\n  sum_numbers(&my_numbers);\n  return 0;\n}\nCompliant Solution\nIt is possible to use the -> operator to dereference each structure member:\ntotal = numb->num_a + numb->num_b + numb->num_c;\nHowever, this solution results in code that is hard to write and hard to maintain (especially if there are many more structure members), which is exactly what the author of the noncompliant code example was likely trying to avoid.\nCompliant Solution\nA better solution is to define the structure to contain an array member to store the numbers in an array rather than a structure, as in this compliant solution:\n#include <stddef.h>\n struct numbers {\n  short a[3];\n};\n int sum_numbers(const short *numb, size_t dim) {\n  int total = 0;\n  for (size_t i = 0; i < dim; ++i) {\n    total += numb[i];\n  }\n   return total;\n}\n int main(void) {\n  struct numbers my_numbers = { .a[0]= 1, .a[1]= 2, .a[2]= 3};\n  sum_numbers(\n    my_numbers.a,\n    sizeof(my_numbers.a)/sizeof(my_numbers.a[0])\n  );\n  return 0;\n}\nArray elements are guaranteed to be contiguous in memory, so this solution is completely portable.\nExceptions\nARR37-C-EX1: Any non-array object in memory can be considered an array consisting of one element. Adding one to a pointer for such an object yields a pointer one element past the array, and subtracting one from that pointer yields the original pointer. This allows for code such as the following:\n#include <stdlib.h>\n#include <string.h>\n  struct s {\n  char *c_str;\n  /* Other members */\n};\n  struct s *create_s(const char *c_str) {\n  struct s *ret;\n  size_t len = strlen(c_str) + 1;\n      ret = (struct s *)malloc(sizeof(struct s) + len);\n  if (ret != NULL) {\n    ret->c_str = (char *)(ret + 1);\n    memcpy(ret + 1, c_str, len);\n  }\n  return ret;\n}\nA more general and safer solution to this problem is to use a flexible array member that guarantees the array that follows the structure is properly aligned by inserting padding, if necessary, between it and the member that immediately precedes it.\nRisk Assessment\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nARR37-C\nMedium\nProbable\nYes\nNo\nP8\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported indirectly via MISRA C:2004 Rule 17.4.\nAxivion Bauhaus Suite\n7.2.0\nCertC-ARR37 Fully implemented\nCodeSonar\n9.1p0\nLANG.MEM.BO\nLANG.MEM.BU\nLANG.STRUCT.PARITH\nLANG.STRUCT.PBB\nLANG.STRUCT.PPE\nLANG.MEM.TBA\nLANG.MEM.TO\nLANG.MEM.TU\nBuffer Overrun\nBuffer Underrun\nPointer Arithmetic\nPointer Before Beginning of Object\nPointer Past End of Object\nTainted Buffer Access\nType Overrun\nType Underrun\nCompass/ROSE\n\n\nCoverity\n2017.07\nARRAY_VS_SINGLETON Implemented\nCppcheck Premium\n24.11.0\npremium-cert-arr37-c\nHelix QAC\n2025.2\nDF2930, DF2931, DF2932, DF2933\nC++3705, C++3706, C++3707\n\nKlocwork\n2025.2\nCERT.ARR.PTR.ARITH\n\nLDRA tool suite\n 9.7.1\n567 S Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-ARR37-a\nPointer arithmetic shall not be applied to pointers that address variables of non-array type\nPC-lint Plus\n1.4\n2662\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ARR37-C Checks for invalid assumptions about memory organization (rule partially covered)\n\nRuleChecker\n24.04\n\nSupported indirectly via MISRA C:2004 Rule 17.4.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nBibliography\n[Banahan 2003] Section 5.3, \"Pointers\"\nSection 5.7, \"Expressions Involving Pointers\"\n[ISO/IEC 9899:2024] 6.5.7, \"Additive Operators\"\n[VU#162289]",
        "language": "C"
    },
    {
        "rule_id": "ARR38-C",
        "rule_title": "Guarantee that library functions do not form invalid pointers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ARR38-C.+Guarantee+that+library+functions+do+not+form+invalid+pointers",
        "content": "C library functions that make changes to arrays or objects take at least two arguments: a pointer to the array or object and an integer indicating the number of elements or bytes to be manipulated. For the purposes of this rule, the element count of a pointer is the size of the object to which it points, expressed by the number of elements that are valid to access. Supplying arguments to such a function might cause the function to form a pointer that does not point into or just past the end of the object, resulting in undefined behavior.\nAnnex J of the C Standard [ISO/IEC 9899:2024] states that it is undefined behavior if the \"pointer passed to a library function array parameter does not have a value such that all address computations and object accesses are valid.\" (See undefined behavior 108.)\nIn the following code,\nint arr[5];\nint *p = arr;\n unsigned char *p2 = (unsigned char *)arr;\nunsigned char *p3 = arr + 2;\nvoid *p4 = arr;\nthe element count of the pointer p is sizeof(arr) / sizeof(arr[0]), that is, 5. The element count of the pointer p2 is sizeof(arr), that is, 20, on implementations where sizeof(int) == 4. The element count of the pointer p3 is 12 on implementations where sizeof(int) == 4, because p3 points two elements past the start of the array arr.  The element count of p4 is treated as though it were unsigned char * instead of void *, so it is the same as p2.\nPointer + Integer\nThe following standard library functions take a pointer argument and a size argument, with the constraint that the pointer must point to a valid memory object of at least the number of elements indicated by the size argument.\nfgets() fgetws() mbstowcs()1  wcstombs()1\nmbrtoc16()2  mbrtoc32()2 mbsrtowcs()1 wcsrtombs()1\nmbtowc()2  mbrtowc()2 mblen() mbrlen()\nmemchr() wmemchr() memset() wmemset()\nstrftime() wcsftime() strxfrm()1 wcsxfrm()1\nstrncat()2  wcsncat()2 snprintf() vsnprintf()\nswprintf() vswprintf() setvbuf() tmpnam_s()\nsnprintf_s() sprintf_s()  vsnprintf_s() vsprintf_s()\ngets_s()  getenv_s() wctomb_s() mbstowcs_s()3\nwcstombs_s()3 memcpy_s()3 memmove_s()3 strncpy_s()3\nstrncat_s()3 strtok_s()2 strerror_s() strnlen_s()\nasctime_s() ctime_s() snwprintf_s() swprintf_s()\nvsnwprintf_s() vswprintf_s() wcsncpy_s()3 wmemcpy_s()3\nwmemmove_s()3 wcsncat_s()3 wcstok_s()2 wcsnlen_s()\nwcrtomb_s() mbsrtowcs_s()3 wcsrtombs_s()3 memset_s()4\n1 Takes two pointers and an integer, but the integer specifies the element count only of the output buffer, not of the input buffer.\n2 Takes two pointers and an integer, but the integer specifies the element count only of the input buffer, not of the output buffer.\n3 Takes two pointers and two integers; each integer corresponds to the element count of one of the pointers.\n4 Takes a pointer and two size-related integers; the first size-related integer parameter specifies the number of bytes available in the buffer; the second size-related integer parameter specifies the number of bytes to write within the buffer.\nFor calls that take a pointer and an integer size, the given size should not be greater than the element count of the pointer.\n Noncompliant Code Example (Element Count)\nIn this noncompliant code example, the incorrect element count is used in a call to wmemcpy(). The sizeof operator returns the size expressed in bytes, but wmemcpy() uses an element count based on wchar_t *.\n#include <string.h>\n#include <wchar.h>\n  static const char str[] = \"Hello world\";\nstatic const wchar_t w_str[] = L\"Hello world\";\nvoid func(void) {\n  char buffer[32];\n  wchar_t w_buffer[32];\n  memcpy(buffer, str, sizeof(str)); /* Compliant */\n  wmemcpy(w_buffer, w_str, sizeof(w_str)); /* Noncompliant */\n}\nCompliant Solution (Element Count)\nWhen using functions that operate on pointed-to regions, programmers must always express the integer size in terms of the element count expected by the function. For example, memcpy() expects the element count expressed in terms of void *, but wmemcpy() expects the element count expressed in terms of wchar_t *.  Instead of the sizeof operator, functions that return the number of elements in the string are called, which matches the expected element count for the copy functions. In the case of this compliant solution, where the argument is an array A of type T, the expression sizeof(A) / sizeof(T), or equivalently sizeof(A) / sizeof(*A), can be used to compute the number of elements in the array.\n#include <string.h>\n#include <wchar.h>\n  static const char str[] = \"Hello world\";\nstatic const wchar_t w_str[] = L\"Hello world\";\nvoid func(void) {\n  char buffer[32];\n  wchar_t w_buffer[32];\n  memcpy(buffer, str, strlen(str) + 1);\n  wmemcpy(w_buffer, w_str, wcslen(w_str) + 1);\n} \nNoncompliant Code Example (Pointer + Integer)\nThis noncompliant code example assigns a value greater than the number of bytes of available memory to n, which is then passed to memset():\n#include <stdlib.h>\n#include <string.h>\n  void f1(size_t nchars) {\n  char *p = (char *)malloc(nchars);\n  /* ... */\n  const size_t n = nchars + 1;\n  /* ... */\n  memset(p, 0, n);\n}\nCompliant Solution (Pointer + Integer)\nThis compliant solution ensures that the value of n is not greater than the number of bytes of the dynamic memory pointed to by the pointer p:\n#include <stdlib.h>\n#include <string.h>\n  void f1(size_t nchars) {\n  char *p = (char *)malloc(nchars);\n  /* ...  */\n  const size_t n = nchars;\n  /* ...  */\n  memset(p, 0, n);\n}\nNoncompliant Code Example (Pointer + Integer)\nIn this noncompliant code example, the element count of the array a is ARR_SIZE elements. Because memset() expects a byte count, the size of the array is scaled incorrectly by sizeof(int) instead of sizeof(long), which can form an invalid pointer on architectures where sizeof(int) != sizeof(long).\n#include <string.h>\n  void f2(void) {\n  const size_t ARR_SIZE = 4;\n  long a[ARR_SIZE];\n  const size_t n = sizeof(int) * ARR_SIZE;\n  void *p = a;\n   memset(p, 0, n);\n}\nCompliant Solution (Pointer + Integer)\nIn this compliant solution, the element count required by memset() is properly calculated without resorting to scaling:\n#include <string.h>\n  void f2(void) {\n  const size_t ARR_SIZE = 4;\n  long a[ARR_SIZE];\n  const size_t n = sizeof(a);\n  void *p = a;\n   memset(p, 0, n);\n}\nTwo Pointers + One Integer\nThe following standard library functions take two pointer arguments and a size argument, with the constraint that both pointers must point to valid memory objects of at least the number of elements indicated by the size argument. \nmemcpy() wmemcpy() memmove() wmemmove()\nstrncpy() wcsncpy() memcmp() wmemcmp()\nstrncmp() wcsncmp() strcpy_s() wcscpy_s()\nstrcat_s() wcscat_s()\n\nFor calls that take two pointers and an integer size, the given size should not be greater than the element count of either pointer.\nNoncompliant Code Example (Two Pointers + One Integer)\nIn this noncompliant code example, the value of n is incorrectly computed, allowing a read past the end of the object referenced by q:\n#include <string.h>\n void f4() {\n  char p[40];\n  const char *q = \"Too short\";\n  size_t n = sizeof(p);\n  memcpy(p, q, n);\n}\nCompliant Solution (Two Pointers + One Integer)\nThis compliant solution ensures that n is equal to the size of the character array:\n#include <string.h>\n void f4() {\n  char p[40];\n  const char *q = \"Too short\";\n  size_t n = sizeof(p) < strlen(q) + 1 ? sizeof(p) : strlen(q) + 1;\n  memcpy(p, q, n);\n}\nOne Pointer + Two Integers\nThe following standard library functions take a pointer argument and two size arguments, with the constraint that the pointer must point to a valid memory object containing at least as many bytes as the product of the two size arguments.\nbsearch() bsearch_s() qsort() qsort_s()\nfread() fwrite()  \nFor calls that take a pointer and two integers, one integer represents the number of bytes required for an individual object, and a second integer represents the number of elements in the array. The resulting product of the two integers should not be greater than the element count of the pointer were it expressed as an unsigned char *.  \nNoncompliant Code Example (One Pointer + Two Integers)\nThis noncompliant code example allocates a variable number of objects of type struct obj. The function checks that num_objs is small enough to prevent wrapping, in compliance with INT30-C. Ensure that unsigned integer operations do not wrap. The size of struct obj is assumed to be 16 bytes to account for padding to achieve the assumed alignment of long long. However, the padding typically depends on the target architecture, so this object size may be incorrect, resulting in an incorrect element count.\n#include <stdint.h>\n#include <stdio.h>\n  struct obj {\n  char c;\n  long long i;\n};\n  void func(FILE *f, struct obj *objs, size_t num_objs) {\n  const size_t obj_size = 16;\n  if (num_objs > (SIZE_MAX / obj_size) ||\n      num_objs != fwrite(objs, obj_size, num_objs, f)) {\n    /* Handle error */\n  }\n}\nCompliant Solution (One Pointer + Two Integers)\nThis compliant solution uses the sizeof operator to correctly provide the object size and num_objs to provide the element count:\n#include <stdint.h>\n#include <stdio.h>\n  struct obj {\n  char c;\n  long long i;\n};\n  void func(FILE *f, struct obj *objs, size_t num_objs) {\n  const size_t obj_size = sizeof *objs;\n  if (num_objs > (SIZE_MAX / obj_size) ||\n      num_objs != fwrite(objs, obj_size, num_objs, f)) {\n    /* Handle error */\n  }\n}\nNoncompliant Code Example (One Pointer + Two Integers)\nIn this noncompliant code example, the function f() calls fread() to read nitems of type wchar_t, each size bytes in size, into an array of BUFFER_SIZE elements, wbuf. However, the expression used to compute the value of nitems fails to account for the fact that, unlike the size of char, the size of wchar_t may be greater than 1. Consequently, fread() could attempt to form pointers past the end of wbuf and use them to assign values to nonexistent elements of the array. Such an attempt is undefined behavior. (See undefined behavior 109.)  A likely consequence of this undefined behavior is a buffer overflow. For a discussion of this programming error in the Common Weakness Enumeration database, see CWE-121, \"Stack-based Buffer Overflow,\" and CWE-805, \"Buffer Access with Incorrect Length Value.\"\n#include <stddef.h>\n#include <stdio.h>\n void f(FILE *file) {\n  enum { BUFFER_SIZE = 1024 };\n  wchar_t wbuf[BUFFER_SIZE];\n   const size_t size = sizeof(*wbuf);\n  const size_t nitems = sizeof(wbuf);\n   size_t nread = fread(wbuf, size, nitems, file);\n  /* ... */\n}\nCompliant Solution (One Pointer + Two Integers)\nThis compliant solution correctly computes the maximum number of items for fread() to read from the file:\n#include <stddef.h>\n#include <stdio.h>\n  void f(FILE *file) {\n  enum { BUFFER_SIZE = 1024 };\n  wchar_t wbuf[BUFFER_SIZE];\n   const size_t size = sizeof(*wbuf);\n  const size_t nitems = sizeof(wbuf) / size;\n   size_t nread = fread(wbuf, size, nitems, file);\n  /* ... */\n}\nNoncompliant Code Example (Heartbleed)\nCERT vulnerability 720951 describes a vulnerability in OpenSSL versions 1.0.1 through 1.0.1f, popularly known as \"Heartbleed.\" This vulnerability allows an attacker to steal information that under normal conditions would be protected by Secure Socket Layer/Transport Layer Security (SSL/TLS) encryption.\nDespite the seriousness of the vulnerability, Heartbleed is the result of a common programming error and an apparent lack of awareness of secure coding principles. Following is the vulnerable code:\nint dtls1_process_heartbeat(SSL *s) {        \n  unsigned char *p = &s->s3->rrec.data[0], *pl;\n  unsigned short hbtype;\n  unsigned int payload;\n  unsigned int padding = 16; /* Use minimum padding */\n    /* Read type and payload length first */\n  hbtype = *p++;\n  n2s(p, payload);\n  pl = p;\n    /* ... More code ... */\n    if (hbtype == TLS1_HB_REQUEST) {\n    unsigned char *buffer, *bp;\n    int r;\n      /*\n     * Allocate memory for the response; size is 1 byte\n     * message type, plus 2 bytes payload length, plus\n     * payload, plus padding.\n     */\n    buffer = OPENSSL_malloc(1 + 2 + payload + padding);\n    bp = buffer;\n      /* Enter response type, length, and copy payload */\n    *bp++ = TLS1_HB_RESPONSE;\n    s2n(payload, bp);\n    memcpy(bp, pl, payload);\n      /* ... More code ... */\n  }\n  /* ... More code ... */\n}\n\nThis code processes a \"heartbeat\" packet from a client. As specified in RFC 6520, when the program receives a heartbeat packet, it must echo the packet's data back to the client. In addition to the data, the packet contains a length field that conventionally indicates the number of bytes in the packet data, but there is nothing to prevent a malicious packet from lying about its data length.\nThe p pointer, along with payload and p1, contains data from a packet. The code allocates a buffer sufficient to contain payload bytes, with some overhead, then copies payload bytes starting at p1 into this buffer and sends it to the client. Notably absent from this code are any checks that the payload integer variable extracted from the heartbeat packet corresponds to the size of the packet data. Because the client can specify an arbitrary value of payload, an attacker can cause the server to read and return the contents of memory beyond the end of the packet data, which violates INT04-C. Enforce limits on integer values originating from tainted sources. The resulting call to memcpy() can then copy the contents of memory past the end of the packet data and the packet itself, potentially exposing sensitive data to the attacker. This call to memcpy() violates ARR38-C. Guarantee that library functions do not form invalid pointers. A version of ARR38-C also appears in ISO/IEC TS 17961:2013, \"Forming invalid pointers by library functions [libptr].\" This rule would require a conforming analyzer to diagnose the Heartbleed vulnerability.\n\nCompliant Solution (Heartbleed)\nOpenSSL version 1.0.1g contains the following patch, which guarantees that payload is within a valid range. The range is limited by the size of the input record.\nint dtls1_process_heartbeat(SSL *s) {        \n  unsigned char *p = &s->s3->rrec.data[0], *pl;\n  unsigned short hbtype;\n  unsigned int payload;\n  unsigned int padding = 16; /* Use minimum padding */\n    /* ... More code ... */\n    /* Read type and payload length first */\n  if (1 + 2 + 16 > s->s3->rrec.length)\n    return 0; /* Silently discard */\n  hbtype = *p++;\n  n2s(p, payload);\n  if (1 + 2 + payload + 16 > s->s3->rrec.length)\n    return 0; /* Silently discard per RFC 6520 */\n  pl = p;\n    /* ... More code ... */\n    if (hbtype == TLS1_HB_REQUEST) {\n    unsigned char *buffer, *bp;\n    int r;\n      /*\n     * Allocate memory for the response; size is 1 byte\n     * message type, plus 2 bytes payload length, plus\n     * payload, plus padding.\n     */\n    buffer = OPENSSL_malloc(1 + 2 + payload + padding);\n    bp = buffer;\n    /* Enter response type, length, and copy payload */\n    *bp++ = TLS1_HB_RESPONSE;\n    s2n(payload, bp);\n    memcpy(bp, pl, payload);\n    /* ... More code ... */\n  }\n  /* ... More code ... */\n}\nRisk Assessment\nDepending on the library function called, an attacker may be able to use a heap or stack overflow vulnerability to run arbitrary code.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nARR38-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\narray_out_of_bounds\nSupported\nAstr\u00e9e reports all out-of-bound accesses within library analysis stubs. The user may provide additional stubs for arbitrary (library) functions.\nCodeSonar\n9.1p0\nLANG.MEM.BO\nLANG.MEM.BU\nBuffer overrun\nBuffer underrun\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nBUFFER_SIZE\nBAD_SIZEOF\nBAD_ALLOC_STRLEN\nBAD_ALLOC_ARITHMETIC\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-arr38-c\nFortify SCA\n5.0\n\nCan detect violations of this rule with CERT C Rule Pack\nHelix QAC\n2025.2\nC2840\nDF2840, DF2841, DF2842, DF2843, DF2845, DF2846, DF2847, DF2848, DF2935, DF2936, DF2937, DF2938, DF4880, DF4881, DF4882, DF4883\n\nKlocwork\n2025.2\nABV.GENERAL\nABV.GENERAL.MULTIDIMENSION\n\nLDRA tool suite\n9.7.1\n64 X, 66 X, 68 X, 69 X, 70 X, 71 X, 79 X\nPartially Implmented\nParasoft C/C++test 2024.2\nCERT_C-ARR38-a\nCERT_C-ARR38-b\nCERT_C-ARR38-c\nCERT_C-ARR38-d\nAvoid overflow when reading from a buffer\nAvoid overflow when writing to a buffer\nAvoid buffer overflow due to defining incorrect format limits\nAvoid overflow due to reading a not zero terminated string\nParasoft Insure++\n\nRuntime analysis\nPC-lint Plus\n1.4\n419, 420\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ARR38-C\nChecks for:\nMismatch between data length and size\nInvalid use of standard library memory routine\nPossible misuse of sizeof\nBuffer overflow from incorrect string format specifier\nInvalid use of standard library string routine\nDestination buffer overflow in string manipulation\nDestination buffer underflow in string manipulation\nRule partially covered.\nSecurity Reviewer - Static Reviewer\n6.02\nC109\nFully Implemented\nSplint\n3.1.1\n\n\nTrustInSoft Analyzer\n1.38\nout of bounds read Partially verified.\nRelated Vulnerabilities\nCVE-2016-2208 results from a violation of this rule. The attacker can supply a value used to determine how much data is copied into a buffer via memcpy(), resulting in a buffer overlow of attacker-controlled data.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nC Secure Coding Standard API00-C. Functions should validate their parameters Prior to 2018-01-12: CERT: Unspecified Relationship\nC Secure Coding Standard ARR01-C. Do not apply the sizeof operator to a pointer when taking the size of an array Prior to 2018-01-12: CERT: Unspecified Relationship\nC Secure Coding Standard INT30-C. Ensure that unsigned integer operations do not wrap Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Forming invalid pointers by library functions [libptr] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Buffer Boundary Violation (Buffer Overflow) [HCB] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Unchecked Array Copying [XYW] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer 2017-05-18: CERT: Rule subset of CWE\nCWE 2.11 CWE-121, Stack-based Buffer Overflow 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-123, Write-what-where Condition 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-125, Out-of-bounds Read 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-805, Buffer Access with Incorrect Length Value 2017-05-18: CERT: Partial overlap\nCWE 3.1 CWE-129, Improper Validation of Array Index\n2017-10-30:MITRE:Unspecified Relationship\n2018-10-18:CERT:Partial Overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-121 and ARR38-C\nIntersection( CWE-121, ARR38-C) =\nStack buffer overflow from passing invalid arguments to library function\nCWE-121 \u2013 ARR38-C =\nStack buffer overflows from direct out-of-bounds write\nARR38-C \u2013 CWE-121 =\nOut-of-bounds read from passing invalid arguments to library function\nBuffer overflow on heap or data segment from passing invalid arguments to library function\nCWE-119 and ARR38-C\nSee CWE-119 and ARR30-C\nCWE-125 and ARR38-C\nIndependent( ARR30-C, ARR38-C, EXP39-C, INT30-C)\nSTR31-C = Subset( Union( ARR30-C, ARR38-C))\nSTR32-C = Subset( ARR38-C)\nIntersection( ARR38-C, CWE-125) =\nReading from an out-of-bounds array index or off the end of an array via standard library function\nARR38-C \u2013 CWE-125 =\nWriting to an out-of-bounds array index or off the end of an array via standard library function\nCWE-125 \u2013 ARR38-C =\nReading beyond a non-array buffer\nReading beyond an array directly (using pointer arithmetic, or [] notation)\nCWE-805 and ARR38-C\nIntersection( CWE-805, ARR38-C) =\nBuffer access with incorrect length via passing invalid arguments to library function\nCWE-805 \u2013 ARR38-C =\nBuffer access with incorrect length directly (such as a loop construct)\nARR38-C \u2013 CWE-805 =\nOut-of-bounds read or write that does not involve incorrect length (could use incorrect offset instead), that uses library function\nCWE-123 and ARR38-C\nIndependent(ARR30-C, ARR38-C)\nSTR31-C = Subset( Union( ARR30-C, ARR38-C))\nSTR32-C = Subset( ARR38-C)\nCWE-123 includes any operation that allows an attacker to write an arbitrary value to an arbitrary memory location. This could be accomplished via overwriting a pointer with data that refers to the address to write, then when the program writes to a pointed-to value, supplying a malicious value. Vulnerable pointer values can be corrupted by:\nStack return address\nBuffer overflow on the heap (which typically overwrites back/next pointer values)\nWrite to untrusted array index (if it is also invalid)\nFormat string exploit\nOverwriting a C++ object with virtual functions (because it has a virtual pointer)\nOthers?\nIntersection( CWE-123, ARR38-C) =\nBuffer overflow via passing invalid arguments to library function\nARR38-C \u2013 CWE-123 =\nBuffer overflow to \u201charmless\u201d memory from passing invalid arguments to library function\nOut-of-bounds read from passing invalid arguments to library function\nCWE-123 \u2013 ARR38-C =\nArbitrary writes that do not involve standard C library functions\nCWE-129 and ARR38-C\nARR38-C - CWE-129 = making library functions create invalid pointers without using untrusted data.\nE.g. : char[3] array;\nstrcpy(array, \"123456\");\nCWE-129 - ARR38-C = not validating an integer used as an array index or in pointer arithmetic\nE.g.: void foo(int i) {\n  char array[3];\n  array[i];\n}\nIntersection(ARR38-C, CWE-129) = making library functions create invalid pointers using untrusted data.\neg: void foo(int i) {\n  char src[3], dest[3];\n  memcpy(dest, src, i);\n}\nBibliography\n[Cassidy 2014] Existential Type Crisis : Diagnosis of the OpenSSL Heartbleed Bug\n[IETF: RFC 6520]\n[ISO/IEC TS 17961:2013]\n[VU#720951]",
        "language": "C"
    },
    {
        "rule_id": "ARR39-C",
        "rule_title": "Do not add or subtract a scaled integer to a pointer",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ARR39-C.+Do+not+add+or+subtract+a+scaled+integer+to+a+pointer",
        "content": "Pointer arithmetic is appropriate only when the pointer argument refers to an array (see ARR37-C. Do not add or subtract an integer to a pointer to a non-array object), including an array of bytes. When performing pointer arithmetic, the size of the value to add to or subtract from a pointer is automatically scaled to the size of the type of the referenced array object. Adding or subtracting a scaled integer value to or from a pointer is invalid because it may yield a pointer that does not point to an element within or one past the end of the array. (See ARR30-C. Do not form or use out-of-bounds pointers or array subscripts.)\nAdding a pointer to an array of a type other than character to the result of the sizeof operator or offsetof macro, which returns a size and an offset, respectively, violates this rule. However, adding an array pointer to the number of array elements, for example, by using the arr[sizeof(arr)/sizeof(arr[0])]) idiom, is allowed provided that arr refers to an array and not a pointer.\nNoncompliant Code Example\nIn this noncompliant code example, sizeof(buf) is added to the array buf. This example is noncompliant because sizeof(buf) is scaled by int and then scaled again when added to buf.\nenum { INTBUFSIZE = 80 };\n extern int getdata(void);\nint buf[INTBUFSIZE];\n  void func(void) {\n  int *buf_ptr = buf;\n   while (buf_ptr < (buf + sizeof(buf))) {\n    *buf_ptr++ = getdata();\n  }\n}\nCompliant Solution\nThis compliant solution uses an unscaled integer to obtain a pointer to the end of the array:\nenum { INTBUFSIZE = 80 };\n extern int getdata(void);\nint buf[INTBUFSIZE];\n void func(void) {\n  int *buf_ptr = buf;\n   while (buf_ptr < (buf + INTBUFSIZE)) {\n    *buf_ptr++ = getdata();\n  }\n}\nNoncompliant Code Example\nIn this noncompliant code example, skip is added to the pointer s. However, skip represents the byte offset of ull_b in struct big. When added to s, skip is scaled by the size of struct big.\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n  struct big {\n  unsigned long long ull_a;\n  unsigned long long ull_b;\n  unsigned long long ull_c;\n  int si_e;\n  int si_f;\n};\n void func(void) {\n  size_t skip = offsetof(struct big, ull_b);\n  struct big *s = (struct big *)malloc(sizeof(struct big));\n  if (s == NULL) {\n    /* Handle malloc() error */\n  }\n   memset(s + skip, 0, sizeof(struct big) - skip);\n  /* ... */\n  free(s);\n  s = NULL;\n}\nCompliant Solution\nThis compliant solution uses an unsigned char * to calculate the offset instead of using a struct big *, which would result in scaled arithmetic:\n#include <string.h>\n#include <stdlib.h>\n#include <stddef.h>\n  struct big {\n  unsigned long long ull_a;\n  unsigned long long ull_b;\n  unsigned long long ull_c;\n  int si_d;\n  int si_e;\n};\n void func(void) {\n  size_t skip = offsetof(struct big, ull_b);\n  unsigned char *ptr = (unsigned char *)malloc(\n    sizeof(struct big)\n  );\n  if (ptr == NULL) {\n     /* Handle malloc() error */\n  }\n   memset(ptr + skip, 0, sizeof(struct big) - skip);\n  /* ... */\n  free(ptr);\n  ptr = NULL;\n}\nNoncompliant Code Example\nIn this noncompliant code example, wcslen(error_msg) * sizeof(wchar_t) bytes are scaled by the size of wchar_t when added to error_msg:\n#include <wchar.h>\n#include <stdio.h>\n  enum { WCHAR_BUF = 128 };\n  void func(void) {\n  wchar_t error_msg[WCHAR_BUF];\n   wcscpy(error_msg, L\"Error: \");\n  fgetws(error_msg + wcslen(error_msg) * sizeof(wchar_t),\n         WCHAR_BUF - 7, stdin);\n  /* ... */\n}\nCompliant Solution\nThis compliant solution does not scale the length of the string; wcslen() returns the number of characters and the addition to error_msg is scaled:\n#include <wchar.h>\n#include <stdio.h>\n enum { WCHAR_BUF = 128 };\nconst wchar_t ERROR_PREFIX[7] = L\"Error: \";\n void func(void) {\n  const size_t prefix_len = wcslen(ERROR_PREFIX);\n  wchar_t error_msg[WCHAR_BUF];\n   wcscpy(error_msg, ERROR_PREFIX);\n  fgetws(error_msg + prefix_len,\n        WCHAR_BUF - prefix_len, stdin);\n  /* ... */\n}\nRisk Assessment\nFailure to understand and properly use pointer arithmetic can allow an attacker to execute arbitrary code.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nARR39-C\nHigh\nProbable\nNo\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nscaled-pointer-arithmetic\nPartially checked\nBesides direct rule violations, Astr\u00e9e reports all (resulting) out-of-bound array accesses.\nAxivion Bauhaus Suite\n7.2.0\nCertC-ARR39 Fully implemented\nCodeSonar\n9.1p0\nLANG.MEM.BO\nLANG.MEM.BU\nLANG.MEM.TBA\nLANG.MEM.TO\nLANG.MEM.TU\nLANG.STRUCT.PARITH\nLANG.STRUCT.PBB\nLANG.STRUCT.PPE\nBuffer overrun\nBuffer underrun\nTainted buffer access\nType overrun\nType underrun\nPointer Arithmetic\nPointer before beginning of object\nPointer past end of object\nCoverity\n2017.07\nBAD_SIZEOF\n  Partially implemented\nCppcheck Premium\n24.11.0\npremium-cert-arr39-c\nHelix QAC\n2025.2\nDF4955, DF4956, DF4957\n\nKlocwork\n2025.2\nCERT.ARR.PTR.ARITH\n\nLDRA tool suite\n 9.7.1\n47 S, 489 S, 567 S,\n64 X, 66 X, 68 X,\n69 X, 70 X, 71 X Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-ARR39-a\nCERT_C-ARR39-b\nCERT_C-ARR39-c\nAvoid accessing arrays out of bounds\nPointer arithmetic should not be used\nDo not add or subtract a scaled integer to a pointer\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ARR39-C\nChecks for incorrect pointer scaling (rule fully covered).\nRuleChecker\n24.04\nscaled-pointer-arithmetic\nPartially checked\nTrustInSoft Analyzer\n1.38\nindex_in_address\nExhaustively detects undefined behavior (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard ARR30-C. Do not form or use out-of-bounds pointers or array subscripts Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard ARR37-C. Do not add or subtract an integer to a pointer to a non-array object Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Pointer Casting and Pointer Type Changes [HFC] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Pointer Arithmetic [RVG] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 18.1 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 18.2 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 18.3 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 18.4 (advisory) Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-468, Incorrect Pointer Scaling 2017-07-07: CERT: Exact\nBibliography\n[Dowd 2006] Chapter 6, \"C Language Issues\"\n[Murenin 07]",
        "language": "C"
    },
    {
        "rule_id": "MEM33-C",
        "rule_title": "Allocate and copy structures containing a flexible array member dynamically",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MEM33-C.++Allocate+and+copy+structures+containing+a+flexible+array+member+dynamically",
        "content": "The C Standard, 6.7.3.2, paragraph 20 [ISO/IEC 9899:2024], says\nAs a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. In most situations, the \ufb02exible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply.\nThe following is an example of a structure that contains a flexible array member:\nstruct flex_array_struct {\n  int num;\n  int data[];\n};\nThis definition means that when computing the size of such a structure, only the first member, num, is considered. Unless the appropriate size of the flexible array member has been explicitly added when allocating storage for an object of the struct, the result of accessing the member data of a variable of nonpointer type struct flex_array_struct is undefined. DCL38-C. Use the correct syntax when declaring a flexible array member describes the correct way to declare a struct with a flexible array member.\nTo avoid the potential for undefined behavior 59, structures that contain a flexible array member should always be allocated dynamically. Flexible array structures must\nHave dynamic storage duration (be allocated via malloc() or another dynamic allocation function)\nBe dynamically copied using memcpy() or a similar function and not by assignment\nWhen used as an argument to a function, be passed by pointer and not copied by value\nNoncompliant Code Example (Storage Duration)\nThis noncompliant code example uses automatic storage for a structure containing a flexible array member:\n#include <stddef.h>\n  struct flex_array_struct {\n  size_t num;\n  int data[];\n};\n  void func(void) {\n  struct flex_array_struct flex_struct;\n  size_t array_size = 4;\n   /* Initialize structure */\n  flex_struct.num = array_size;\n   for (size_t i = 0; i < array_size; ++i) {\n    flex_struct.data[i] = 0;\n  }\n}\nBecause the memory for flex_struct is reserved on the stack, no space is reserved for the data member. Accessing the data member is undefined behavior 59.\nCompliant Solution (Storage Duration)\nThis compliant solution dynamically allocates storage for flex_array_struct:\n#include <stdlib.h>\n  struct flex_array_struct {\n  size_t num;\n  int data[];\n};\n  void func(void) {\n  struct flex_array_struct *flex_struct;\n  size_t array_size = 4;\n   /* Dynamically allocate memory for the struct */\n  flex_struct = (struct flex_array_struct *)malloc(\n    sizeof(struct flex_array_struct)\n    + sizeof(int) * array_size);\n  if (flex_struct == NULL) {\n    /* Handle error */\n  }\n   /* Initialize structure */\n  flex_struct->num = array_size;\n   for (size_t i = 0; i < array_size; ++i) {\n    flex_struct->data[i] = 0;\n  }\n}\nNoncompliant Code Example (Copying)\nThis noncompliant code example attempts to copy an instance of a structure containing a flexible array member (struct flex_array_struct) by assignment:\n#include <stddef.h>\n  struct flex_array_struct {\n  size_t num;\n  int data[];\n};\n  void func(struct flex_array_struct *struct_a,\n          struct flex_array_struct *struct_b) {\n  *struct_b = *struct_a;\n}\nWhen the structure is copied, the size of the flexible array member is not considered, and only the first member of the structure, num, is copied, leaving the array contents untouched.\nCompliant Solution (Copying)\nThis compliant solution uses memcpy() to properly copy the content of struct_a into struct_b:\n#include <string.h>\n  struct flex_array_struct {\n  size_t num;\n  int data[];\n};\n  void func(struct flex_array_struct *struct_a,\n          struct flex_array_struct *struct_b) {\n  if (struct_a->num > struct_b->num) {\n    /* Insufficient space; handle error */\n    return;\n  }\n  memcpy(struct_b, struct_a,\n         sizeof(struct flex_array_struct) + (sizeof(int)\n           * struct_a->num));\n}\nNoncompliant Code Example (Function Arguments)\nIn this noncompliant code example, the flexible array structure is passed by value to a function that prints the array elements:\n#include <stdio.h>\n#include <stdlib.h>\n  struct flex_array_struct {\n  size_t num;\n  int data[];\n};\n  void print_array(struct flex_array_struct struct_p) {\n  puts(\"Array is: \");\n  for (size_t i = 0; i < struct_p.num; ++i) {\n    printf(\"%d \", struct_p.data[i]);\n  }\n  putchar('\\n');\n}\n void func(void) {\n  struct flex_array_struct *struct_p;\n  size_t array_size = 4;\n   /* Space is allocated for the struct */\n  struct_p = (struct flex_array_struct *)malloc(\n    sizeof(struct flex_array_struct)\n    + sizeof(int) * array_size);\n  if (struct_p == NULL) {\n    /* Handle error */\n  }\n  struct_p->num = array_size;\n   for (size_t i = 0; i < array_size; ++i) {\n    struct_p->data[i] = i;\n  }\n  print_array(*struct_p);\n}\nBecause the argument is passed by value, the size of the flexible array member is not considered when the structure is copied, and only the first member of the structure, num, is copied.\nCompliant Solution (Function Arguments)\nIn this compliant solution, the structure is passed by reference and not by value:\n#include <stdio.h>\n#include <stdlib.h>\n  struct flex_array_struct {\n  size_t num;\n  int data[];\n};\n  void print_array(struct flex_array_struct *struct_p) {\n  puts(\"Array is: \");\n  for (size_t i = 0; i < struct_p->num; ++i) {\n    printf(\"%d \", struct_p->data[i]);\n  }\n  putchar('\\n');\n}\n void func(void) {\n  struct flex_array_struct *struct_p;\n  size_t array_size = 4;\n   /* Space is allocated for the struct and initialized... */\n   print_array(struct_p);\n}\nRisk Assessment\nFailure to use structures with flexible array members correctly can result in undefined behavior 59. \nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMEM33-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nflexible-array-member-assignment\nflexible-array-member-declaration Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-MEM33 Fully implemented\nCodeSonar\n9.1p0\nLANG.STRUCT.DECL.FAM\nDeclaration of Flexible Array Member\nCompass/ROSE\n\n\nCan detect all of these\nCppcheck Premium\n24.11.0\npremium-cert-mem33-c\nHelix QAC\n2025.2\nC1061, C1062, C1063, C1064\nKlocwork\n2025.2\nMISRA.INCOMPLETE.STRUCT\nMISRA.MEMB.FLEX_ARRAY.2012\n\nLDRA tool suite\n9.7.1\n649 S, 650 S Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-MEM33-a\nCERT_C-MEM33-b\nAllocate structures containing a flexible array member dynamically\nDo not copy instances of structures containing a flexible array member\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MEM33-C Checks for misuse of structure with flexible array member (rule fully covered)\nRuleChecker\n24.04\nflexible-array-member-assignment\nflexible-array-member-declaration Fully checked\nSecurity Reviewer - Static Reviewer\n6.02\nCPP_028 Fully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard DCL38-C. Use the correct syntax when declaring a flexible array member Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-401 and MEM33-CPP\nThere is no longer a C++ rule for MEM33-CPP. (In fact, all C++ rules from 30-50 are gone, because we changed the numbering system to be 50-99 for C++ rules.)\nBibliography\n[ISO/IEC 9899:2024] Subclause 6.7.3.2, \"Structure and Union Specifiers\"\n[JTC1/SC22/WG14 N791]\nSolving the Struct Hack Problem",
        "language": "C"
    },
    {
        "rule_id": "STR11-C",
        "rule_title": "Do not specify the bound of a character array initialized with a string literal",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/STR11-C.+Do+not+specify+the+bound+of+a+character+array+initialized+with+a+string+literal",
        "content": "The C Standard allows an array variable to be declared both with a bound index and with an initialization literal. The initialization literal also implies an array size in the number of elements specified. For strings, the size specified by a string literal is the number of characters in the literal plus one for the terminating null character.\nIt is common for an array variable to be initialized by a string literal and declared with an explicit bound that matches the number of characters in the string literal. Subclause 6.7.9, paragraph 14, of the C Standard [ISO/IEC 9899:2011], says:\nAn array of character type may be initialized by a character string literal or UTF\u22128 string literal, optionally enclosed in braces. Successive bytes of the string literal (including the terminating null character if there is room or if the array is of unknown size) initialize the elements of the array.\nHowever, if the string is intended to be used as a null-terminated byte string, then the array will have one too few characters to hold the string because it does not account for the terminating null character. Such a sequence of characters has limited utility and has the potential to cause vulnerabilities if a null-terminated byte string is assumed.\nA better approach is to not specify the bound of a string initialized with a string literal because the compiler will automatically allocate sufficient space for the entire string literal, including the terminating null character. This rule is a specific exception to ARR02-C. Explicitly specify array bounds, even if implicitly defined by an initializer.\nNoncompliant Code Example\nThis noncompliant code example initializes an array of characters using a string literal that defines one character more (counting the terminating '\\0') than the array can hold:\nconst char s[3] = \"abc\";\nThe size of the array s is 3, although the size of the string literal is 4. Any subsequent use of the array as a null-terminated byte string can result in a vulnerability, because s is not properly null-terminated. (See STR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string.)\nImplementation Details\nThis code compiles with no warning with Visual Studio 2013 and GCC 4.8.1. It produces a three-character array with no terminating null character, as specified by the standard.\nCompliant Solution\nThis compliant solution does not specify the bound of a character array in the array declaration. If the array bound is omitted, the compiler allocates sufficient storage to store the entire string literal, including the terminating null character.\nconst char s[] = \"abc\";\nThis approach is preferred because the size of the array can always be derived even if the size of the string literal changes.\nExceptions\nSTR11-C-EX1: If the intention is to create a character array and not a null-terminated byte string, initializing to fit exactly without a null byte is allowed but not recommended. The preferred approach to create an array containing just the three characters 'a', 'b', and 'c', for example, is to declare each character literal as a separate element as follows:\nchar s[3] = { 'a', 'b', 'c' }; /* NOT a string */\nAlso, you should make clear in comments or documentation if a character array is, in fact, not a null-terminated byte string.\nSTR11-C-EX2: If the character array must be larger than the string literal it is initialized with, you may explicitly specify an array bounds. This is particularly important if the array's contents might change during program execution.\n#include <string.h>\n \nvoid func(void) {\n  char s[10] = \"abc\";\n  strcpy(&s[3], \"def\");\n}\nRisk Assessment\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSTR11-C\nLow\nProbable\nYes\nYes\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported: Astr\u00e9e can detect subsequent code defects that this rule aims to prevent.\nAxivion Bauhaus Suite\n7.2.0\nCertC-STR11\nCompass/ROSE\n\n\n\nECLAIR\n1.2\nCC2.STR36\nFully implemented\nHelix QAC\n2025.2\nC1312\nLDRA tool suite\n9.7.1\n404 S Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-STR11-a\nDo not specify the bound of a character array initialized with a string literal\nPC-lint Plus\n1.4\n784\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. STR11-C\nChecks for missing null in string array (rec. partially covered)\nSplint\n3.1.1\n\n\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nCERT C Secure Coding Standard ARR02-C. Explicitly specify array bounds, even if implicitly defined by an initializer\nSTR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string\nSEI CERT C++ Coding Standard VOID STR08-CPP. Do not specify the bound of a character array initialized with a string literal\nISO/IEC TR 24772:2013 String Termination [CJM]\nBibliography\n[ECTC 1998] Section A.8, \"Character Array Initialization\"\n[ISO/IEC 9899:2011] Subclause 6.7.9, \"Initialization\"\n[Seacord 2013] Chapter 2, \"Strings\"",
        "language": "C"
    },
    {
        "rule_id": "STR31-C",
        "rule_title": "Guarantee that storage for strings has sufficient space for character data and the null terminator",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator",
        "content": "Copying data to a buffer that is not large enough to hold that data results in a buffer overflow. Buffer overflows occur frequently when manipulating strings [Seacord 2013b]. To prevent such errors, either limit copies through truncation or, preferably, ensure that the destination is of sufficient size to hold the character data to be copied and the null-termination character. (See STR03-C. Do not inadvertently truncate a string.)\nWhen strings live on the heap, this rule is a specific instance of MEM35-C. Allocate sufficient memory for an object. Because strings are represented as arrays of characters, this rule is related to both ARR30-C. Do not form or use out-of-bounds pointers or array subscripts and ARR38-C. Guarantee that library functions do not form invalid pointers.\nNoncompliant Code Example (Off-by-One Error)\nThis noncompliant code example demonstrates an off-by-one error [Dowd 2006]. The loop copies data from src to dest. However, because the loop does not account for the null-termination character, it may be incorrectly written 1 byte past the end of dest.\n#include <stddef.h>\n  void copy(size_t n, char src[n], char dest[n]) {\n   size_t i;\n     for (i = 0; src[i] && (i < n); ++i) {\n     dest[i] = src[i];\n   }\n   dest[i] = '\\0';\n}\nCompliant Solution (Off-by-One Error)\nIn this compliant solution, the loop termination condition is modified to account for the null-termination character that is appended to dest:\n#include <stddef.h>\n  void copy(size_t n, char src[n], char dest[n]) {\n   size_t i;\n     for (i = 0; src[i] && (i < n - 1); ++i) {\n     dest[i] = src[i];\n   }\n   dest[i] = '\\0';\n}\nNoncompliant Code Example (gets())\nThe gets() function, which was deprecated in the C99 Technical Corrigendum 3 and removed from C11, is inherently unsafe and should never be used because it provides no way to control how much data is read into a buffer from stdin. This noncompliant code example assumes that gets() will not read more than BUFFER_SIZE - 1 characters from stdin. This is an invalid assumption, and the resulting operation can result in a buffer overflow.\nThe gets() function reads characters from the stdin into a destination array until end-of-file is encountered or a newline character is read. Any newline character is discarded, and a null character is written immediately after the last character read into the array.\n#include <stdio.h>\n  #define BUFFER_SIZE 1024\n void func(void) {\n  char buf[BUFFER_SIZE];\n  if (gets(buf) == NULL) {\n    /* Handle error */\n  }\n}\nSee also MSC24-C. Do not use deprecated or obsolescent functions.\nCompliant Solution (fgets())\nThe fgets() function reads, at most, one less than the specified number of characters from a stream into an array. This solution is compliant because the number of characters copied from stdin to buf cannot exceed the allocated memory:\n#include <stdio.h>\n#include <string.h>\n  enum { BUFFERSIZE = 32 };\n  void func(void) {\n  char buf[BUFFERSIZE];\n  int ch;\n   if (fgets(buf, sizeof(buf), stdin)) {\n    /* fgets() succeeded; scan for newline character */\n    char *p = strchr(buf, '\\n');\n    if (p) {\n      *p = '\\0';\n    } else {\n      /* Newline not found; flush stdin to end of line */\n      while ((ch = getchar()) != '\\n' && ch != EOF)\n        ;\n      if (ch == EOF && !feof(stdin) && !ferror(stdin)) {\n          /* Character resembles EOF; handle error */\n      }\n    }\n  } else {\n    /* fgets() failed; handle error */\n  }\n}\nThe fgets() function is not a strict replacement for the gets() function because fgets() retains the newline character (if read) and may also return a partial line. It is possible to use fgets() to safely process input lines too long to store in the destination array, but this is not recommended for performance reasons. Consider using one of the following compliant solutions when replacing gets().\nCompliant Solution (getline(), POSIX)\nThe getline() function is similar to the fgets() function but can dynamically allocate memory for the input buffer. If passed a null pointer, getline() dynamically allocates a buffer of sufficient size to hold the input. If passed a pointer to dynamically allocated storage that is too small to hold the contents of the string, the getline() function resizes the buffer, using realloc(), rather than truncating the input. If successful, the getline() function returns the number of characters read, which can be used to determine if the input has any null characters before the newline. The getline() function works only with dynamically allocated buffers. Allocated memory must be explicitly deallocated by the caller to avoid memory leaks. (See MEM31-C. Free dynamically allocated memory when no longer needed.)\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n  void func(void) {\n  int ch;\n  size_t buffer_size = 32;\n  char *buffer = malloc(buffer_size);\n    if (!buffer) {\n    /* Handle error */\n    return;\n  }\n   if ((ssize_t size = getline(&buffer, &buffer_size, stdin))\n        == -1) {\n    /* Handle error */\n  } else {\n    char *p = strchr(buffer, '\\n');\n    if (p) {\n      *p = '\\0';\n    } else {\n      /* Newline not found; flush stdin to end of line */\n      while ((ch = getchar()) != '\\n' && ch != EOF)\n        ;\n      if (ch == EOF && !feof(stdin) && !ferror(stdin)) {\n         /* Character resembles EOF; handle error */\n      }\n    }\n  }\n  free (buffer);\n}\nNote that the getline() function uses an in-band error indicator, in violation of ERR02-C. Avoid in-band error indicators.\nNoncompliant Code Example (getchar())\nReading one character at a time provides more flexibility in controlling behavior, though with additional performance overhead. This noncompliant code example uses the getchar() function to read one character at a time from stdin instead of reading the entire line at once. The stdin stream is read until end-of-file is encountered or a newline character is read. Any newline character is discarded, and a null character is written immediately after the last character read into the array. Similar to the noncompliant code example that invokes gets(), there are no guarantees that this code will not result in a buffer overflow.\n#include <stdio.h>\n  enum { BUFFERSIZE = 32 };\n  void func(void) {\n  char buf[BUFFERSIZE];\n  char *p;\n  int ch;\n  p = buf;\n  while ((ch = getchar()) != '\\n' && ch != EOF) {\n    *p++ = (char)ch;\n  }\n  *p++ = 0;\n  if (ch == EOF) {\n      /* Handle EOF or error */\n  }\n}\nAfter the loop ends, if ch == EOF, the loop has read through to the end of the stream without encountering a newline character, or a read error occurred before the loop encountered a newline character. To conform to FIO34-C. Distinguish between characters read from a file and EOF or WEOF, the error-handling code must verify that an end-of-file or error has occurred by calling feof() or ferror().\nCompliant Solution (getchar())\nIn this compliant solution, characters are no longer copied to buf once index == BUFFERSIZE - 1, leaving room to null-terminate the string. The loop continues to read characters until the end of the line, the end of the file, or an error is encountered. When truncated == true, the input string has been truncated.\n#include <stdio.h>\n  enum { BUFFERSIZE = 32 };\n void func(void) {\n  char buf[BUFFERSIZE];\n  int ch;\n  size_t index = 0;\n  bool truncated = false;\n   while ((ch = getchar()) != '\\n' && ch != EOF) {\n    if (index < sizeof(buf) - 1) {\n      buf[index++] = (char)ch;\n    } else {\n      truncated = true;\n    }\n  }\n  buf[index] = '\\0';  /* Terminate string */\n  if (ch == EOF) {\n    /* Handle EOF or error */\n  }\n  if (truncated) {\n    /* Handle truncation */\n  }\n}\nNoncompliant Code Example (fscanf())\nIn this noncompliant example, the call to fscanf() can result in a write outside the character array buf:\n#include <stdio.h>\n  enum { BUF_LENGTH = 1024 };\n  void get_data(void) {\n  char buf[BUF_LENGTH];\n  if (1 != fscanf(stdin, \"%s\", buf)) {\n    /* Handle error */\n  }\n   /* Rest of function */\n}\nCompliant Solution (fscanf())\nIn this compliant solution, the call to fscanf() is constrained not to overflow buf:\n#include <stdio.h>\n  enum { BUF_LENGTH = 1024 };\n  void get_data(void) {\n  char buf[BUF_LENGTH];\n  if (1 != fscanf(stdin, \"%1023s\", buf)) {\n    /* Handle error */\n  }\n   /* Rest of function */\n}\nNoncompliant Code Example (argv)\nIn a hosted environment, arguments read from the command line are stored in process memory. The function main(), called at program startup, is typically declared as follows when the program accepts command-line arguments:\nint main(int argc, char *argv[]) { /* ... */ }\nCommand-line arguments are passed to main() as pointers to strings in the array members argv[0] through argv[argc - 1]. If the value of argc is greater than 0, the string pointed to by argv[0] is, by convention, the program name. If the value of argc is greater than 1, the strings referenced by argv[1] through argv[argc - 1] are the program arguments.\nVulnerabilities can occur when inadequate space is allocated to copy a command-line argument or other program input. In this noncompliant code example, an attacker can manipulate the contents of argv[0] to cause a buffer overflow:\n#include <string.h>\n  int main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char *const name = (argc && argv[0]) ? argv[0] : \"\";\n  char prog_name[128];\n  strcpy(prog_name, name);\n    return 0;\n}\nCompliant Solution (argv)\nThe strlen() function can be used to determine the length of the strings referenced by argv[0] through argv[argc - 1] so that adequate memory can be dynamically allocated.\n#include <stdlib.h>\n#include <string.h>\n  int main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char *const name = (argc && argv[0]) ? argv[0] : \"\";\n  char *prog_name = (char *)malloc(strlen(name) + 1);\n  if (prog_name != NULL) {\n    strcpy(prog_name, name);\n  } else {\n    /* Handle error */\n  }\n  free(prog_name);\n  return 0;\n}\nRemember to add a byte to the destination string size to accommodate the null-termination character.\nCompliant Solution (argv)\nThe strcpy_s() function provides additional safeguards, including accepting the size of the destination buffer as an additional argument. (See VOID STR07-C. Use the bounds-checking interfaces for string manipulation.)\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdlib.h>\n#include <string.h>\n  int main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char *const name = (argc && argv[0]) ? argv[0] : \"\";\n  char *prog_name;\n  size_t prog_size;\n   prog_size = strlen(name) + 1;\n  prog_name = (char *)malloc(prog_size);\n   if (prog_name != NULL) {\n    if (strcpy_s(prog_name, prog_size, name)) {\n      /* Handle  error */\n    }\n  } else {\n    /* Handle error */\n  }\n  /* ... */\n  free(prog_name);\n  return 0;\n}\nThe strcpy_s() function can be used to copy data to or from dynamically allocated memory or a statically allocated array. If insufficient space is available, strcpy_s() returns an error.\nCompliant Solution (argv)\nIf an argument will not be modified or concatenated, there is no reason to make a copy of the string. Not copying a string is the best way to prevent a buffer overflow and is also the most efficient solution. Care must be taken to avoid assuming that argv[0] is non-null.\nint main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char * const prog_name = (argc && argv[0]) ? argv[0] : \"\";\n  /* ... */\n  return 0;\n}\nNoncompliant Code Example (getenv())\nAccording to the C Standard, 7.22.4.6 [ISO/IEC 9899:2011]\nThe getenv function searches an environment list, provided by the host environment, for a string that matches the string pointed to by name. The set of environment names and the method for altering the environment list are implementation defined.\nEnvironment variables can be arbitrarily large, and copying them into fixed-length arrays without first determining the size and allocating adequate storage can result in a buffer overflow.\n#include <stdlib.h>\n#include <string.h>\n  void func(void) {\n  char buff[256];\n  char *editor = getenv(\"EDITOR\");\n  if (editor == NULL) {\n    /* EDITOR environment variable not set */\n  } else {\n    strcpy(buff, editor);\n  }\n}\nCompliant Solution (getenv())\nEnvironmental variables are loaded into process memory when the program is loaded. As a result, the length of these strings can be determined by calling the strlen() function, and the resulting length can be used to allocate adequate dynamic memory:\n#include <stdlib.h>\n#include <string.h>\n  void func(void) {\n  char *buff;\n  char *editor = getenv(\"EDITOR\");\n  if (editor == NULL) {\n    /* EDITOR environment variable not set */\n  } else {\n    size_t len = strlen(editor) + 1;\n    buff = (char *)malloc(len);\n    if (buff == NULL) {\n      /* Handle error */\n    } \n    memcpy(buff, editor, len);\n    free(buff);\n  }\n}\nNoncompliant Code Example (sprintf())\nIn this noncompliant code example, name refers to an external string; it could have originated from user input, the file system, or the network. The program constructs a file name from the string in preparation for opening the file.\n#include <stdio.h>\n  void func(const char *name) {\n  char filename[128];\n  sprintf(filename, \"%s.txt\", name);\n}\nBecause the sprintf() function makes no guarantees regarding the length of the generated string, a sufficiently long string in name could generate a buffer overflow.\nCompliant Solution (sprintf())\nThe buffer overflow in the preceding noncompliant example can be prevented by adding a precision to the %s conversion specification. If the precision is specified, no more than that many bytes are written. The precision 123 in this compliant solution ensures that filename can contain the first 123 characters of name, the .txt extension, and the null terminator.\n#include <stdio.h>\n  void func(const char *name) {\n  char filename[128];\n  sprintf(filename, \"%.123s.txt\", name);\n}\nYou can also use * to indicate that the precision should be provided as a variadic argument:\n#include <stdio.h>\n  void func(const char *name) {\n  char filename[128];\n  sprintf(filename, \"%.*s.txt\", sizeof(filename) - 5, name);\n}\nCompliant Solution (snprintf())\nA more general solution is to use the snprintf() function, which also truncates name if it will not fit in the filename.\n#include <stdio.h>\n  void func(const char *name) {\n  char filename[128];\n  int result = snprintf(filename, sizeof(filename), \"%s.txt\", name);\n  if (result != strlen(filename) {\n    /* truncation occurred */\n  }\n}\nRisk Assessment\nCopying string data to a buffer that is too small to hold that data results in a buffer overflow. Attackers can exploit this condition to execute arbitrary code with the permissions of the vulnerable process.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSTR31-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nArray access out of bounds, Buffer overflow from incorrect string format specifier, Destination buffer overflow in string manipulation, Invalid use of standard library string routine, Missing null in string array, Pointer access out of bounds, Tainted NULL or non-null-terminated string, Use of dangerous standard function \nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported\nAstr\u00e9e reports all buffer overflows resulting from copying data to a buffer that is not large enough to hold that data.\nAxivion Bauhaus Suite 7.2.0 CertC-STR31\nDetects calls to unsafe string function that may cause buffer overflow\nDetects potential buffer overruns, including those caused by unsafe usage of fscanf()\nCodeSonar\n9.1p0\nLANG.MEM.BO\nLANG.MEM.TO\nMISC.MEM.NTERM\nBADFUNC.BO.*\nBuffer overrun\nType overrun\nNo space for null terminator\nA collection of warning classes that report uses of library functions prone to internal buffer overflows\nCompass/ROSE\n\n\nCan detect violations of the rule. However, it is unable to handle cases involving strcpy_s() or manual string copies such as the one in the first example\nCoverity\n2017.07\nSTRING_OVERFLOW\nBUFFER_SIZE\nOVERRUN\nSTRING_SIZE\nFully implemented\nFortify SCA\n5.0\n\n\nHelix QAC\n2025.2\nC2840,  C5009, C5038\nC++0145, C++5009, C++5038\nDF2840, DF2841, DF2842, DF2843, DF2845, DF2846, DF2847, DF2848, DF2930, DF2931, DF2932, DF2933, DF2935, DF2936, DF2937, DF2938, DF3581, DF3582, DF3583, DF3586, DF3587, DF3589\n\nKlocwork\n2025.2\nSV.FMT_STR.BAD_SCAN_FORMAT\nSV.UNBOUND_STRING_INPUT.FUNC\n\nLDRA tool suite\n9.7.1\n489 S, 109 D, 66 X, 70 X, 71 X\nPartially implemented\nParasoft C/C++test 2024.2\nCERT_C-STR31-a\nCERT_C-STR31-b\nCERT_C-STR31-c\nCERT_C-STR31-d\nCERT_C-STR31-e\nAvoid accessing arrays out of bounds\nAvoid overflow when writing to a buffer\nPrevent buffer overflows from tainted data\nAvoid buffer write overflow from tainted data\nAvoid using unsafe string functions which may cause buffer overflows\nPC-lint Plus\n1.4\n421, 498\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule STR31-C\nChecks for:\nUse of dangerous standard function\nMissing null in string array\nBuffer overflow from incorrect string format specifier\nDestination buffer overflow in string manipulation\nInsufficient destination buffer size\nRule partially covered.\nPVS-Studio\n7.38\nV518, V645, V727, V755\nSecurity Reviewer - Static Reviewer\n6.02\nRTOS_33\nRTOS_34\nshadowVariable\nUNSAFE_03\nUNSAFE_04\nFully implemented\nSplint\n3.1.1\n\n\nTrustInSoft Analyzer\n1.38\nmem_access\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nCVE-2009-1252 results from a violation of this rule. The Network Time Protocol daemon (NTPd), before versions 4.2.4p7 and 4.2.5p74, contained calls to sprintf that allow an attacker to execute arbitrary code by overflowing a character array [xorl 2009].\nCVE-2009-0587 results from a violation of this rule. Before version 2.24.5, Evolution Data Server performed unchecked arithmetic operations on the length of a user-input string and used the value to allocate space for a new buffer. An attacker could thereby execute arbitrary code by inputting a long string, resulting in incorrect allocation and buffer overflow [xorl 2009].\nCVE-2021-3156 results from a violation of this rule in versions of Sudo before 1.9.5p2. Due to inconsistencies on whether backslashes are escaped, vulnerable versions of Sudo enabled a user to create a heap-based buffer overflow and exploit it to execute arbitrary code. [BC].\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard STR03-C. Do not inadvertently truncate a string Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard STR07-C. Use the bounds-checking interfaces for remediation of existing string manipulation code\nMSC24-C. Do not use deprecated or obsolescent functions\nMEM00-C. Allocate and free memory in the same module, at the same level of abstraction\nFIO34-C. Distinguish between characters read from a file and EOF or WEOF Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 String Termination [CJM] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Buffer Boundary Violation (Buffer Overflow) [HCB] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Unchecked Array Copying [XYW] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Using a tainted value to write to an object using a formatted input or output function [taintformatio] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Tainted strings are passed to a string copying function [taintstrcpy] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer 2017-05-18: CERT: Rule subset of CWE\nCWE 2.11 CWE-120, Buffer Copy without Checking Size of Input (\"Classic Buffer Overflow\") 2017-05-15: CERT: Exact\nCWE 2.11 CWE-123, Write-what-where Condition 2017-06-12: CERT: Partial overlap\nCWE 2.11 CWE-125, Out-of-bounds Read 2017-05-18: CERT: Partial overlap\nCWE 2.11 CWE-676, Off-by-one Error 2017-05-18: CERT: Partial overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-122 and STR31-C\nSTR31-C = Union( CWE-122, list) where list =\nBuffer overflows on strings in the stack or data segment\nCWE-125 and STR31-C\nIndependent( ARR30-C, ARR38-C, EXP39-C, INT30-C)\nSTR31-C = Subset( Union( ARR30-C, ARR38-C))\nSTR32-C = Subset( ARR38-C)\nIntersection( STR31-C, CWE-125) =\nDirectly reading beyond the end of a string\nSTR31-C \u2013 CWE-125 =\nDirectly writing beyond the end of a string\nCWE-125 \u2013 STR31-C =\nReading beyond a non-string array\nReading beyond a string using library functions\nCWE-676 and STR31-C\nIndependent( ENV33-C, CON33-C, STR31-C, EXP33-C, MSC30-C, ERR34-C)\nSTR31-C implies that several C string copy functions, like strcpy() are dangerous.\nIntersection( CWE-676, STR31-C) =\nBuffer Overflow resulting from invocation of the following dangerous functions:\ngets(), fscanf(), strcpy(), sprintf()\nSTR31-C \u2013 CWE-676 =\nBuffer overflow that does not involve the dangerous functions listed above.\nCWE-676 - STR31-C =\nInvocation of other dangerous functions\nCWE-121 and STR31-C\nSTR31-C = Union( CWE-121, list) where list =\nBuffer overflows on strings in the heap or data segment\nCWE-123 and STR31-C\nIndependent(ARR30-C, ARR38-C)\nSTR31-C = Subset( Union( ARR30-C, ARR38-C))\nSTR32-C = Subset( ARR38-C)\nIntersection( CWE-123, STR31-C) =\nBuffer overflow that overwrites a (unrelated) pointer with untrusted data\nSTR31-C \u2013 CWE-123 =\nBuffer overflow that does not overwrite a (unrelated) pointer\nCWE-123 \u2013 STR31-C =\nArbitrary writes that do not involve buffer overflows\nCWE-119 and STR31-C\nIndependent( ARR30-C, ARR38-C, ARR32-C, INT30-C, INT31-C, EXP39-C, EXP33-C, FIO37-C)\nSTR31-C = Subset( Union( ARR30-C, ARR38-C))\nSTR32-C = Subset( ARR38-C)\nCWE-119 = Union( STR31-C, list) where list =\nOut-of-bounds reads or writes that are not created by string copy operations\nCWE-193 and STR31-C\nIntersection( CWE-193, STR31-C) = \u00d8\nCWE-193 involves an integer computation error (typically off-by-one), which is often a precursor to (slight) buffer overflow. However the two errors occur in different operations and are thus unrelated.\nBibliography\n[Dowd 2006] Chapter 7, \"Program Building Blocks\" (\"Loop Constructs,\" pp. 327\u2013336)\n[Drepper 2006] Section 2.1.1, \"Respecting Memory Bounds\"\n[ISO/IEC 9899:2024] K.3.5.4.1, \"The gets_s Function\"\n[Lai 2006]\n[NIST 2006] SAMATE Reference Dataset Test Case ID 000-000-088\n[Seacord 2013b] Chapter 2, \"Strings\"\n[xorl 2009] FreeBSD-SA-09:11: NTPd Remote Stack Based Buffer Overflows\n[BC]\nNew Linux SUDO flaw lets local users gain root privileges",
        "language": "C"
    },
    {
        "rule_id": "STR30-C",
        "rule_title": "Do not attempt to modify string literals",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/STR30-C.+Do+not+attempt+to+modify+string+literals",
        "content": "According to the C Standard, 6.4.5, paragraph 3 [ISO/IEC 9899:2024]:\nA character string literal is a sequence of zero or more multibyte characters enclosed in double-quotes, as in \"xyz\". A UTF-8 string literal is the same, except prefixed by u8. A wchar_t string literal is the same, except prefixed by L. A UTF-16 string literal is the same, except prefixed by u. A UTF-32 string literal is the same, except prefixed by U. Collectively, wchar_t, UTF-16, and UTF-32 string literals are called wide string literals.\nAt compile time, string literals are used to create an array of static storage duration of sufficient length to contain the character sequence and a terminating null character. String literals are usually referred to by a pointer to (or array of) characters. Ideally, they should be assigned only to pointers to (or arrays of) const char or const wchar_t. It is unspecified whether these arrays of string literals are distinct from each other. The behavior is undefined if a program attempts to modify any portion of a string literal. Modifying a string literal frequently results in an access violation because string literals are typically stored in read-only memory. (See undefined behavior 32.)\nAvoid assigning a string literal to a pointer to non-const or casting a string literal to a pointer to non-const. For the purposes of this rule, a pointer to (or array of) const characters must be treated as a string literal. Similarly, the returned value of the following library functions must be treated as a string literal if the first argument is a string literal:\nstrpbrk(), strchr(), strrchr(), strstr()\nwcspbrk(), wcschr(), wcsrchr(), wcsstr()\nmemchr(), wmemchr()\nThis rule is a specific instance of EXP40-C. Do not modify constant objects.\nNoncompliant Code Example\nIn this noncompliant code example, the char pointer str is initialized to the address of a string literal. Attempting to modify the string literal is undefined behavior 32:\nchar *str  = \"string literal\";\nstr[0] = 'S';\nCompliant Solution\nAs an array initializer, a string literal specifies the initial values of characters in an array as well as the size of the array. (See STR11-C. Do not specify the bound of a character array initialized with a string literal.) This code creates a copy of the string literal in the space allocated to the character array str. The string stored in str can be modified safely.\nchar str[] = \"string literal\";\nstr[0] = 'S';\nNoncompliant Code Example (POSIX)\nIn this noncompliant code example, a string literal is passed to the (pointer to non-const) parameter of the POSIX function mkstemp(), which then modifies the characters of the string literal:\n#include <stdlib.h>\n \nvoid func(void) {\n  mkstemp(\"/tmp/edXXXXXX\");\n}\nThe behavior of mkstemp() is described in more detail in FIO21-C. Do not create temporary files in shared directories.\nCompliant Solution (POSIX)\nThis compliant solution uses a named array instead of passing a string literal:\n#include <stdlib.h>\n \nvoid func(void) {\n  static char fname[] = \"/tmp/edXXXXXX\";\n  mkstemp(fname);\n}\nNoncompliant Code Example (Result of strrchr())\nIn this noncompliant example, the char * result of the strrchr() function is used to modify the object pointed to by pathname. Because the argument to strrchr() points to a string literal, the effects of the modification are undefined.\n#include <stdio.h>\n#include <string.h>\n \nconst char *get_dirname(const char *pathname) {\n  char *slash;\n  slash = strrchr(pathname, '/');\n  if (slash) {\n    *slash = '\\0'; /* Undefined behavior */\n  }\n  return pathname;\n}\n\nint main(void) {\n  puts(get_dirname(__FILE__));\n  return 0;\n}\nCompliant Solution (Result of strrchr())\nThis compliant solution avoids modifying a const object, even if it is possible to obtain a non-const pointer to such an object by calling a standard C library function, such as strrchr(). To reduce the risk to callers of get_dirname(), a buffer and length for the directory name are passed into the function. It is insufficient to change pathname to require a char * instead of a const char * because conforming compilers are not required to diagnose passing a string literal to a function accepting a char *.\n#include <stddef.h>\n#include <stdio.h>\n#include <string.h>\n \nchar *get_dirname(const char *pathname, char *dirname, size_t size) {\n  const char *slash;\n  slash = strrchr(pathname, '/');\n  if (slash) {\n    ptrdiff_t slash_idx = slash - pathname;\n    if ((size_t)slash_idx < size) {\n      memcpy(dirname, pathname, slash_idx);\n      dirname[slash_idx] = '\\0';      \n      return dirname;\n    }\n  }\n  return 0;\n}\n \nint main(void) {\n  char dirname[260];\n  if (get_dirname(__FILE__, dirname, sizeof(dirname))) {\n    puts(dirname);\n  }\n  return 0;\n}\nRisk Assessment\nModifying string literals can lead to abnormal program termination and possibly denial-of-service attacks.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSTR30-C\nLow\nLikely\nNo\nYes\nP6\nL2\nAutomated Detection\n\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nstring-literal-modfication\nwrite-to-string-literal Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-STR30 Fully implemented\nCompass/ROSE\n\nCan detect simple violations of this rule\nCoverity\n2017.07\nPW Deprecates conversion from a string literal to \"char *\"\nCppcheck Premium \n24.11.0\npremium-cert-str30-c  \nHelix QAC\n2025.2\nC0556, C0752, C0753, C0754\nC++3063, C++3064, C++3605, C++3606, C++3607\n\nKlocwork\n2025.2\nCERT.STR.ARG.CONST_TO_NONCONST\nCERT.STR.ASSIGN.CONST_TO_NONCONST\n\nLDRA tool suite\n9.7.1\n157 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-STR30-a\nCERT_C-STR30-b\nA string literal shall not be modified\nDo not modify string literals\nPC-lint Plus\n1.4\n489, 1776\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule STR30-C Checks for writing to const qualified object (rule fully covered)\n\nPVS-Studio\n7.38\nV675\nRuleChecker\n24.04\nstring-literal-modfication Partially checked\nSplint\n3.1.1\n\n\nTrustInSoft Analyzer\n1.38\nmem_access Exhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard EXP05-C. Do not cast away a const qualification Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard STR11-C. Do not specify the bound of a character array initialized with a string literal Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Modifying string literals [strmod] Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 6.4.5, \"String Literals\"\n[Plum 1991] Topic 1.26, \"Strings\u2014String Literals\"\n[Summit 1995] comp.lang.c FAQ List, Question 1.32",
        "language": "C"
    },
    {
        "rule_id": "STR32-C",
        "rule_title": "Do not pass a non-null-terminated character sequence to a library function that expects a string",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/STR32-C.+Do+not+pass+a+non-null-terminated+character+sequence+to+a+library+function+that+expects+a+string",
        "content": "Many library functions accept a string or wide string argument with the constraint that the string they receive is properly null-terminated. Passing a character sequence or wide character sequence that is not null-terminated to such a function can result in accessing memory that is outside the bounds of the object. Do not pass a character sequence or wide character sequence that is not null-terminated to a library function that expects a string or wide string argument. \nNoncompliant Code Example\nThis code example is noncompliant because the character sequence c_str will not be null-terminated when passed as an argument to printf(). (See STR11-C. Do not specify the bound of a character array initialized with a string literal on how to properly initialize character arrays.)\n#include <stdio.h>\n  void func(void) {\n  char c_str[3] = \"abc\";\n  printf(\"%s\\n\", c_str);\n}\nCompliant Solution\nThis compliant solution does not specify the bound of the character array in the array declaration. If the array bound is omitted, the compiler allocates sufficient storage to store the entire string literal, including the terminating null character.\n#include <stdio.h>\n  void func(void) {\n  char c_str[] = \"abc\";\n  printf(\"%s\\n\", c_str);\n}\nNoncompliant Code Example\nThis code example is noncompliant because the wide character sequence cur_msg will not be null-terminated when passed to wcslen(). This will occur if lessen_memory_usage() is invoked while cur_msg_size still has its initial value of 1024.\n#include <stdlib.h>\n#include <wchar.h>\n  wchar_t *cur_msg = NULL;\nsize_t cur_msg_size = 1024;\nsize_t cur_msg_len = 0;\n void lessen_memory_usage(void) {\n  wchar_t *temp;\n  size_t temp_size;\n   /* ... */\n   if (cur_msg != NULL) {\n    temp_size = cur_msg_size / 2 + 1;\n    temp = realloc(cur_msg, temp_size * sizeof(wchar_t));\n    /* temp &and cur_msg may no longer be null-terminated */\n    if (temp == NULL) {\n      /* Handle error */\n    }\n     cur_msg = temp;\n    cur_msg_size = temp_size;\n    cur_msg_len = wcslen(cur_msg);\n  }\n}\nCompliant Solution\nIn this compliant solution, cur_msg will always be null-terminated when passed to wcslen():\n#include <stdlib.h>\n#include <wchar.h>\n  wchar_t *cur_msg = NULL;\nsize_t cur_msg_size = 1024;\nsize_t cur_msg_len = 0;\n void lessen_memory_usage(void) {\n  wchar_t *temp;\n  size_t temp_size;\n   /* ... */\n   if (cur_msg != NULL) {\n    temp_size = cur_msg_size / 2 + 1;\n    temp = realloc(cur_msg, temp_size * sizeof(wchar_t));\n    /* temp and cur_msg may no longer be null-terminated */\n    if (temp == NULL) {\n      /* Handle error */\n    }\n     cur_msg = temp;\n    /* Properly null-terminate cur_msg */\n    cur_msg[temp_size - 1] = L'\\0';\n    cur_msg_size = temp_size;\n    cur_msg_len = wcslen(cur_msg);\n  }\n}\nNoncompliant Code Example (strncpy())\nAlthough the strncpy() function takes a string as input, it does not guarantee that the resulting value is still null-terminated. In the following noncompliant code example, if no null character is contained in the first n characters of the source array, the result will not be null-terminated. Passing a non-null-terminated character sequence to strlen() is undefined behavior 196.\n#include <string.h>\n  enum { STR_SIZE = 32 };\n  size_t func(const char *source) {\n  char c_str[STR_SIZE];\n  size_t ret = 0;\n   if (source) {\n    c_str[sizeof(c_str) - 1] = '\\0';\n    strncpy(c_str, source, sizeof(c_str));\n    ret = strlen(c_str);\n  } else {\n    /* Handle null pointer */\n  }\n  return ret;\n}\nCompliant Solution (Truncation)\nThis compliant solution is correct if the programmer's intent is to truncate the string:\n#include <string.h>\n  enum { STR_SIZE = 32 };\n  size_t func(const char *source) {\n  char c_str[STR_SIZE];\n  size_t ret = 0;\n   if (source) {\n    strncpy(c_str, source, sizeof(c_str) - 1);\n    c_str[sizeof(c_str) - 1] = '\\0';\n    ret = strlen(c_str);\n  } else {\n    /* Handle null pointer */\n  }\n  return ret;\n}\nCompliant Solution (Copy without Truncation)\nIf the programmer's intent is to copy without truncation, this compliant solution copies the data and guarantees that the resulting array is null-terminated. If the string cannot be copied, it is handled as an error condition.\n#include <string.h>\n  enum { STR_SIZE = 32 };\n  size_t func(const char *source) {\n  char c_str[STR_SIZE];\n  size_t ret = 0;\n   if (source) {\n    if (strnlen(source, sizeof(c_str)) < sizeof(c_str)) {\n      strcpy(c_str, source);\n      ret = strlen(c_str);\n    } else {\n      /* Handle string-too-large */\n    }\n  } else {\n    /* Handle null pointer */\n  }\n  return ret;\n}\nNote that this code is not bulletproof. It gracefully handles the case where source  is NULL, when it is a valid string, and when source is not null-terminated, but at least the first 32 bytes are valid. However, in cases where source is not NULL, but points to invalid memory, or any of the first 32 bytes are invalid memory, the first call to strnlen() will access this invalid memory, and the resulting behavior is undefined. Unfortunately, standard C provides no way to prevent or even detect this condition without some external knowledge about the memory source points to.\nRisk Assessment\nFailure to properly null-terminate a character sequence that is passed to a library function that expects a string can result in buffer overflows and the execution of arbitrary code with the permissions of the vulnerable process. Null-termination errors can also result in unintended information disclosure.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSTR32-C\nHigh\nProbable\nNo\nYes\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported\nAstr\u00e9e supports the implementation of library stubs to fully verify this guideline.\nAxivion Bauhaus Suite\n7.2.0\nCertC-STR32 Partially implemented: can detect some violation of the rule\nCodeSonar\n9.1p0\nMISC.MEM.NTERM.CSTRING Unterminated C String\nCompass/ROSE\n\n\nCan detect some violations of this rule\nCoverity\n2017.07\nSTRING_NULL Fully implemented\nCppcheck Premium\n24.11.0\npremium-cert-str32-c\nHelix QAC\n2025.2\nDF2835, DF2836, DF2839\n\nKlocwork\n2025.2\nNNTS.MIGHT\nNNTS.MUST\nSV.STRBO.BOUND_COPY.UNTERM\n\nLDRA tool suite\n9.7.1\n404 S, 600 S\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-STR32-a\nAvoid overflow due to reading a not zero terminated string\nPolyspace Bug Finder\nR2025b\nCERT C: Rule STR32-C\n\nChecks for:\nInvalid use of standard library string routine\nTainted NULL or non-null-terminated string\nRule partially covered.\nPVS-Studio\n7.38\nV692\nSecurity Reviewer - Static Reviewer\n6.02\nshiftTooManyBits Fully implemented\nTrustInSoft Analyzer\n1.38\nmatch format and arguments Partially verified.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TR 24772:2013 String Termination [CMJ] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Passing a non-null-terminated character sequence to a library function that expects a string [strmod] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer 2017-05-18: CERT: Rule subset of CWE\nCWE 2.11 CWE-123, Write-what-where Condition 2017-06-12: CERT: Partial overlap\nCWE 2.11 CWE-125, Out-of-bounds Read 2017-05-18: CERT: Rule subset of CWE\nCWE 2.11 CWE-170, Improper Null Termination 2017-06-13: CERT: Exact\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-119 and STR32-C\nIndependent( ARR30-C, ARR38-C, ARR32-C, INT30-C, INT31-C, EXP39-C, EXP33-C, FIO37-C) STR31-C = Subset( Union( ARR30-C, ARR38-C)) STR32-C = Subset( ARR38-C)\nCWE-119 = Union( STR32-C, list) where list =\n\nOut-of-bounds reads or writes that do not involve non-null-terminated byte strings.\n\nCWE-125 and STR32-C\nIndependent( ARR30-C, ARR38-C, EXP39-C, INT30-C) STR31-C = Subset( Union( ARR30-C, ARR38-C)) STR32-C = Subset( ARR38-C)\nCWE-125 = Union( STR32-C, list) where list =\n\nOut-of-bounds reads that do not involve non-null-terminated byte strings.\n\nCWE-123 and STR32-C\nIndependent(ARR30-C, ARR38-C) STR31-C = Subset( Union( ARR30-C, ARR38-C)) STR32-C = Subset( ARR38-C)\nIntersection( CWE-123, STR32-C) =\n\nBuffer overflow from passing a non-null-terminated byte string to a standard C library copying function that expects null termination, and that overwrites an (unrelated) pointer\n\nSTR32-C - CWE-123 =\n\nBuffer overflow from passing a non-null-terminated byte string to a standard C library copying function that expects null termination, but it does not overwrite an (unrelated) pointer\n\nCWE-123 \u2013 STR31-C =\n\nArbitrary writes that do not involve standard C library copying functions, such as strcpy()\n\nBibliography\n[Seacord 2013]  Chapter 2, \"Strings\" \n[Viega 2005] Section 5.2.14, \"Miscalculated NULL Termination\"",
        "language": "C"
    },
    {
        "rule_id": "STR34-C",
        "rule_title": "Cast characters to unsigned char before converting to larger integer sizes",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/STR34-C.+Cast+characters+to+unsigned+char+before+converting+to+larger+integer+sizes",
        "content": "Signed character data must be converted to unsigned char before being assigned or converted to a larger signed type. This rule applies to both signed char and (plain) char characters on implementations where char is defined to have the same range, representation, and behaviors as signed char.\nHowever, this rule is applicable only in cases where the character data may contain values that can be misinterpreted as negative numbers. For example, if the char type is represented by a two's complement 8-bit value, any character value greater than +127 is interpreted as a negative value.\nThis rule is a generalization of STR37-C. Arguments to character-handling functions must be representable as an unsigned char.\nNoncompliant Code Example\nThis noncompliant code example is taken from a vulnerability in bash versions 1.14.6 and earlier that led to the release of CERT Advisory CA-1996-22. This vulnerability resulted from the sign extension of character data referenced by the c_str pointer in the yy_string_get() function in the parse.y module of the bash source code:\nstatic int yy_string_get(void) {\n  register char *c_str;\n  register int c;\n\n  c_str = bash_input.location.string;\n  c = EOF;\n\n  /* If the string doesn't exist or is empty, EOF found */\n  if (c_str && *c_str) {\n    c = *c_str++;\n    bash_input.location.string = c_str;\n  }\n  return (c);\n}\nThe c_str variable is used to traverse the character string containing the command line to be parsed. As characters are retrieved from this pointer, they are stored in a variable of type int. For implementations in which the char type is defined to have the same range, representation, and behavior as signed char, this value is sign-extended when assigned to the int variable. For character code 255 decimal (\u22121 in two's complement form), this sign extension results in the value \u22121 being assigned to the integer, which is indistinguishable from EOF.\nNoncompliant Code Example\nThis problem can be repaired by explicitly declaring the c_str variable as unsigned char:\nstatic int yy_string_get(void) {\n  register unsigned char *c_str;\n  register int c;\n\n  c_str = bash_input.location.string;\n  c = EOF;\n\n  /* If the string doesn't exist or is empty, EOF found */\n  if (c_str && *c_str) {\n    c = *c_str++;\n    bash_input.location.string = c_str;\n  }\n  return (c);\n}\nThis example, however, violates STR04-C. Use plain char for characters in the basic character set.\nCompliant Solution\nIn this compliant solution, the result of the expression *c_str++ is cast to unsigned char before assignment to the int variable c:\nstatic int yy_string_get(void) {\n  register char *c_str;\n  register int c;\n\n  c_str = bash_input.location.string;\n  c = EOF;\n\n  /* If the string doesn't exist or is empty, EOF found */\n  if (c_str && *c_str) {\n    /* Cast to unsigned type */\n    c = (unsigned char)*c_str++;\n\n    bash_input.location.string = c_str;\n  }\n  return (c);\n}\nNoncompliant Code Example\nIn this noncompliant code example, the cast of *s to unsigned int can result in a value in excess of UCHAR_MAX because of integer promotions, a violation of ARR30-C. Do not form or use out-of-bounds pointers or array subscripts:\n#include <limits.h>\n#include <stddef.h>\n \nstatic const char table[UCHAR_MAX + 1] = { 'a' /* ... */ };\n\nptrdiff_t first_not_in_table(const char *c_str) {\n  for (const char *s = c_str; *s; ++s) {\n    if (table[(unsigned int)*s] != *s) {\n      return s - c_str;\n    }\n  }\n  return -1;\n}\nCompliant Solution\nThis compliant solution casts the value of type char to unsigned char before the implicit promotion to a larger type:\n#include <limits.h>\n#include <stddef.h>\n \nstatic const char table[UCHAR_MAX + 1] = { 'a' /* ... */ };\n\nptrdiff_t first_not_in_table(const char *c_str) {\n  for (const char *s = c_str; *s; ++s) {\n    if (table[(unsigned char)*s] != *s) {\n      return s - c_str;\n    }\n  }\n  return -1;\n}\nExceptions\nSTR34-C-EX1: This rule only applies to characters that are to be treated as unsigned chars for some purpose, such as being passed to the isdigit() function. Characters that hold small integer values for mathematical purposes need not comply with this rule.\nRisk Assessment\nConversion of character data resulting in a value in excess of UCHAR_MAX is an often-missed error that can result in a disturbingly broad range of potentially severe vulnerabilities.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSTR34-C\nMedium\nProbable\nYes\nNo\nP8\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nchar-sign-conversion Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-STR34 Fully implemented\nCodeSonar\n9.1p0\nMISC.NEGCHAR Negative Character Value\nCompass/ROSE\n\nCan detect violations of this rule when checking for violations of INT07-C. Use only explicitly signed or unsigned char type for numeric values\nCoverity\n2017.07\nMISRA C 2012 Rule 10.1\nMISRA C 2012 Rule 10.2\nMISRA C 2012 Rule 10.3\nMISRA C 2012 Rule 10.4\nImplemented\nEssential type checkers\nCppcheck Premium\n24.11.0\npremium-cert-str34-c\nECLAIR\n1.2\nCC2.STR34\nFully implemented\nGCC\n2.95 and later\n-Wchar-subscripts\nDetects objects of type char used as array indices\nHelix QAC\n2025.2\nC2140, C2141, C2143, C2144, C2145, C2147, C2148, C2149, C2151, C2152, C2153, C2155\nC++3051\n\nKlocwork\n2025.2\nCXX.CAST.SIGNED_CHAR_TO_INTEGER\n\nLDRA tool suite\n9.7.1\n434 S\nPartially implemented\nParasoft C/C++test 2024.2\nCERT_C-STR34-b\nCERT_C-STR34-c\nCERT_C-STR34-d\nCast characters to unsigned char before assignment to larger integer sizes\nAn expressions of the 'signed char' type should not be used as an array index\nCast characters to unsigned char before converting to larger integer sizes\nPC-lint Plus\n1.4\n571\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule STR34-C Checks for misuse of sign-extended character value (rule fully covered)\nRuleChecker\n24.04\nchar-sign-conversion Fully checked\nTrustInSoft Analyzer\n1.38\nout of bounds read Partially verified (exhaustively detects undefined behavior).\nRelated Vulnerabilities\nCVE-2009-0887 results from a violation of this rule. In Linux PAM (up to version 1.0.3), the libpam implementation of strtok() casts a (potentially signed) character to an integer for use as an index to an array. An attacker can exploit this vulnerability by inputting a string with non-ASCII characters, causing the cast to result in a negative index and accessing memory outside of the array [xorl 2009].\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nCERT C Secure Coding Standard STR37-C. Arguments to character-handling functions must be representable as an unsigned char\nSTR04-C. Use plain char for characters in the basic character set\nARR30-C. Do not form or use out-of-bounds pointers or array subscripts\nISO/IEC TS 17961:2013 Conversion of signed characters to wider integer types before a check for EOF [signconv]\nMISRA-C:2012\nRule 10.1 (required)\nRule 10.2 (required)\nRule 10.3 (required)\nRule 10.4 (required)\nMITRE CWE CWE-704, Incorrect Type Conversion or Cast\nBibliography\n[xorl 2009] CVE-2009-0887: Linux-PAM Signedness Issue",
        "language": "C"
    },
    {
        "rule_id": "STR37-C",
        "rule_title": "Arguments to character-handling functions must be representable as an unsigned char",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/STR37-C.+Arguments+to+character-handling+functions+must+be+representable+as+an+unsigned+char",
        "content": "According to the C Standard, 7.4.1 paragraph 1 [ISO/IEC 9899:2024],\nThe header <ctype.h> declares several functions useful for classifying and mapping characters. In all cases the argument is an int, the value of which shall be representable as an unsigned char or shall equal the value of the macro EOF. If the argument has any other value, the behavior is undefined.\nSee also undefined behavior 112.\nThis rule is applicable only to code that runs on platforms where the char data type is defined to have the same range, representation, and behavior as signed char.\nFollowing are the character classification functions that this rule addresses:\nisalnum()\nisalpha()\nisascii()XSI\nisblank()\niscntrl()\nisdigit()\nisgraph()\nislower()\nisprint()\nispunct()\nisspace()\nisupper()\nisxdigit()\ntoascii()XSI\ntoupper()\ntolower()\nXSI denotes an X/Open System Interfaces Extension to ISO/IEC 9945\u2014POSIX. These functions are not defined by the C Standard.\nThis rule is a specific instance of STR34-C. Cast characters to unsigned char before converting to larger integer sizes.\nNoncompliant Code Example\nOn implementations where plain char is signed, this code example is noncompliant because the parameter to isspace(), *t, is defined as a const char *, and this value might not be representable as an unsigned char:\n#include <ctype.h>\n#include <string.h>\n \nsize_t count_preceding_whitespace(const char *s) {\n  const char *t = s;\n  size_t length = strlen(s) + 1;\n  while (isspace(*t) && (t - s < length)) { \n    ++t;\n  }\n  return t - s;\n} \nThe argument to isspace() must be EOF or representable as an unsigned char; otherwise, the result is undefined.\nCompliant Solution\nThis compliant solution casts the character to unsigned char before passing it as an argument to the isspace() function:\n#include <ctype.h>\n#include <string.h>\n \nsize_t count_preceding_whitespace(const char *s) {\n  const char *t = s;\n  size_t length = strlen(s) + 1;\n  while (isspace((unsigned char)*t) && (t - s < length)) { \n    ++t;\n  }\n  return t - s;\n} \nRisk Assessment\nPassing values to character handling functions that cannot be represented as an unsigned char to character handling functions is undefined behavior 112.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSTR37-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nctype-limits Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-STR37 Fully implemented\nCodeSonar\n9.1p0\nMISC.NEGCHAR Negative character value\nCompass/ROSE\n\nCould detect violations of this rule by seeing if the argument to a character handling function (listed above) is not an unsigned char\nECLAIR\n1.2\nCC2.STR37\nFully implemented\nHelix QAC\n2025.2\nC4413, C4414\nC++3051\nDF2796, DF2797, DF2798, DF2799\n\nKlocwork\n2025.2\nAUTOSAR.STDLIB.CCTYPE.UCHAR\nMISRA.ETYPE.ASSIGN.2012\n\nLDRA tool suite\n9.7.1\n663 S Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-STR37-a Do not pass incorrect values to ctype.h library functions\nPolyspace Bug Finder\nR2025b\nCERT C: Rule STR37-C\nChecks for invalid use of standard library integer routine (rule fully covered)\nRuleChecker\n24.04\nctype-limits Partially checked\nSecurity Reviewer - Static Reviewer\n6.02\nUNSAFE_01 Fully implemented\nTrustInSoft Analyzer\n1.38\nvalid_char Partially verified.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard STR34-C. Cast characters to unsigned char before converting to larger integer sizes Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Passing arguments to character-handling functions that are not representable as unsigned char [chrsgnext] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-704, Incorrect Type Conversion or Cast 2017-06-14: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-686 and STR37-C\nIntersection( CWE-686, STR37-C) = \u00d8\nSTR37-C is not about the type of the argument passed (which is signed int), but about the restrictions placed on the value in this type (must be 0-UCHAR_MAX or EOF). I interpret \u2018argument type\u2019 to be specific to the C language, so CWE-686 does not apply to incorrect argument values, just incorrect types (which is relatively rare in C, but still possible).\nCWE-704 and STR37-C\nSTR37-C = Subset( STR34-C)\nCWE-683 and STR37-C\nIntersection( CWE-683, STR37-C) = \u00d8\nSTR37-C excludes mis-ordered function arguments (assuming they pass type-checking), because there is no easy way to reliably detect violations of CWE-683.\nBibliography\n[ISO/IEC 9899:2024] 7.4.1, \"Character Handling <ctype.h>\"\n[Kettlewell 2002] Section 1.1, \"<ctype.h> and Characters Types\"",
        "language": "C"
    },
    {
        "rule_id": "STR38-C",
        "rule_title": "Do not confuse narrow and wide character strings and functions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/STR38-C.+Do+not+confuse+narrow+and+wide+character+strings+and+functions",
        "content": "Passing narrow string arguments to wide string functions or wide string arguments to narrow string functions can lead to unexpected and undefined behavior 151. Scaling problems are likely because of the difference in size between wide and narrow characters. (See ARR39-C. Do not add or subtract a scaled integer to a pointer.) Because wide strings are terminated by a null wide character and can contain null bytes, determining the length is also problematic.\nBecause wchar_t and char are distinct types, many compilers will produce a warning diagnostic if an inappropriate function is used. (See MSC00-C. Compile cleanly at high warning levels.)\nNoncompliant Code Example (Wide Strings with Narrow String Functions) \nThis noncompliant code example incorrectly uses the strncpy() function in an attempt to copy up to 10 wide characters. However, because wide characters can contain null bytes, the copy operation may end earlier than anticipated, resulting in the truncation of the wide string.\n#include <stddef.h>\n#include <string.h>\n  void func(void) {\n  wchar_t wide_str1[]  = L\"0123456789\";\n  wchar_t wide_str2[] =  L\"0000000000\";\n   strncpy(wide_str2, wide_str1, 10);\n}\nNoncompliant Code Example (Narrow Strings with Wide String Functions)\nThis noncompliant code example incorrectly invokes the wcsncpy() function to copy up to 10 wide characters from narrow_str1 to narrow_str2. Because narrow_str2 is a narrow string, it has insufficient memory to store the result of the copy and the copy will result in a buffer overflow.\n#include <wchar.h>\n  void func(void) {\n  char narrow_str1[] = \"01234567890123456789\";\n  char narrow_str2[] = \"0000000000\";\n   wcsncpy(narrow_str2, narrow_str1, 10);\n}\nCompliant Solution\nThis compliant solution uses the proper-width functions. Using wcsncpy() for wide character strings and strncpy() for narrow character strings ensures that data is not truncated and buffer overflow does not occur.\n#include <string.h>\n#include <wchar.h>\n  void func(void) {\n  wchar_t wide_str1[] = L\"0123456789\";\n  wchar_t wide_str2[] = L\"0000000000\";\n  /* Use of proper-width function */\n  wcsncpy(wide_str2, wide_str1, 10);\n   char narrow_str1[] = \"0123456789\";\n  char narrow_str2[] = \"0000000000\";\n  /* Use of proper-width function */\n  strncpy(narrow_str2, narrow_str1, 10);\n}\nNoncompliant Code Example (strlen())\nIn this noncompliant code example, the strlen() function is used to determine the size of a wide character string:\n#include <stdlib.h>\n#include <string.h>\n  void func(void) {\n  wchar_t wide_str1[] = L\"0123456789\";\n  wchar_t *wide_str2 = (wchar_t*)malloc(strlen(wide_str1) + 1);\n  if (wide_str2 == NULL) {\n    /* Handle error */\n  }\n  /* ... */\n  free(wide_str2);\n  wide_str2 = NULL;\n}\nThe strlen() function determines the number of characters that precede the terminating null character. However, wide characters can contain null bytes, particularly when expressing characters from the ASCII character set, as in this example. As a result, the strlen() function will return the number of bytes preceding the first null byte in the wide string. \nCompliant Solution\nThis compliant solution correctly calculates the number of bytes required to contain a copy of the wide string, including the terminating null wide character:\n#include <stdlib.h>\n#include <wchar.h>\n  void func(void) {\n  wchar_t wide_str1[] = L\"0123456789\";\n  wchar_t *wide_str2 = (wchar_t *)malloc(\n    (wcslen(wide_str1) + 1) * sizeof(wchar_t));\n  if (wide_str2 == NULL) {\n    /* Handle error */\n  }\n  /* ... */\n   free(wide_str2);\n  wide_str2 = NULL;\n}\nRisk Assessment\nConfusing narrow and wide character strings can result in buffer overflows, data truncation, and other defects.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSTR38-C\nHigh\nLikely\nYes\nNo\nP18\nL1\nAutomated Detection\nModern compilers recognize the difference between a char * and a wchar_t *, so compiling code that violates this rule will generate warnings. It is feasible to have automated software that recognizes functions of improper width and replaces them with functions of proper width (that is, software that uses wcsncpy() when it recognizes that the parameters are of type wchar_t *).\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nwide-narrow-string-cast\nwide-narrow-string-cast-implicit Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-STR38 Fully implemented\nClang\n3.9\n-Wincompatible-pointer-types\nCodeSonar\n9.1p0\nLANG.MEM.BO\nLANG.MEM.TBA\nBuffer Overrun\nTainted Buffer Access\nCoverity\n2017.07\nPW\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-str38-c\nHelix QAC\n2025.2\nC0432\nC++0403 \n\nKlocwork\n2025.2\nCXX.DIFF.WIDTH.STR_AND_FUNC\n\nParasoft C/C++test\n2024.2\nCERT_C-STR38-a\nDo not confuse narrow and wide character strings and functions\nPC-lint Plus\n1.4\n2454, 2480, 2481\nPartially supported: reports illegal conversions involving pointers to char or wchar_t as well as byte/wide-oriented stream inconsistencies\nPolyspace Bug Finder\nR2025b\nCERT C: Rule STR38-C\nChecks for misuse of narrow or wide character string (rule fully covered)\nRuleChecker\n24.04\nwide-narrow-string-cast\nwide-narrow-string-cast-implicit Partially checked\nSecurity Reviewer - Static Reviewer\n6.02\nUNSAFE_02 Fully implemented\nTrustInSoft Analyzer\n1.38\npointer arithmetic Partially verified.\n\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2024] 7.26.2.5, \"The strncpy Function\"\n7.31.4.2.2, \"The wcsncpy Function\"",
        "language": "C"
    },
    {
        "rule_id": "FIO30-C",
        "rule_title": "Exclude user input from format strings",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings",
        "content": "Never call a formatted I/O function with a format string containing a tainted value .  An attacker who can fully or partially control the contents of a format string can crash a vulnerable process, view the contents of the stack, view memory content, or write to an arbitrary memory location. Consequently, the attacker can execute arbitrary code with the permissions of the vulnerable process [Seacord 2013b]. Formatted output functions are particularly dangerous because many programmers are unaware of their capabilities. For example, formatted output functions can be used to write an integer value to a specified address using the %n conversion specifier.\nNoncompliant Code Example\nThe incorrect_password() function in this noncompliant code example is called during identification and authentication to display an error message if the specified user is not found or the password is incorrect. The function accepts the name of the user as a string referenced by user. This is an exemplar of untrusted data that originates from an unauthenticated user. The function constructs an error message that is then output to stderr using the C Standard fprintf() function.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n  void incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  fprintf(stderr, msg);\n  free(msg);\n}\nThe incorrect_password() function calculates the size of the message, allocates dynamic storage, and then constructs the message in the allocated memory using the snprintf() function. The addition operations are not checked for integer overflow because the string referenced by user is known to have a length of 256 or less. Because the %s characters are replaced by the string referenced by user in the call to snprintf(), the resulting string needs 1 byte less than is allocated. The snprintf() function is commonly used for messages that are displayed in multiple locations or messages that are difficult to build. However, the resulting code contains a format-string vulnerability because the msg includes untrusted user input and is passed as the format-string argument in the call to fprintf().\nCompliant Solution (fputs())\nThis compliant solution fixes the problem by replacing the fprintf() call with a call to fputs(), which outputs msg directly to stderr without evaluating its contents:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n  void incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  fputs(msg, stderr);\n  free(msg);\n}\nCompliant Solution (fprintf())\nThis compliant solution passes the untrusted user input as one of the variadic arguments to fprintf() and not as part of the format string, eliminating the possibility of a format-string vulnerability:\n#include <stdio.h>\n  void incorrect_password(const char *user) {\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  fprintf(stderr, msg_format, user);\n}\nNoncompliant Code Example (POSIX)\nThis noncompliant code example is similar to the first noncompliant code example but uses the POSIX function syslog() [IEEE Std 1003.1:2013] instead of the fprintf() function. The syslog() function is also susceptible to format-string vulnerabilities.\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n  void incorrect_password(const char *user) {\n  int ret;\n  /* User names are restricted to 256 or fewer characters */\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  size_t len = strlen(user) + sizeof(msg_format);\n  char *msg = (char *)malloc(len);\n  if (msg == NULL) {\n    /* Handle error */\n  }\n  ret = snprintf(msg, len, msg_format, user);\n  if (ret < 0) { \n    /* Handle error */ \n  } else if (ret >= len) { \n    /* Handle truncated output */ \n  }\n  syslog(LOG_INFO, msg);\n  free(msg);\n}\nThe syslog() function first appeared in BSD 4.2 and is supported by Linux and other modern UNIX implementations. It is not available on Windows systems.\nCompliant Solution (POSIX)\nThis compliant solution passes the untrusted user input as one of the variadic arguments to syslog() instead of including it in the format string:\n#include <syslog.h>\n  void incorrect_password(const char *user) {\n  static const char msg_format[] = \"%s cannot be authenticated.\\n\";\n  syslog(LOG_INFO, msg_format, user);\n}\nRisk Assessment\nFailing to exclude user input from format specifiers may allow an attacker to crash a vulnerable process, view the contents of the stack, view memory content, or write to an arbitrary memory location and consequently execute arbitrary code with the permissions of the vulnerable process.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO30-C\nHigh\nLikely\nYes\nNo\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n  Supported via stubbing/taint analysis\nAxivion Bauhaus Suite\n7.2.0\nCertC-FIO30 Partially implemented\nCodeSonar\n9.1p0\nIO.INJ.FMT\nMISC.FMT\nFormat string injection\nFormat string\nCompass/ROSE\n\n\nCoverity\n2017.07\nTAINTED_STRING\nImplemented\nCppcheck Premium 24.11.0\n\npremium-cert-fio30-c\n\nGCC\n4.3.5\n\nCan detect violations of this rule when the -Wformat-security flag is used\nHelix QAC\n2025.2\nDF4916, DF4917, DF4918\n\nKlocwork\n2025.2\nSV.FMTSTR.GENERIC\nSV.TAINTED.FMTSTR\n\nLDRA tool suite\n9.7.1\n86 D\nPartially Implemented\nParasoft C/C++test 2024.2\nCERT_C-FIO30-a\nCERT_C-FIO30-b\nCERT_C-FIO30-c\nAvoid calling functions printf/wprintf with only one argument other than string constant\nAvoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable\nNever use unfiltered data from an untrusted user as the format parameter\nPC-lint Plus\n1.4\n592\nPartially supported: reports non-literal format strings\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO30-C\nChecks for tainted string format (rule partially covered)\nPVS-Studio\n7.38\nV618\nSplint\n3.1.1\n\n\nRelated Vulnerabilities\nTwo examples of format-string vulnerabilities resulting from a violation of this rule include Ettercap and Samba.\nIn Ettercap v.NG-0.7.2, the ncurses user interface suffers from a format-string defect. The curses_msg() function in ec_curses.c calls wdg_scroll_print(), which takes a format string and its parameters and passes it to vw_printw(). The curses_msg() function uses one of its parameters as the format string. This input can include user data, allowing for a format-string vulnerability.\nThe Samba AFS ACL mapping VFS plug-in fails to properly sanitize user-controlled file names that are used in a format specifier supplied to snprintf(). This security flaw becomes exploitable when a user can write to a share that uses Samba's afsacl.so library for setting Windows NT access control lists on files residing on an AFS file system.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT Oracle Secure Coding Standard for Java IDS06-J. Exclude unsanitized user input from format strings Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Perl Secure Coding Standard IDS30-PL. Exclude user input from format strings Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Injection [RST] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Including tainted or out-of-domain input in a format string [usrfmt] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-134, Uncontrolled Format String 2017-05-16: CERT: Exact\nCWE 2.11 CWE-20, Improper Input Validation 2017-05-17: CERT: Rule subset of CWE\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, syslog\n[Seacord 2013b] Chapter 6, \"Formatted Output\"\n[Viega 2005] Section 5.2.23, \"Format String Problem\"",
        "language": "C"
    },
    {
        "rule_id": "FIO40-C",
        "rule_title": "Reset strings on fgets() or fgetws() failure",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO40-C.+Reset+strings+on+fgets%28%29++or+fgetws%28%29+failure",
        "content": "If either of the C Standard fgets() or fgetws() functions fail, the contents of the array being written is indeterminate. (See undefined behavior 175.)  It is necessary to reset the string to a known value to avoid errors on subsequent string manipulation functions.\nNoncompliant Code Example\nIn this noncompliant code example, an error flag is set if fgets() fails. However, buf is not reset and has indeterminate contents:\n#include <stdio.h>\n  enum { BUFFER_SIZE = 1024 };\nvoid func(FILE *file) {\n  char buf[BUFFER_SIZE];\n   if (fgets(buf, sizeof(buf), file) == NULL) {\n    /* Set error flag and continue */\n  }\n}\nCompliant Solution\nIn this compliant solution, buf is set to an empty string if fgets() fails. The equivalent solution for fgetws() would set buf to an empty wide string.\n#include <stdio.h>\n  enum { BUFFER_SIZE = 1024 };\n void func(FILE *file) {\n  char buf[BUFFER_SIZE];\n   if (fgets(buf, sizeof(buf), file) == NULL) {\n    /* Set error flag and continue */\n    *buf = '\\0';\n  }\n}\nExceptions\nFIO40-C-EX1: If the string goes out of scope immediately following the call to fgets() or fgetws() or is not referenced in the case of a failure, it need not be reset.\nRisk Assessment\nMaking invalid assumptions about the contents of an array modified by fgets() or fgetws() can result in undefined behavior 175 and abnormal program termination.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO40-C\nLow\nProbable\nYes\nYes\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nLANG.MEM.UVAR\nUninitialized Variable\nCppcheck Premium\n24.11.0\npremium-cert-fio40-c\nHelix QAC\n2025.2\nDF4861, DF4862, DF4863\n\nLDRA tool suite\n9.7.1\n44 S Enhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-FIO40-a\nReset strings on fgets() or fgetws() failure\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO40-C Checks for use of indeterminate string (rule partially covered)\nPVS-Studio\n7.38\nV1024\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.",
        "language": "C"
    },
    {
        "rule_id": "FIO47-C",
        "rule_title": "Use valid format strings",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO47-C.+Use+valid+format+strings",
        "content": "The formatted output functions (fprintf() and related functions) convert, format, and print their arguments under control of a format string. The C Standard, 7.23.6.1, paragraph 3 [ISO/IEC 9899:2024], specifies\nThe format shall be a multibyte character sequence, beginning and ending in its initial shift state. The format is composed of zero or more directives: ordinary multibyte characters (not %), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments, converting them, if applicable, according to the corresponding conversion specifier, and then writing the result to the output stream.\nEach conversion specification is introduced by the % character followed (in order) by\nZero or more flags (in any order), which modify the meaning of the conversion specification\nAn optional minimum field width\nAn optional precision that gives the minimum number of digits, the maximum number of digits, or the maximum number of bytes, etc. depending on the conversion specifier\nAn optional length modifier that specifies the size of the argument\nA conversion specifier character that indicates the type of conversion to be applied\nCommon mistakes in creating format strings include\nProviding an incorrect number of arguments for the format string\nUsing invalid conversion specifiers\nUsing a flag character that is incompatible with the conversion specifier\nUsing a length modifier that is incompatible with the conversion specifier\nMismatching the argument type and conversion specifier\nUsing an argument of type other than int for width or precision\nThe following table summarizes the compliance of various conversion specifications. The first column contains one or more conversion specifier characters. The next four columns consider the combination of the specifier characters with the various flags (the apostrophe ['], -, +, the space character, #, and 0). The next eight columns consider the combination of the specifier characters with the various length modifiers (h, hh, l, ll, j, z, t, and L).\nValid combinations are marked with a type name; arguments matched with the conversion specification are interpreted as that type. For example, an argument matched with the specifier %hd is interpreted as a short, so short appears in the cell where d and h intersect. The last column denotes the expected types of arguments matched with the original specifier characters.\nValid and meaningful combinations are marked by the  symbol (save for the length modifier columns, as described previously). Valid combinations that have no effect are labeled N/E. Using a combination marked by the symbol, using a specification not represented in the table, or using an argument of an unexpected type is undefined behavior. (See undefined behaviors 158, 160, 162, 163, 166, and 167.) \nConversion\nSpecifier\nCharacter\n' XSI\n-\n+\nSPACE\n\n#\n\n0\n\nh\n\nhh\n\nl\n\nll\n\nj\n\nz\n\nt\n\nL\nArgument\nType\nd, i\nshort\nsigned char\nlong\nlong long\nintmax_t\nsize_t\nptrdiff_t\nSigned integer\no\nunsigned short\nunsigned char\nunsigned long\nunsigned long long\nuintmax_t\nsize_t\nptrdiff_t\nUnsigned integer\nu\nunsigned short\nunsigned  char\nunsigned long\nunsigned long long\nuintmax_t\nsize_t\nptrdiff_t\nUnsigned integer\nx, X\nunsigned short\nunsigned char\nunsigned long\nunsigned long long\nuintmax_t\nsize_t\nptrdiff_t\nUnsigned integer\nf, F\nN/E\nN/E\nlong double\ndouble or long double\ne, E\nN/E\nN/E\nlong double\ndouble or long double\ng, G\nN/E\nN/E\nlong double\ndouble or long double\na, A\nN/E\nN/E\nlong double\ndouble or long double\nc\nwint_t\nint or wint_t\ns\nNTWS\nNTBS or NTWS\np\nvoid*\nn\nshort*\nchar*\nlong*\nlong long*\nintmax_t*\nsize_t*\nptrdiff_t*\nPointer to integer\nC XSI\nwint_t\nS XSI\nNTWS\n%\nNone\n     SPACE: The space (\" \") character\n     N/E: No effect\n     NTBS: char* argument pointing to a null-terminated character string\n     NTWS: wchar_t* argument pointing to a null-terminated wide character string\n     XSI: ISO/IEC 9945-2003 XSI extension\nThe formatted input functions (fscanf() and related functions) use similarly specified format strings and impose similar restrictions on their format strings and arguments.\nDo not supply an unknown or invalid conversion specification or an invalid combination of flag character, precision, length modifier, or conversion specifier to a formatted IO function. Likewise, do not provide a number or type of argument that does not match the argument type of the conversion specifier used in the format string.\nFormat strings are usually string literals specified at the call site, but they need not be. However, they should not contain tainted values. (See FIO30-C. Exclude user input from format strings for more information.)\nNoncompliant Code Example\nMismatches between arguments and conversion specifications may result in undefined behavior 163. Compilers may diagnose type mismatches in formatted output function invocations. In this noncompliant code example, the error_type argument to printf() is incorrectly matched with the s specifier rather than with the d specifier. Likewise, the error_msg argument is incorrectly matched with the d specifier instead of the s specifier. These usages result in undefined behavior 163. One possible result of this invocation is that printf() will interpret the error_type argument as a pointer and try to read a string from the address that error_type contains, possibly resulting in an access violation.\n#include <stdio.h>\n \nvoid func(void) {\n  const char *error_msg = \"Resource not available to user.\";\n  int error_type = 3;\n  /* ... */\n  printf(\"Error (type %s): %d\\n\", error_type, error_msg);\n  /* ... */\n}\nCompliant Solution\nThis compliant solution ensures that the arguments to the printf() function match their respective conversion specifications:\n#include <stdio.h>\n \nvoid func(void) {\n  const char *error_msg = \"Resource not available to user.\";\n  int error_type = 3;\n  /* ... */\n  printf(\"Error (type %d): %s\\n\", error_type, error_msg);\n\n  /* ... */\n}\nRisk Assessment\nIncorrectly specified format strings can result in memory corruption or abnormal program termination.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO47-C\nHigh\nUnlikely\nYes\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAxivion Bauhaus Suite\n7.2.0\nCertC-FIO47 Fully implemented\nCodeSonar\n9.1p0\nIO.INJ.FMT\nMISC.FMT\nMISC.FMTTYPE\nFormat string injection\nFormat string\nFormat string type error\nCoverity\n2017.07\nPW Reports when the number of arguments differs from the number of required arguments according to the format string\nCppcheck\n  2.15\ninvalidscanf\nwrongPrintfScanfArgNum\ninvalidLengthModifierError\ninvalidScanfFormatWidth\nwrongPrintfScanfParameterPositionError\nCppcheck Premium\n24.11.0\ninvalidscanf\nwrongPrintfScanfArgNum\ninvalidLengthModifierError\ninvalidScanfFormatWidth\nwrongPrintfScanfParameterPositionError\nGCC\n4.3.5\n\nCan detect violations of this recommendation when the -Wformat flag is used\nHelix QAC\n2025.2\nC0161, C0162, C0163, C0164, C0165, C0166, C0167, C0168, C0169, C0170, C0171, C0172, C0173, C0174, C0175, C0176, C0177, C0178, C0179, C0180, C0184, C0185, C0190, C0191, C0192, C0193, C0194, C0195, C0196, C0197, C0198, C0199, C0200, C0201, C0202, C0204, C0206, C0209\nC++3150, C++3151, C++3152, C++3153, C++3154, C++3155, C++3156, C++3157, C++3158, C++3159\n\nKlocwork\n2025.2\nSV.FMT_STR.PRINT_FORMAT_MISMATCH.BAD\nSV.FMT_STR.PRINT_FORMAT_MISMATCH.UNDESIRED\nSV.FMT_STR.PRINT_IMPROP_LENGTH\nSV.FMT_STR.PRINT_PARAMS_WRONGNUM.FEW\nSV.FMT_STR.PRINT_PARAMS_WRONGNUM.MANY\nSV.FMT_STR.SCAN_FORMAT_MISMATCH.BAD\nSV.FMT_STR.SCAN_FORMAT_MISMATCH.UNDESIRED\nSV.FMT_STR.SCAN_IMPROP_LENGTH\nSV.FMT_STR.SCAN_PARAMS_WRONGNUM.FEW\nSV.FMT_STR.SCAN_PARAMS_WRONGNUM.MANY\nSV.FMT_STR.UNKWN_FORMAT\n\n\nLDRA tool suite\n9.7.1\n486 S\n589 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO47-a\nCERT_C-FIO47-b\nCERT_C-FIO47-c\nCERT_C-FIO47-d\nCERT_C-FIO47-e\nCERT_C-FIO47-f\nThere should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function\nThere should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function\nThere should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function\nThere should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function\nThere should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function\nThe number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal\nPC-lint Plus\n1.4\n492, 493, 494, 499, 557,\n558, 559, 566, 705, 706,\n719, 816, 855, 2401, 2402,\n2403, 2404, 2405, 2406, 2407\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO47-C\nCheck for format string specifiers and arguments mismatch (rule fully covered)\nPVS-Studio\n7.38\nV510, V576\nSecurity Reviewer - Static Reviewer\n6.02\nC81\nC82\nC83\nC83\nC84\nC85\nC86\nC86\n\nTrustInSoft Analyzer\n1.38\nmatch format and arguments Exhaustively verified (see the compliant and the non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C FIO00-CPP. Take care when creating format strings Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Using invalid format strings [invfmtstr] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-686, Function Call with Incorrect Argument Type 2017-06-29: CERT: Partial overlap\nCWE 2.11 CWE-685 2017-06-29: CERT: Partial overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-686 and FIO47-C\nIntersection( EXP37-C, FIO47-C) =\n\nInvalid argument types passed to format I/O function\n\nEXP37-C \u2013 FIO47-C =\n\nInvalid argument types passed to non-format I/O function\n\nFIO47-C \u2013 EXP37-C =\n\nInvalid format string, but correctly matches arguments in number and type\n\nIntersection( CWE-686, FIO47-C) =\n\nUse of format strings that do not match the type of arguments\n\nCWE-686 \u2013 FIO47-C =\n\nIncorrect argument type in functions outside of the printf() family.\n\nFIO47-C \u2013 CWE-686 =\n\nInvalid format strings that still match their arguments in type\n\nCWE-685 and FIO47-C\nIntersection( CWE-685, FIO47-C) =\n\nUse of format strings that do not match the number of arguments\n\nCWE-685 \u2013 FIO47-C =\n\nIncorrect argument number in functions outside of the printf() family.\n\nFIO47-C \u2013 CWE-685 =\n\nInvalid format strings that still match their arguments in number\n\nCWE-134 and FIO47-C\nIntersection( FIO30-C, FIO47-C) =\n\nUse of untrusted and ill-specified format string\n\nFIO30-C \u2013 FIO47-C =\n\nUse of untrusted, but well-defined format string\n\nFIO47-C \u2013 FIO30-C =\n\nUse of Ill-defined, but trusted format string\n\nFIO47-C = Union(CWE-134, list) where list =\n\nUsing a trusted but invalid format string\n\nBibliography\n[ISO/IEC 9899:2024] Subclause 7.23.6.1, \"The fprintf Function\"",
        "language": "C"
    },
    {
        "rule_id": "INT07-C",
        "rule_title": "Use only explicitly signed or unsigned char type for numeric values",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT07-C.+Use+only+explicitly+signed+or+unsigned+char+type+for+numeric+values",
        "content": "The three types char, signed char, and unsigned char are collectively called the character types. Compilers have the latitude to define char to have the same range, representation, and behavior as either signed char or unsigned char. Irrespective of the choice made, char is a separate type from the other two and is not compatible with either.\nUse only signed char and unsigned char types for the storage and use of numeric values because it is the only portable way to guarantee the signedness of the character types (see STR00-C. Represent characters using an appropriate type for more information on representing characters).\nNoncompliant Code Example\nIn this noncompliant code example, the char-type variable c may be signed or unsigned. Assuming 8-bit, two's complement character types, this code may print out either i/c = 5 (unsigned) or i/c = -17 (signed). It is much more difficult to reason about the correctness of a program without knowing if these integers are signed or unsigned.\nchar c = 200;\nint i = 1000;\nprintf(\"i/c = %d\\n\", i/c);\nCompliant Solution\nIn this compliant solution, the variable c is declared as unsigned char. The subsequent division operation is now independent of the signedness of char and consequently has a predictable result.\nunsigned char c = 200;\nint i = 1000;\nprintf(\"i/c = %d\\n\", i/c);\nExceptions\nINT07-C-EX1: void FIO34-C. Use int to capture the return value of character IO functions that might be used to check for end of file mentions that certain character IO functions return a value of type int. Despite being returned in an arithmetic type, the value is not actually numeric in nature, so it is acceptable to later store the result into a variable of type char.\nRisk Assessment\nThis is a subtle error that results in a disturbingly broad range of potentially severe vulnerabilities. At the very least, this error can lead to unexpected numerical results on different platforms. Unexpected arithmetic values when applied to arrays or pointers can yield buffer overflows or other invalid memory access.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT07-C\nMedium\nProbable\nYes\nYes\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported indirectly via MISRA C:2012 rules 10.1, 10.3 and 10.4.\nAxivion Bauhaus Suite\n7.2.0\nCertC-INT07\nCodeSonar\n9.1p0\nLANG.TYPE.IOT Inappropriate operand type\nCompass/ROSE\n\n\nCan detect violations of this recommendation. In particular, it flags any instance of a variable of type char (without a signed or unsigned qualifier) that appears in an arithmetic expression\nECLAIR\n1.2\nCC2.INT07\nFully implemented\nHelix QAC\n2025.2\nC1292, C1293, C4401, C4421, C4431, C4441, C4451\n\nKlocwork\n2025.2\nPORTING.SIGNED.CHAR\nLDRA tool suite\n9.7.1\n93 S, 96 S, 101 S, 329 S, 432 S, 458 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-INT07-a\nCERT_C-INT07-b\nThe plain char type shall be used only for the storage and use of character values\nsigned and unsigned char type shall be used only for the storage and use of numeric values\nPC-lint Plus\n1.4\n9112\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. INT07-C\n\nChecks for use of plain char type for numeric value (rec. fully covered)\nSplint\n3.1.1\n\n\nRuleChecker\n24.04\n\nSupported indirectly via MISRA C:2012 rules 10.1, 10.3 and 10.4.\nSonarQube C/C++ Plugin\n3.11\nS820\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID INT07-CPP. Use only explicitly signed or unsigned char type for numeric values\nISO/IEC TR 24772:2013 Bit Representations [STR]\nMISRA C:2012 Rule 10.1 (required)\nRule 10.3 (required)\nRule 10.4 (required)\nMITRE CWE CWE-682, Incorrect calculation",
        "language": "C"
    },
    {
        "rule_id": "POS30-C",
        "rule_title": "Use the readlink() function properly",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS30-C.+Use+the+readlink%28%29+function+properly",
        "content": "The readlink() function reads where a link points to. It makes no effort to null-terminate its second argument, buffer. Instead, it just returns the number of characters it has written.\nNoncompliant Code Example\nIf len is equal to sizeof(buf), the null terminator is written 1 byte past the end of buf:\nchar buf[1024];\nssize_t len = readlink(\"/usr/bin/perl\", buf, sizeof(buf));\nbuf[len] = '\\0';\nAn incorrect solution to this problem is to try to make buf large enough that it can always hold the result:\nlong symlink_max;\nsize_t bufsize;\nchar *buf;\nssize_t len;\n errno = 0;\nsymlink_max = pathconf(\"/usr/bin/\", _PC_SYMLINK_MAX);\nif (symlink_max == -1) {\n  if (errno != 0) {\n    /* handle error condition */\n  }\n  bufsize = 10000;\n}\nelse {\n  bufsize = symlink_max+1;\n}\n buf = (char *)malloc(bufsize);\nif (buf == NULL) {\n  /* handle error condition */\n}\n len = readlink(\"/usr/bin/perl\", buf, bufsize);\nbuf[len] = '\\0';\nThis modification incorrectly assumes that the symbolic link cannot be longer than the value of SYMLINK_MAX returned by pathconf(). However, the value returned by pathconf() is out of date by the time readlink() is called, so the off-by-one buffer-overflow risk is still present because, between the two calls, the location of /usr/bin/perl can change to a file system with a larger SYMLINK_MAX value. Also, if SYMLINK_MAX is indeterminate (that is, if pathconf() returned -1 without setting errno), the code uses an arbitrary large buffer size (10,000) that it hopes will be sufficient, but there is a small chance that readlink() can return exactly this size.\nAn additional issue is that readlink() can return -1 if it fails, causing an off-by-one underflow.\nCompliant Solution\nThis compliant solution ensures there is no overflow by reading in only sizeof(buf)-1 characters. It also properly checks to see if an error has occurred:\nenum { BUFFERSIZE = 1024 };\nchar buf[BUFFERSIZE];\nssize_t len = readlink(\"/usr/bin/perl\", buf, sizeof(buf)-1);\n if (len != -1) {\n  buf[len] = '\\0';\n}\nelse {\n  /* handle error condition */\n}\nRisk Assessment\nFailing to properly null-terminate the result of readlink() can result in abnormal program termination and buffer-overflow vulnerabilities.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS30-C\nHigh\nProbable\nYes\nYes\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported: Can be checked with appropriate analysis stubs.\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS30\nCodeSonar\n9.1p0\nLANG.MEM.BO\nLANG.MEM.TBA\nMISC.MEM.NTERM.CSTRING\nBuffer Overrun\nTainted Buffer Access\nUnterminated C String\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nREADLINK\nImplemented\nHelix QAC\n2025.2\nC5033\nKlocwork\n2025.2\nABV.GENERAL\nABV.GENERAL.MULTIDIMENSION\n\nParasoft C/C++test\n2024.2\nCERT_C-POS30-a\nCERT_C-POS30-b\nCERT_C-POS30-c\nAvoid overflow due to reading a not zero terminated string\nThe values returned by functions 'read' and 'readlink' shall be used\nUse of possibly not null-terminated string with functions expecting null-terminated string\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS30-C Checks for misuse of readlink() (rule partially covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCWE 2.11 CWE-170, Improper null termination 2017-06-13: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-170 and POS30-C\nCWE-170 = Union( POS30-C, list) where list =\n\nNon-null terminated strings fed to functions other than POSIX readlink()\n\nBibliography\n[Ilja 2006]\n[Open Group 1997a]\n[Open Group 2004]",
        "language": "C"
    },
    {
        "rule_id": "MEM30-C",
        "rule_title": "Do not access freed memory",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory",
        "content": "Evaluating a pointer\u2014including dereferencing the pointer, using it as an operand of an arithmetic operation, type casting it, and using it as the right-hand side of an assignment\u2014into memory that has been deallocated by a memory management function is undefined behavior 183. Pointers to memory that has been deallocated are called dangling pointers. Accessing a dangling pointer can result in exploitable vulnerabilities.\nAccording to the C Standard, using the value of a pointer that refers to space deallocated by a call to the free() or realloc() function is undefined behavior. (See undefined behavior 183.)\nReading a pointer to deallocated memory is undefined behavior 183 because the pointer value is indeterminate and might be a trap representation. Fetching a trap representation might perform a hardware trap (but is not required to).\nIt is at the memory manager's discretion when to reallocate or recycle the freed memory. When memory is freed, all pointers into it become invalid, and its contents might either be returned to the operating system, making the freed space inaccessible, or remain intact and accessible. As a result, the data at the freed location can appear to be valid but change unexpectedly. Consequently, memory must not be written to or read from once it is freed.\nNoncompliant Code Example\nThis example from Brian Kernighan and Dennis Ritchie [Kernighan 1988] shows both the incorrect and correct techniques for freeing the memory associated with a linked list. In their (intentionally) incorrect example, p is freed before p->next is executed, so that p->next reads memory that has already been freed.\n#include <stdlib.h>\n  struct node {\n  int value;\n  struct node *next;\n};\n  void free_list(struct node *head) {\n  for (struct node *p = head; p != NULL; p = p->next) {\n    free(p);\n  }\n}\nCompliant Solution\nKernighan and Ritchie correct this error by storing a reference to p->next  in q before freeing p:\n#include <stdlib.h>\n  struct node {\n  int value;\n  struct node *next;\n};\n  void free_list(struct node *head) {\n  struct node *q;\n  for (struct node *p = head; p != NULL; p = q) {\n    q = p->next;\n    free(p);\n  }\n}\nNoncompliant Code Example\nIn this noncompliant code example, buf is written to after it has been freed. Write-after-free vulnerabilities can be exploited to run arbitrary code with the permissions of the vulnerable process. Typically, allocations and frees are far removed, making it difficult to recognize and diagnose these problems.\n#include <stdlib.h>\n#include <string.h>\n int main(int argc, char *argv[]) {\n  char *return_val = 0;\n  const size_t bufsize = strlen(argv[0]) + 1;\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    return EXIT_FAILURE;\n  }\n  /* ... */\n  free(buf);\n  /* ... */\n  strcpy(buf, argv[0]);\n  /* ... */\n  return EXIT_SUCCESS;\n}\nCompliant Solution\nIn this compliant solution, the memory is freed after its final use:\n#include <stdlib.h>\n#include <string.h>\n int main(int argc, char *argv[]) {\n  char *return_val = 0;\n  const size_t bufsize = strlen(argv[0]) + 1;\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    return EXIT_FAILURE;\n  }\n  /* ... */\n  strcpy(buf, argv[0]);\n  /* ... */\n  free(buf);\n  return EXIT_SUCCESS;\n}\nNoncompliant Code Example\nIn this noncompliant example, realloc() may free c_str1 when it returns a null pointer, resulting in c_str1 being freed twice.  The C Standards Committee's proposed response to Defect Report #400 makes it implementation-defined whether or not the old object is deallocated when size is zero and memory for the new object is not allocated. The current implementation of realloc() in the GNU C Library and Microsoft Visual Studio's Runtime Library will free c_str1 and return a null pointer for zero byte allocations.  Freeing a pointer twice can result in a potentially exploitable vulnerability commonly referred to as a double-free vulnerability [Seacord 2013b].\n#include <stdlib.h>\n  void f(char *c_str1, size_t size) {\n  char *c_str2 = (char *)realloc(c_str1, size);\n  if (c_str2 == NULL) {\n    free(c_str1);\n  }\n}\nCompliant Solution\nThis compliant solution does not pass a size argument of zero to the realloc() function, eliminating the possibility of c_str1 being freed twice:\n#include <stdlib.h>\n  void f(char *c_str1, size_t size) {\n  if (size != 0) {\n    char *c_str2 = (char *)realloc(c_str1, size);\n    if (c_str2 == NULL) {\n      free(c_str1);\n    }\n  }\n  else {\n    free(c_str1);\n  }\n  }\nIf the intent of calling f() is to reduce the size of the object, then doing nothing when the size is zero would be unexpected; instead, this compliant solution frees the object.\nNoncompliant Code Example\nIn this noncompliant example (CVE-2009-1364) from libwmf version 0.2.8.4, the return value of gdRealloc (a simple wrapper around realloc() that reallocates space pointed to by im->clip->list) is set to more. However, the value of im->clip->list is used directly afterwards in the code, and the C Standard specifies that if realloc() moves the area pointed to, then the original block is freed. An attacker can then execute arbitrary code by forcing a reallocation (with a sufficient im->clip->count) and accessing freed memory [xorl 2009].\nvoid gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) {\n  gdClipRectanglePtr more;\n  if (im->clip == 0) {\n   /* ... */\n  }\n  if (im->clip->count == im->clip->max) {\n    more = gdRealloc (im->clip->list,(im->clip->max + 8) *\n                      sizeof (gdClipRectangle));\n    /*\n     * If the realloc fails, then we have not lost the\n     * im->clip->list value.\n     */\n    if (more == 0) return;\n    im->clip->max += 8;\n  }\n  im->clip->list[im->clip->count] = *rect;\n  im->clip->count++;\n }\nCompliant Solution\nThis compliant solution simply reassigns im->clip->list to the value of more after the call to realloc():\nvoid gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) {\n  gdClipRectanglePtr more;\n  if (im->clip == 0) {\n    /* ... */\n  }\n  if (im->clip->count == im->clip->max) {\n    more = gdRealloc (im->clip->list,(im->clip->max + 8) *\n                      sizeof (gdClipRectangle));\n    if (more == 0) return;\n    im->clip->max += 8;\n    im->clip->list = more;\n  }\n  im->clip->list[im->clip->count] = *rect;\n  im->clip->count++;\n }\nRisk Assessment\nReading memory that has already been freed can lead to abnormal program termination and denial-of-service attacks. Writing memory that has already been freed can additionally lead to the execution of arbitrary code with the permissions of the vulnerable process. \nFreeing memory multiple times has similar consequences to accessing memory after it is freed. Reading a pointer to deallocated memory is undefined behavior 183 because the pointer value is indeterminate and might be a trap representation. When reading from or writing to freed memory does not cause a trap, it may corrupt the underlying data structures that manage the heap in a manner that can be exploited to execute arbitrary code. Alternatively, writing to memory after it has been freed might modify memory that has been reallocated.\nProgrammers should be wary when freeing memory in a loop or conditional statement; if coded incorrectly, these constructs can lead to double-free vulnerabilities. It is also a common error to misuse the realloc() function in a manner that results in double-free vulnerabilities. (See MEM04-C. Beware of zero-length allocations.)\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMEM30-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ndangling_pointer_use\nSupported\nAstr\u00e9e reports all accesses to freed allocated memory.\nAxivion Bauhaus Suite\n7.2.0\nCertC-MEM30 Detects memory accesses after its deallocation and double memory deallocations\nCodeSonar\n9.1p0\nALLOC.UAF\nUse after free\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nUSE_AFTER_FREE\nCan detect the specific instances where memory is deallocated more than once or read/written to the target of a freed pointer\nCppcheck\n 2.15\ndoubleFree\ndeallocret\ndeallocuse\nCppcheck Premium\n24.11.0\ndoubleFree\ndeallocret\ndeallocuse\nHelix QAC\n2025.2\nDF4866, DF4867, DF4868, DF4871, DF4872, DF4873\nC++3339, C++4303, C++4304\n\nKlocwork\n2025.2\nUFM.DEREF.MIGHT\nUFM.DEREF.MUST\nUFM.FFM.MIGHT\nUFM.FFM.MUST\nUFM.RETURN.MIGHT\nUFM.RETURN.MUST\nUFM.USE.MIGHT\nUFM.USE.MUST\n\nLDRA tool suite\n9.7.1\n51 D, 484 S, 112 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-MEM30-a\nDo not use resources that have been freed\nParasoft Insure++\n\nRuntime analysis\nPC-lint Plus\n1.4\n449, 2434\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MEM30-C\nChecks for:\nAccessing previously freed pointer\nFreeing previously freed pointer\nRule partially covered.\nPVS-Studio\n7.38\nV586, V774\nSecurity Reviewer - Static Reviewer\n6.02\nCPP_12 Fully implemented\nSplint\n3.1.1\n\n\nTrustInSoft Analyzer\n1.38\ndangling_pointer\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nVU#623332 describes a double-free vulnerability in the MIT Kerberos 5 function krb5_recvauth(). \nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard MEM01-C. Store a new value in pointers immediately after free() Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C MEM50-CPP. Do not access freed memory Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Dangling References to Stack Frames [DCM] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Dangling Reference to Heap [XYK] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Accessing freed memory [accfree] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Freeing memory multiple times [dblfree] Prior to 2018-01-12: CERT: Unspecified Relationship\nMISRA C:2012 Rule 18.6 (required) Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-416, Use After Free 2017-07-07: CERT: Exact\nCWE 2.11 CWE-672 2017-07-07: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-672 and MEM30-C\nIntersection( MEM30-C, FIO46-C) = \u00d8 CWE-672 = Union( MEM30-C, list) where list =\n\nUse of a resource, other than memory after it has been released (eg: reusing a closed file, or expired mutex)\n\nCWE-666 and MEM30-C\nIntersection( MEM30-C, FIO46-C) = \u00d8\nCWE-672 = Subset( CWE-666)\nCWE-758 and MEM30-C\nCWE-758 = Union( MEM30-C, list) where list =\n\nUndefined behavior that is not covered by use-after-free errors\n\nCWE-415 and MEM30-C\nMEM30-C = Union( CWE-456, list) where list =\n\nDereference of a pointer after freeing it (besides passing it to free() a second time)\n\nBibliography\n[ISO/IEC 9899:2024] 7.24.3, \"Memory Management Functions\"\n[Kernighan 1988] Section 7.8.5, \"Storage Management\"\n[OWASP Freed Memory]\n[MIT 2005]\n[Seacord 2013b] Chapter 4, \"Dynamic Memory Management\"\n[Viega 2005] Section 5.2.19, \"Using Freed Memory\"\n[VU#623332]\n[xorl 2009] CVE-2009-1364: LibWMF Pointer Use after free()",
        "language": "C"
    },
    {
        "rule_id": "MEM31-C",
        "rule_title": "Free dynamically allocated memory when no longer needed",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MEM31-C.+Free+dynamically+allocated+memory+when+no+longer+needed",
        "content": "Before the lifetime of the last pointer that stores the return value of a call to a standard memory allocation function has ended, it must be matched by a call to free() with that pointer value.\nNoncompliant Code Example\nIn this noncompliant example, the object allocated by the call to malloc() is not freed before the end of the lifetime of the last pointer text_buffer referring to the object:\n#include <stdlib.h>\n  enum { BUFFER_SIZE = 32 };\n int f(void) {\n  char *text_buffer = (char *)malloc(BUFFER_SIZE);\n  if (text_buffer == NULL) {\n    return -1;\n  }\n  return 0;\n}\nCompliant Solution\nIn this compliant solution, the pointer is deallocated with a call to free():\n#include <stdlib.h>\n enum { BUFFER_SIZE = 32 };\n int f(void) {\n  char *text_buffer = (char *)malloc(BUFFER_SIZE);\n  if (text_buffer == NULL) {\n    return -1;\n  }\n    free(text_buffer);\n  return 0;\n}\nExceptions\nMEM31-C-EX1: Allocated memory does not need to be freed if it is assigned to a pointer whose lifetime includes program termination. The following code example illustrates a pointer that stores the return value from malloc() in a static variable:\n#include <stdlib.h>\n  enum { BUFFER_SIZE = 32 };\n int f(void) {\n  static char *text_buffer = NULL;\n  if (text_buffer == NULL) {\n    text_buffer = (char *)malloc(BUFFER_SIZE);\n    if (text_buffer == NULL) {\n      return -1;\n    }\n  }\n  return 0;\n}\nRisk Assessment\nFailing to free memory can result in the exhaustion of system memory resources, which can lead to a denial-of-service attack.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMEM31-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nAxivion Bauhaus Suite\n7.2.0\nCertC-MEM31 Can detect dynamically allocated resources that are not freed\nCodeSonar\n9.1p0\nALLOC.LEAK\nLeak\nCompass/ROSE\n\n\nCoverity\n2017.07\nRESOURCE_LEAK\nALLOC_FREE_MISMATCH\nFinds resource leaks from variables that go out of scope while owning a resource\nCppcheck\n  2.15\nmemleak\nleakReturnValNotUsed\nleakUnsafeArgAlloc\nmemleakOnRealloc\nCppcheck Premium\n24.11.0\nmemleak\nleakReturnValNotUsed\nleakUnsafeArgAlloc\nmemleakOnRealloc\nHelix QAC\n2025.2\nDF2706, DF2707, DF2708\nC++3337, C++3338\n\nKlocwork\n2025.2\nCL.FFM.ASSIGN\nCL.FFM.COPY\nCL.SHALLOW.ASSIGN\nCL.SHALLOW.COPY\nFMM.MIGHT\nFMM.MUST\nLDRA tool suite\n9.7.1\n50 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-MEM31-a\nEnsure resources are freed\nParasoft Insure++\n\nRuntime analysis\nPC-lint Plus\n1.4\n429\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MEM31-C Checks for memory leak (rule fully covered)\n\nPVS-Studio\n7.38\nV773\nSecurity Reviewer - Static Reviewer\n6.02\nCPP_17\nCPP_18\nCPP_22\nCPP_23\nCPP_24\nCPP_25\nCPP_26\nCPP_27\nFully implemented\nSonarQube C/C++ Plugin\n3.11\nS3584\nSplint\n3.1.1\n\n\nTrustInSoft Analyzer\n1.38\nmalloc Exhaustively verified.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TR 24772:2013 Memory Leak [XYL] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Failing to close files or free dynamic memory when they are no longer needed [fileclose] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-401, Improper Release of Memory Before Removing Last Reference (\"Memory Leak\") 2017-07-05: CERT: Exact\nCWE 2.11 CWE-404 2017-07-06: CERT: Rule subset of CWE\nCWE 2.11 CWE-459 2017-07-06: CERT: Rule subset of CWE\nCWE 2.11 CWE-771 2017-07-06: CERT: Rule subset of CWE\nCWE 2.11 CWE-772 2017-07-06: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-404/CWE-459/CWE-771/CWE-772 and FIO42-C/MEM31-C\nIntersection( FIO42-C, MEM31-C) = \u00d8\nCWE-404 = CWE-459 = CWE-771 = CWE-772\nCWE-404 = Union( FIO42-C, MEM31-C list) where list =\nFailure to free resources besides files or memory chunks, such as mutexes)\nBibliography\n[ISO/IEC 9899:2024] Subclause 7.24.3, \"Memory Management Functions\"",
        "language": "C"
    },
    {
        "rule_id": "MEM34-C",
        "rule_title": "Only free memory allocated dynamically",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MEM34-C.+Only+free+memory+allocated+dynamically",
        "content": "The C Standard, Annex J (184) [ISO/IEC 9899:2024], states that the behavior of a program is undefined when\nThe pointer argument to the free or realloc function does not match a pointer earlier returned by a memory management function, or the space has been deallocated by a call to free or realloc.\nSee also undefined behavior 184.\nFreeing memory that is not allocated dynamically can result in heap corruption and other serious errors. Do not call free() on a pointer other than one returned by a standard memory allocation function, such as malloc(), calloc(), realloc(), or aligned_alloc().\nA similar situation arises when realloc() is supplied a pointer to non-dynamically allocated memory. The realloc() function is used to resize a block of dynamic memory. If realloc() is supplied a pointer to memory not allocated by a standard memory allocation function, the behavior is undefined. One consequence is that the program may terminate abnormally.\nThis rule does not apply to null pointers. The C Standard guarantees that if free() is passed a null pointer, no action occurs.\nNoncompliant Code Example\nThis noncompliant code example sets c_str to reference either dynamically allocated memory or a statically allocated string literal depending on the value of argc. In either case, c_str is passed as an argument to free(). If anything other than dynamically allocated memory is referenced by c_str, the call to free(c_str) is erroneous.\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n  enum { MAX_ALLOCATION = 1000 };\n int main(int argc, const char *argv[]) {\n  char *c_str = NULL;\n  size_t len;\n   if (argc == 2) {\n    len = strlen(argv[1]) + 1;\n    if (len > MAX_ALLOCATION) {\n      /* Handle error */\n    }\n    c_str = (char *)malloc(len);\n    if (c_str == NULL) {\n      /* Handle error */\n    }\n    strcpy(c_str, argv[1]);\n  } else {\n    c_str = \"usage: $>a.exe [string]\";\n    printf(\"%s\\n\", c_str);\n  }\n  free(c_str);\n  return 0;\n}\nCompliant Solution\nThis compliant solution eliminates the possibility of c_str referencing memory that is not allocated dynamically when passed to free():\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n  enum { MAX_ALLOCATION = 1000 };\n int main(int argc, const char *argv[]) {\n  char *c_str = NULL;\n  size_t len;\n   if (argc == 2) {\n    len = strlen(argv[1]) + 1;\n    if (len > MAX_ALLOCATION) {\n      /* Handle error */\n    }\n    c_str = (char *)malloc(len);\n    if (c_str == NULL) {\n      /* Handle error */\n    }\n    strcpy(c_str, argv[1]);\n  } else {\n    printf(\"%s\\n\", \"usage: $>a.exe [string]\");\n    return EXIT_FAILURE;\n  }\n  free(c_str);\n  return 0;\n}\nNoncompliant Code Example (realloc())\nIn this noncompliant example, the pointer parameter to realloc(), buf, does not refer to dynamically allocated memory:\n#include <stdlib.h>\n  enum { BUFSIZE = 256 };\n  void f(void) {\n  char buf[BUFSIZE];\n  char *p = (char *)realloc(buf, 2 * BUFSIZE);\n  if (p == NULL) {\n    /* Handle error */\n  }\n}\nCompliant Solution (realloc())\nIn this compliant solution, buf refers to dynamically allocated memory:\n#include <stdlib.h>\n  enum { BUFSIZE = 256 };\n  void f(void) {\n  char *buf = (char *)malloc(BUFSIZE * sizeof(char));\n  char *p = (char *)realloc(buf, 2 * BUFSIZE);\n  if (p == NULL) {\n    /* Handle error */\n  }\n}\nNote that realloc() will behave properly even if malloc() failed, because when given a null pointer, realloc() behaves like a call to malloc().\nRisk Assessment\nThe consequences of this error depend on the implementation, but they range from nothing to arbitrary code execution if that memory is reused by malloc(). \nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMEM34-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ninvalid-free\nFully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-MEM34 Can detect memory deallocations for stack objects\nClang\n3.9\nclang-analyzer-unix.Malloc Checked by clang-tidy; can detect some instances of this rule, but does not detect all\nCodeSonar\n9.1p0\nALLOC.TM\nType Mismatch\nCompass/ROSE\n\nCan detect some violations of this rule\nCoverity\n2017.07\nBAD_FREE\nIdentifies calls to free() where the argument is a pointer to a function or an array. It also detects the cases where\nfree() is used on an address-of expression, which can never be heap allocated. Coverity Prevent cannot discover all\nviolations of this rule, so further verification is necessary\nCppcheck\n 2.15\nautovarInvalidDeallocation\nmismatchAllocDealloc\nCppcheck Premium\n24.11.0\nautovarInvalidDeallocation\nmismatchAllocDealloc\nHelix QAC\n2025.2\nDF2721, DF2722, DF2723\n\nKlocwork\n2025.2\nFNH.MIGHT\nFNH.MUST\nLDRA tool suite\n9.7.1\n407 S, 483 S, 644 S, 645 S, 125 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-MEM34-a\nDo not free resources using invalid pointers\nParasoft Insure++\n\nRuntime analysis\nPC-lint Plus\n1.4\n424, 673\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MEM34-C\n\nChecks for:\nInvalid free of pointer\nInvalid reallocation of pointer\nRule fully covered.\nPVS-Studio\n7.38\nV585, V726\nRuleChecker\n24.04\ninvalid-free\nPartially checked\nSecurity Reviewer - Static Reviewer\n6.02\nCPP_31\nCPP_32\nCPP_33\nCPP_34\nCPP_35\nCPP_36\nFully implemented\nTrustInSoft Analyzer\n1.38\nunclassified (\"free expects a free-able address\")\nExhaustively verified (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nCVE-2015-0240 describes a vulnerability in which an uninitialized pointer is passed to TALLOC_FREE(), which is a Samba-specific memory deallocation macro that wraps the talloc_free() function. The implementation of  talloc_free() would access the uninitialized pointer, resulting in a remote exploit.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard MEM31-C. Free dynamically allocated memory when no longer needed Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C MEM51-CPP. Properly deallocate dynamically allocated resources Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Reallocating or freeing memory that was not dynamically allocated [xfree] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-590, Free of Memory Not on the Heap 2017-07-10: CERT: Exact\nBibliography\n[ISO/IEC 9899:2024] Subclause J.2, \"Undefined Behavior\"\n[Seacord 2013b] Chapter 4, \"Dynamic Memory Management\"",
        "language": "C"
    },
    {
        "rule_id": "MEM35-C",
        "rule_title": "Allocate sufficient memory for an object",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MEM35-C.+Allocate+sufficient+memory+for+an+object",
        "content": "The types of integer expressions used as size arguments to malloc(), calloc(), realloc(), or aligned_alloc() must have sufficient range to represent the size of the objects to be stored. If size arguments are incorrect or can be manipulated by an attacker, then a buffer overflow may occur. Incorrect size arguments, inadequate range checking, integer overflow, or truncation can result in the allocation of an inadequately sized buffer.\nTypically, the amount of memory to allocate will be the size of the type of object to allocate. When allocating space for an array, the size of the object will be multiplied by the bounds of the array. When allocating space for a structure containing a flexible array member, the size of the array member must be added to the size of the structure. (See MEM33-C. Allocate and copy structures containing a flexible array member dynamically.) Use the correct type of the object when computing the size of memory to allocate.\nSTR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator is a specific instance of this rule.\nNoncompliant Code Example (Pointer)\nIn this noncompliant code example, inadequate space is allocated for a struct tm object because the size of the pointer is being used to determine the size of the pointed-to object:\n#include <stdlib.h>\n#include <time.h>\n  struct tm *make_tm(int year, int mon, int day, int hour,\n                   int min, int sec) {\n  struct tm *tmb;\n  tmb = (struct tm *)malloc(sizeof(tmb));\n  if (tmb == NULL) {\n    return NULL;\n  }\n  *tmb = (struct tm) {\n    .tm_sec = sec, .tm_min = min, .tm_hour = hour,\n    .tm_mday = day, .tm_mon = mon, .tm_year = year\n  };\n  return tmb;\n}\nCompliant Solution (Pointer)\n In this compliant solution, the correct amount of memory is allocated for the struct tm object. When allocating  space for a single object, passing the (dereferenced) pointer type to the sizeof operator is a simple way to allocate sufficient memory. Because the sizeof operator does not evaluate its operand, dereferencing an uninitialized or null pointer in this context is well-defined behavior.\n#include <stdlib.h>\n#include <time.h>\n  struct tm *make_tm(int year, int mon, int day, int hour,\n                   int min, int sec) {\n  struct tm *tmb;\n  tmb = (struct tm *)malloc(sizeof(*tmb));\n  if (tmb == NULL) {\n    return NULL;\n  }\n  *tmb = (struct tm) {\n    .tm_sec = sec, .tm_min = min, .tm_hour = hour,\n    .tm_mday = day, .tm_mon = mon, .tm_year = year\n  };\n  return tmb;\n}\nNoncompliant Code Example (Integer)\nIn this noncompliant code example, an array of long is allocated and assigned to p. The code attempts to check for unsigned integer overflow in compliance with INT30-C. Ensure that unsigned integer operations do not wrap and also ensures that len is not equal to zero. (See MEM04-C. Beware of zero-length allocations.) However, because sizeof(int) is used to compute the size, and not sizeof(long), an insufficient amount of memory can be allocated on implementations where sizeof(long) is larger than sizeof(int), and filling the array can cause a heap buffer overflow.\n#include <stdint.h>\n#include <stdlib.h>\n  void function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(long)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(int));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\nCompliant Solution (Integer)\nThis compliant solution uses sizeof(long) to correctly size the memory allocation:\n#include <stdint.h>\n#include <stdlib.h>\n void function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(long)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(long));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\nCompliant Solution (Integer)\nAlternatively, sizeof(*p) can be used to properly size the allocation:\n#include <stdint.h>\n#include <stdlib.h>\n  void function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(*p)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(*p));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\nRisk Assessment\nProviding invalid size arguments to memory allocation functions can lead to buffer overflows and the execution of arbitrary code with the permissions of the vulnerable process.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMEM35-C\nHigh\nProbable\nNo\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nmalloc-size-insufficient\nPartially checked\nBesides direct rule violations, all undefined behaviour resulting from invalid memory accesses is reported by Astr\u00e9e.\nAxivion Bauhaus Suite\n7.2.0\nCertC-MEM35\nCodeSonar\n9.1p0\nALLOC.SIZE.ADDOFLOW\nALLOC.SIZE.IOFLOW\nALLOC.SIZE.MULOFLOW\nALLOC.SIZE.SUBUFLOW\nALLOC.SIZE.TRUNC\nIO.TAINT.SIZE\nMISC.MEM.SIZE.BAD\nLANG.MEM.BO\nLANG.MEM.BU\nLANG.STRUCT.PARITH\nLANG.STRUCT.PBB\nLANG.STRUCT.PPE\nLANG.MEM.TBA\nLANG.MEM.TO\nLANG.MEM.TU\nAddition overflow of allocation size\nAddition overflow of allocation size\nMultiplication overflow of allocation size\nSubtraction underflow of allocation size\nTruncation of allocation size\nTainted allocation size\nUnreasonable size argument\nBuffer Overrun\nBuffer Underrun\nPointer Arithmetic\nPointer Before Beginning of Object\nPointer Past End of Object\nTainted Buffer Access\nType Overrun\nType Underrun\nCompass/ROSE\n\n\nCould check violations of this rule by examining the size expression to malloc() or memcpy() functions. Specifically, the size argument should be bounded by 0, SIZE_MAX, and, unless it is a variable of type size_t or rsize_t, it should be bounds-checked before the malloc() call. If the argument is of the expression a*b, then an appropriate check is\nif (a < SIZE_MAX / b && a > 0) ...\nCoverity\n2017.07\nBAD_ALLOC_STRLEN\nSIZECHECK (deprecated)\nPartially implemented\nCan find instances where string length is miscalculated (length calculated may be one less than intended) for memory allocation purposes. Coverity Prevent cannot discover all violations of this rule, so further verification is necessary\nFinds memory allocations that are assigned to a pointer that reference objects larger than the allocated block\nCppcheck Premium\n24.11.0\npremium-cert-mem35-c\nHelix QAC\n2025.2\nC0696, C0701, C1069, C1071, C1073, C2840\nDF2840, DF2841, DF2842, DF2843, DF2935, DF2936, DF2937, DF2938\n\nKlocwork\n2025.2\nINCORRECT.ALLOC_SIZE\nSV.TAINTED.ALLOC_SIZE\n\nLDRA tool suite\n9.7.1\n400 S, 487 S, 115 D\nEnhanced enforcement\nSplint 3.1.1\n\nParasoft C/C++test 2024.2\nCERT_C-MEM35-a\nDo not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function\nPC-lint Plus\n1.4\n433, 826\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MEM35-C\n\nChecks for:\nPointer access out of bounds\nMemory allocation with tainted size\nRule partially covered.\nPVS-Studio\n7.38\nV531, V635, V781\nRuleChecker\n24.04\nmalloc-size-insufficient Partially checked\nSecurity Reviewer - Static Reviewer\n6.02\nCPP_039 Fully implemented\nTrustInSoft Analyzer\n1.38\nmem_access\nExhaustively detects undefined behavior (see one compliant and one non-compliant example).\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard ARR01-C. Do not apply the sizeof operator to a pointer when taking the size of an array\nINT31-C. Ensure that integer conversions do not result in lost or misinterpreted data Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard INT32-C. Ensure that operations on signed integers do not result in overflow Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard MEM04-C. Beware of zero-length allocations Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Buffer Boundary Violation (Buffer Overflow) [HCB] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Taking the size of a pointer to determine the size of the pointed-to type [sizeofptr] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-131, Incorrect Calculation of Buffer Size 2017-05-16: CERT: Rule subset of CWE\nCWE 2.11 CWE-680 2017-05-18: CERT: Rule subset of CWE\nCWE 2.11 CWE-789 2017-06-12: CERT: Partial overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-680 and MEM35-C\nIntersection( INT32-C, MEM35-C) = \u00d8\nCWE-680 = Union( MEM35-C, list) where list =\n\nOverflowed buffers with inadequate sizes not produced by integer overflow\n\nCWE-467 and MEM35-C\nCWE-467 = Subset( MEM35-C)\nCWE-789 and MEM35-C\nIntersection( MEM35-C, CWE-789) =\n\nInsufficient memory allocation on the heap\n\nMEM35-C \u2013 CWE-789 =\n\nInsufficient memory allocation with trusted value but incorrect calculation\n\nCWE-789 - MEM35-C =\n\nSufficient memory allocation (possibly over-allocation) with untrusted value\n\nCWE-120 and MEM35-C\nIntersection( MEM35-C, CWE-120) = \u00d8\nCWE-120 specifically addresses buffer overflow operations, which occur in the context of string-copying. MEM35-C specifically addresses allocation of memory ranges (some of which may be for subsequent string copy operations).\nConsequently, they address different sections of code, although one (or both) may be responsible for a single buffer overflow vulnerability.\nCWE-131 and MEM35-C\n\nIntersection( INT30-C, MEM35-C) = \u00d8\n\n\nCWE-131 = Union( MEM35-C, list) where list =\n\n\nMiscalculating a buffer for a non-heap region (such as a variable-length array)\n\nBibliography\n[Coverity 2007]\n[Drepper 2006] Section 2.1.1, \"Respecting Memory Bounds\"\n[Seacord 2013] Chapter 4, \"Dynamic Memory Management\"\nChapter 5, \"Integer Security\"\n[Viega 2005] Section 5.6.8, \"Use of sizeof() on a Pointer Type\"\n[xorl 2009] CVE-2009-0587: Evolution Data Server Base64 Integer Overflows",
        "language": "C"
    },
    {
        "rule_id": "INT01-C",
        "rule_title": "Use size_t or rsize_t for all integer values representing the size of an object",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/INT01-C.+Use+size_t+or+rsize_t+for+all+integer+values+representing+the+size+of+an+object",
        "content": "The size_t type is the unsigned integer type of the result of the sizeof operator. Variables of type size_t are guaranteed to be of sufficient precision to represent the size of an object. The limit of size_t is specified by the SIZE_MAX macro.\nThe type size_t generally covers the entire address space. The C Standard, Annex K (normative), \"Bounds-checking interfaces,\" introduces a new type, rsize_t, defined to be size_t but explicitly used to hold the size of a single object [Meyers 2004]. In code that documents this purpose by using the type rsize_t, the size of an object can be checked to verify that it is no larger than RSIZE_MAX, the maximum size of a normal single object, which provides additional input validation for library functions. See VOID STR07-C. Use the bounds-checking interfaces for string manipulation for additional discussion of C11 Annex K.\nAny variable that is used to represent the size of an object, including integer values used as sizes, indices, loop counters, and lengths, should be declared rsize_t, if available. Otherwise, it should be declared size_t.\nNoncompliant Code Example\nIn this noncompliant code example, the dynamically allocated buffer referenced by p overflows for values of n > INT_MAX:\nchar *copy(size_t n, const char *c_str) {\n  int i;\n  char *p;\n\n  if (n == 0) {\n    /* Handle unreasonable object size error */\n  }\n  p = (char *)malloc(n);\n  if (p == NULL) {\n    return NULL; /* Indicate malloc failure */\n  }\n  for ( i = 0; i < n; ++i ) {\n    p[i] = *c_str++;\n  }\n  return p;\n}\n\n/* ... */\n\nchar c_str[] = \"hi there\";\nchar *p = copy(sizeof(c_str), c_str);\nSigned integer overflow causes undefined behavior. The following are two possible conditions under which this code constitutes a serious vulnerability:\nsizeof(size_t) == sizeof(int)\nThe unsigned n may contain a value greater than INT_MAX. Assuming quiet wraparound on signed overflow, the loop executes n times because the comparison i < n is an unsigned comparison. Once i is incremented beyond INT_MAX, i takes on negative values starting with (INT_MIN). Consequently, the memory locations referenced by p[i] precede the memory referenced by p, and a write outside array bounds occurs.\nsizeof(size_t) > sizeof(int)\nFor values of n where 0 < n <= INT_MAX, the loop executes n times, as expected.\nFor values of n where INT_MAX < n <= (size_t)INT_MIN, the loop executes INT_MAX times. Once i becomes negative, the loop stops, and i remains in the range 0 through INT_MAX.\nFor values of n where (size_t)INT_MIN < n <= SIZE_MAX, i wraps and takes the values INT_MIN to INT_MIN + (n - (size_t)INT_MIN - 1). Execution of the loop overwrites memory from p[INT_MIN] through p[INT_MIN + (n - (size_t)INT_MIN - 1)].\nCompliant Solution (C11, Annex K)\nDeclaring i to be of type rsize_t eliminates the possible integer overflow condition (in this example). Also, the argument n is changed to be of type rsize_t to document additional validation in the form of a check against RSIZE_MAX:\nchar *copy(rsize_t n, const char *c_str) {\n  rsize_t i;\n  char *p;\n\n  if (n == 0 || n > RSIZE_MAX) {\n    /* Handle unreasonable object size error */\n  }\n  p = (char *)malloc(n);\n  if (p == NULL) {\n    return NULL;  /* Indicate malloc failure */\n  }\n  for (i = 0; i < n; ++i) {\n    p[i] = *c_str++;\n  }\n  return p;\n}\n\n/* ... */\n\nchar c_str[] = \"hi there\";\nchar *p = copy(sizeof(c_str), c_str);\nNoncompliant Code Example\nIn this noncompliant code example, the value of length is read from a network connection and passed as an argument to a wrapper to malloc() to allocate the appropriate data block. Provided that the size of an unsigned long is equal to the size of an unsigned int, and both sizes are equal to or smaller than the size of size_t, this code runs as expected. However, if the size of an unsigned long is greater than the size of an unsigned int, the value stored in length may be truncated when passed as an argument to alloc().  Both read functions return zero on success and nonzero on failure.\nvoid *alloc(unsigned int blocksize) {\n  return malloc(blocksize);\n}\n\nint read_counted_string(int fd) {\n  unsigned long length;\n  unsigned char *data;\n\n  if (read_integer_from_network(fd, &length)) {\n    return -1;\n  }\n\n  data = (unsigned char*)alloc(length+1);\n  if (data == NULL) {\n    return -1;  /* Indicate failure */\n  }\n\n  if (read_network_data(fd, data, length)) {\n    free(data);\n    return -1;\n  }\n  data[length] = '\\0';\n\n  /* ... */\n  free( data);\n  return 0;\n}\nCompliant Solution (C11, Annex K)\nDeclaring both length and the blocksize argument to alloc() as rsize_t eliminates the possibility of truncation. This compliant solution assumes that read_integer_from_network() and read_network_data() can also be modified to accept a length argument of type pointer to rsize_t and rsize_t, respectively. If these functions are part of an external library that cannot be updated, care must be taken when casting length into an unsigned long to ensure that integer truncation does not occur.\nvoid *alloc(rsize_t blocksize) {\n  if (blocksize == 0 || blocksize > RSIZE_MAX) {\n    return NULL;  /* Indicate failure */\n  }\n  return malloc(blocksize);\n}\n\nint read_counted_string(int fd) {\n  rsize_t length;\n  unsigned char *data;\n\n  if (read_integer_from_network(fd, &length)) {\n    return -1;\n  }\n\n  data = (unsigned char*)alloc(length+1);\n  if (data == NULL) {\n    return -1; /* Indicate failure */\n  }\n\n  if (read_network_data(fd, data, length)) {\n    free(data);\n    return -1;\n  }\n  data[length] = '\\0';\n\n  /* ... */\n  free( data);\n  return 0;\n}\nRisk Assessment\nThe improper calculation or manipulation of an object's size can result in exploitable vulnerabilities.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nINT01-C\nMedium\nProbable\nNo\nYes\nP8\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAxivion Bauhaus Suite\n7.2.0\nCertC-INT01\nCodeSonar\n9.1p0\nLANG.TYPE.BASIC\nBasic numerical type used\nCompass/ROSE\n\n\nCan detect violations of this recommendation. In particular, it catches comparisons and operations where one operand is of type size_t or rsize_t and the other is not\nSecurity Reviewer - Static Reviewer\n6.02\nC999\nFully implemented\nSplint\n3.1.1\n\n\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID INT01-CPP. Use rsize_t or size_t for all integer values representing the size of an object\nBibliography\n[Meyers 2004]",
        "language": "C"
    },
    {
        "rule_id": "FIO32-C",
        "rule_title": "Do not perform operations on devices that are only appropriate for files",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO32-C.+Do+not+perform+operations+on+devices+that+are+only+appropriate+for+files",
        "content": "File names on many operating systems, including Windows and UNIX, may be used to access special files, which are actually devices. Reserved Microsoft Windows device names include AUX, CON, PRN, COM1, and LPT1 or paths using the \\\\.\\ device namespace. Device files on UNIX systems are used to apply access rights and to direct operations on the files to the appropriate device drivers.\nPerforming operations on device files that are intended for ordinary character or binary files can result in crashes and denial-of-service attacks. For example, when Windows attempts to interpret the device name as a file resource, it performs an invalid resource access that usually results in a crash [Howard 2002].\nDevice files in UNIX can be a security risk when an attacker can access them in an unauthorized way. For example, if attackers can read or write to the /dev/kmem device, they may be able to alter the priority, UID, or other attributes of their process or simply crash the system. Similarly, access to disk devices, tape devices, network devices, and terminals being used by other processes can lead to problems [Garfinkel 1996].\nOn Linux, it is possible to lock certain applications by attempting to open devices rather than files. Consider the following example:\n/dev/mouse\n/dev/console\n/dev/tty0\n/dev/zero\nA Web browser that failed to check for these devices would allow an attacker to create a website with image tags such as <IMG src=\"file:///dev/mouse\"> that would lock the user's mouse [Howard 2002].\nNoncompliant Code Example\nIn this noncompliant code example, the user can specify a locked device or a FIFO (first-in, first-out) file name, which can cause the program to hang on the call to fopen():\n#include <stdio.h>\n  void func(const char *file_name) {\n  FILE *file;\n  if ((file = fopen(file_name, \"wb\")) == NULL) {\n    /* Handle error */\n  }\n   /* Operate on the file */\n   if (fclose(file) == EOF) {\n    /* Handle error */\n  }\n}\nCompliant Solution (POSIX)\nPOSIX defines the O_NONBLOCK flag to open(), which ensures that delayed operations on a file do not hang the program [IEEE Std 1003.1:2013].\nWhen opening a FIFO with O_RDONLY or O_WRONLY set:\nIf O_NONBLOCK is set, an open() for reading-only returns without delay. An open() for writing-only returns an error if no process currently has the file open for reading.\nIf O_NONBLOCK is clear, an open() for reading-only blocks the calling thread until a thread opens the file for writing. An open() for writing-only blocks the calling thread until a thread opens the file for reading.\nWhen opening a block special or character special file that supports nonblocking opens:\nIf O_NONBLOCK is set, the open() function returns without blocking for the device to be ready or available; subsequent behavior is device-specific.\nIf O_NONBLOCK is clear, the open() function blocks the calling thread until the device is ready or available before returning.\nOtherwise, the behavior of O_NONBLOCK is unspecified.\nOnce the file is open, programmers can use the POSIX lstat() and fstat() functions to obtain information about a file and the S_ISREG() macro to determine if the file is a regular file. \nBecause the behavior of O_NONBLOCK on subsequent calls to read() or write() is unspecified, it is advisable to disable the flag after it has been determined that the file in question is not a special device.\nWhen available (Linux 2.1.126+, FreeBSD, Solaris 10, POSIX.1-2008), the O_NOFOLLOW flag should also be used. (See POS01-C. Check for the existence of links when dealing with files.) When O_NOFOLLOW is not available, symbolic link checks should use the method from POS35-C. Avoid race conditions while checking for the existence of a symbolic link.\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n #ifdef O_NOFOLLOW\n  #define OPEN_FLAGS O_NOFOLLOW | O_NONBLOCK\n#else\n  #define OPEN_FLAGS O_NONBLOCK\n#endif\n void func(const char *file_name) {\n  struct stat orig_st;\n  struct stat open_st;\n  int fd;\n  int flags;\n   if ((lstat(file_name, &orig_st) != 0) ||\n      (!S_ISREG(orig_st.st_mode))) {\n    /* Handle error */\n  }\n   /* Race window */\n   fd = open(file_name, OPEN_FLAGS | O_WRONLY);\n  if (fd == -1) {\n    /* Handle error */\n  }\n   if (fstat(fd, &open_st) != 0) {\n    /* Handle error */\n  }\n   if ((orig_st.st_mode != open_st.st_mode) ||\n      (orig_st.st_ino  != open_st.st_ino) ||\n      (orig_st.st_dev  != open_st.st_dev)) {\n    /* The file was tampered with */\n  }\n   /*\n   * Optional: drop the O_NONBLOCK now that we are sure\n   * this is a good file.\n   */\n  if ((flags = fcntl(fd, F_GETFL)) == -1) {\n    /* Handle error */\n  }\n   if (fcntl(fd, F_SETFL, flags & ~O_NONBLOCK) == -1) {\n    /* Handle error */\n  }\n   /* Operate on the file */\n   if (close(fd) == -1) {\n    /* Handle error */\n  }\n}\nThis code contains an intractable TOCTOU (time-of-check, time-of-use) race condition under which an attacker can alter the file referenced by file_name following the call to lstat() but before the call to open(). The switch will be discovered after the file is opened, but opening the file cannot be prevented in the case where this action itself causes undesired behavior. (See FIO45-C. Avoid TOCTOU race conditions while accessing files for more information about TOCTOU race conditions.)\nEssentially, an attacker can switch out a file for one of the file types shown in the following table with the specified effect.\nFile Types and Effects\nType\nNote on Effect\nAnother regular file\nThe fstat() verification fails.\nFIFO\nEither open() returns -1 and sets errno to ENXIO, or open() succeeds and the fstat() verification fails.\nSymbolic link\nopen() returns -1 if O_NOFOLLOW is available; otherwise, the fstat() verification fails.\nSpecial device\nUsually the fstat() verification fails on st_mode. This can still be a problem if the device is one for which just opening (or closing) it causes a side effect. If st_mode compares equal, then the device is one that, after opening, appears to be a regular file. It would then fail the fstat() verification on st_dev and st_ino (unless it happens to be the same file, as can happen with /dev/fd/* on Solaris, but this would not be a problem).\n\nTo be compliant with this rule and to prevent this TOCTOU race condition, file_name must refer to a file in a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory.)\nNoncompliant Code Example (Windows)\nThis noncompliant code example uses the GetFileType() function to attempt to prevent opening a special file: \n#include <Windows.h>\n  void func(const TCHAR *file_name) {\n  HANDLE hFile = CreateFile(\n    file_name,\n    GENERIC_READ | GENERIC_WRITE, 0,\n    NULL, OPEN_EXISTING,\n    FILE_ATTRIBUTE_NORMAL, NULL\n  );\n  if (hFile == INVALID_HANDLE_VALUE) {\n    /* Handle error */\n  } else if (GetFileType(hFile) != FILE_TYPE_DISK) {\n    /* Handle error */\n    CloseHandle(hFile);\n  } else {\n    /* Operate on the file */\n    CloseHandle(hFile);\n  }\n}\nAlthough tempting, the Win32 GetFileType() function is dangerous in this case. If the file name given identifies a named pipe that is currently blocking on a read request, the call to GetFileType() will block until the read request completes. This provides an effective attack vector for a denial-of-service attack on the application. Furthermore, the act of opening a file handle may cause side effects, such as line states being set to their default voltage when opening a serial device.\nCompliant Solution (Windows)\nMicrosoft documents a list of reserved identifiers that represent devices and have a device namespace to be used specifically by devices [MSDN]. In this compliant solution, the isReservedName() function can be used to determine if a specified path refers to a device. Care must be taken to avoid a TOCTOU race condition when first testing a path name using the isReservedName() function and then later operating on that path name.\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n static bool isReservedName(const char *path) {\n  /* This list of reserved names comes from MSDN */\n  static const char *reserved[] = {\n    \"nul\", \"con\", \"prn\", \"aux\", \"com1\", \"com2\", \"com3\",\n    \"com4\", \"com5\", \"com6\", \"com7\", \"com8\", \"com9\",\n    \"lpt1\", \"lpt2\", \"lpt3\", \"lpt4\", \"lpt5\", \"lpt6\",\n    \"lpt7\", \"lpt8\", \"lpt9\"\n  };\n  bool ret = false;\n /*\n * First, check to see if this is a device namespace, which\n * always starts with \\\\.\\, because device namespaces are not\n * valid file paths.\n */\n   if (!path || 0 == strncmp(path, \"\\\\\\\\.\\\\\", 4)) {\n    return true;\n  }\n   /* Compare against the list of ancient reserved names */\n  for (size_t i = 0; !ret &&\n       i < sizeof(reserved) / sizeof(*reserved); ++i) {\n   /*\n    * Because Windows uses a case-insensitive file system, operate on\n    * a lowercase version of the given filename. Note: This ignores\n    * globalization issues and assumes ASCII characters.\n    */\n    if (0 == _stricmp(path, reserved[i])) {\n      ret = true;\n    }\n  }\n  return ret;\n}\nExceptions\nFIO32-C-EX1: These checks are intended for opening files specified by a user (or an untrusted source). Intentionally opening device files does not violate this rule.\nRisk Assessment\nAllowing operations that are appropriate only for regular files to be performed on devices can result in denial-of-service attacks or more serious exploits depending on the platform.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO32-C\nMedium\nUnlikely\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCompass/ROSE\n\n\nCould detect some violations of this rule. This rule applies only to untrusted file name strings, and ROSE cannot tell which strings are trusted and which are not. The best heuristic is to note if there is any verification of the file name before or after the fopen() call. If there is any verification, then the file opening should be preceded by an lstat() call and succeeded by an fstat() call. Although that does not enforce the rule completely, it does indicate that the coder is aware of the lstat-fopen-fstat idiom\nCppcheck Premium\n24.11.0\npremium-cert-fio32-c\nHelix QAC\n2025.2\nDF4921, DF4922, DF4923\n\nParasoft C/C++test\n2024.2\nCERT_C-FIO32-a\nProtect against file name injection\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO32-C Checks for inappropriate I/O operation on device files (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard FIO05-C. Identify files using multiple file attributes Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard FIO15-C. Ensure that file operations are performed in a secure directory Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard POS01-C. Check for the existence of links when dealing with files Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard POS35-C. Avoid race conditions while checking for the existence of a symbolic link Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java FIO00-J. Do not operate on files in shared directories Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-67 and FIO32-C\nFIO32-C = Union( CWE-67, list) where list =\n\nTreating trusted device names like regular files in Windows.\n\n\nTreating device names (both trusted and untrusted) like regular files in POSIX\n\nBibliography\n[Garfinkel 1996] Section 5.6, \"Device Files\"\n[Howard 2002] Chapter 11, \"Canonical Representation Issues\"\n[IEEE Std 1003.1:2013] XSH, System Interfaces, open\n[MSDN]",
        "language": "C"
    },
    {
        "rule_id": "FIO34-C",
        "rule_title": "Distinguish between characters read from a file and EOF or WEOF",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO34-C.+Distinguish+between+characters+read+from+a+file+and+EOF+or+WEOF",
        "content": "The EOF macro represents a negative value that is used to indicate that the file is exhausted and no data remains when reading data from a file. EOF is an example of an in-band error indicator. In-band error indicators are problematic to work with, and the creation of new in-band-error indicators is discouraged by ERR02-C. Avoid in-band error indicators.\nThe byte I/O functions fgetc(), getc(), and getchar() all read a character from a stream and return it as an int. (See STR00-C. Represent characters using an appropriate type.) If the stream is at the end of the file, the end-of-file indicator for the stream is set and the function returns EOF. If a read error occurs, the error indicator for the stream is set and the function returns EOF. If these functions succeed, they cast the character returned into an unsigned char.\nBecause EOF is negative, it should not match any unsigned character value. However, this is only true for implementations where the int type is wider than char. On an implementation where int and char have the same width, a character-reading function can read and return a valid character that has the same bit-pattern as EOF. This could occur, for example, if an attacker inserted a value that looked like EOF into the file or data stream to alter the behavior of the program.\nThe C Standard requires only that the int type be able to represent a maximum value of +32767 and that a char type be no larger than an int. Although uncommon, this situation can result in the integer constant expression EOF being indistinguishable from a valid character; that is, (int)(unsigned char)65535 == -1. Consequently, failing to use feof() and ferror() to detect end-of-file and file errors can result in incorrectly identifying the EOF character on rare implementations where sizeof(int) == sizeof(char).\nThis problem is much more common when reading wide characters. The fgetwc(), getwc(), and getwchar() functions return a value of type wint_t. This value can represent the next wide character read, or it can represent WEOF, which indicates end-of-file for wide character streams. On most implementations, the wchar_t type has the same width as wint_t, and these functions can return a character indistinguishable from WEOF.\nIn the UTF-16 character set, 0xFFFF is guaranteed not to be a character, which allows WEOF to be represented as the value -1. Similarly, all UTF-32 characters are positive when viewed as a signed 32-bit integer. All widely used character sets are designed with at least one value that does not represent a character. Consequently, it would require a custom character set designed without consideration of the C programming language for this problem to occur with wide characters or with ordinary characters that are as wide as int.\nThe C Standard feof() and ferror() functions are not subject to the problems associated with character and integer sizes and should be used to verify end-of-file and file errors for susceptible implementations [Kettlewell 2002]. Calling both functions on each iteration of a loop adds significant overhead, so a good strategy is to temporarily trust EOF and WEOF within the loop but verify them with feof() and ferror() following the loop.\nNoncompliant Code Example\nThis noncompliant code example loops while the character c is not EOF:\n#include <stdio.h>\n  void func(void) {\n  int c;\n    do {\n    c = getchar();\n  } while (c != EOF);\n}\nAlthough EOF is guaranteed to be negative and distinct from the value of any unsigned character, it is not guaranteed to be different from any such value when converted to an int. Consequently, when int has the same width as char, this loop may terminate prematurely.\nCompliant Solution (Portable)\nThis compliant solution uses feof() and ferror() to test whether the EOF was an actual character or a real EOF because of end-of-file or errors:\n#include <stdio.h>\n void func(void) {\n  int c;\n   do {\n    c = getchar();\n  } while (c != EOF || (!feof(stdin) && !ferror(stdin)));\n}\nNoncompliant Code Example (Nonportable)\nThis noncompliant code example uses an assertion to ensure that the code is executed only on architectures where int is wider than char and EOF is guaranteed not to be a valid character value. However, this code example is noncompliant because the variable c is declared as a char rather than an int, making it possible for a valid character value to compare equal to the value of the EOF macro when char is signed because of sign extension:\n#include <assert.h>\n#include <limits.h>\n#include <stdio.h>\n void func(void) {\n  char c;\n  static_assert(UCHAR_MAX < UINT_MAX, \"FIO34-C violation\");\n   do {\n    c = getchar();\n  } while (c != EOF);\n}\nAssuming that a char is a signed 8-bit type and an int is a 32-bit type, if getchar() returns the character value '\\xff (decimal 255), it will be interpreted as EOF because this value is sign-extended to 0xFFFFFFFF (the value of EOF) to perform the comparison. (See STR34-C. Cast characters to unsigned char before converting to larger integer sizes.)\nCompliant Solution (Nonportable)\nThis compliant solution declares c to be an int. Consequently, the loop will terminate only when the file is exhausted.\n#include <assert.h>\n#include <stdio.h>\n#include <limits.h>\n void func(void) {\n  int c;\n  static_assert(UCHAR_MAX < UINT_MAX, \"FIO34-C violation\");\n   do {\n    c = getchar();\n  } while (c != EOF);\n}\nNoncompliant Code Example (Wide Characters)\nIn this noncompliant example, the result of the call to the C standard library function getwc() is stored into a variable of type wchar_t and is subsequently compared with WEOF:\n#include <stddef.h>\n#include <stdio.h>\n#include <wchar.h>\n enum { BUFFER_SIZE = 32 };\n void g(void) {\n  wchar_t buf[BUFFER_SIZE];\n  wchar_t wc;\n  size_t i = 0;\n   while ((wc = getwc(stdin)) != L'\\n' && wc != WEOF) {\n    if (i < (BUFFER_SIZE - 1)) {\n      buf[i++] = wc;\n    }\n  }\n  buf[i] = L'\\0';\n}\nThis code suffers from two problems. First, the value returned by getwc() is immediately converted to wchar_t before being compared with WEOF. Second, there is no check to ensure that wint_t is wider than wchar_t. Both of these problems make it possible for an attacker to terminate the loop prematurely by supplying the wide-character value matching WEOF in the file.\nCompliant Solution (Portable)\nThis compliant solution declares wc to be a wint_t to match the integer type returned by getwc(). Furthermore, it does not rely on WEOF to determine end-of-file definitively.\n#include <stddef.h>\n#include <stdio.h>\n#include <wchar.h>\n  enum {BUFFER_SIZE = 32 }\n void g(void) {\n  wchar_t buf[BUFFER_SIZE];\n  wint_t wc;\n  size_t i = 0;\n     while ((wc = getwc(stdin)) != L'\\n' && wc != WEOF) {\n    if (i < BUFFER_SIZE - 1) {\n      buf[i++] = wc;\n    }\n  }\n   if (feof(stdin) || ferror(stdin)) {\n   buf[i] = L'\\0';\n  } else {\n    /* Received a wide character that resembles WEOF; handle error */\n  }\n}\nExceptions\nFIO34-C-EX1: A number of C functions do not return characters but can return EOF as a status code. These functions include fclose(), fflush(), fputs(), fscanf(), puts(), scanf(), sscanf(), vfscanf(), and vscanf(). These return values can be compared to EOF without validating the result.\nRisk Assessment\nIncorrectly assuming characters from a file cannot match EOF or WEOF has resulted in significant vulnerabilities, including command injection attacks. (See the *CA-1996-22 advisory.)\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO34-C\nHigh\nProbable\nYes\nYes\nP18\nL1\n\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nconversion_overflow\nessential-type-assign\nSoundly supported\nAxivion Bauhaus Suite\n7.2.0\nCertC-FIO34\nCodeSonar\n9.1p0\nLANG.CAST.COERCE Coercion alters value\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nCHAR_IO\nIdentifies defects when the return value of fgetc(), getc(), or getchar() is incorrectly assigned to a char instead of an int. Coverity Prevent cannot discover all violations of this rule, so further verification is necessary\nCppcheck Premium 24.11.0\n\npremium-cert-fio34-c\n\nECLAIR 1.2\nCC2.FIO34\nPartially implemented\nHelix QAC\n2025.2\nC2676, C2678\nC++2676, C++2678, C++3001, C++3010, C++3051, C++3137, C++3717\n\nKlocwork\n2025.2\nCWARN.CMPCHR.EOF\nLDRA tool suite\n9.7.1\n662 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO34-a\nThe macro EOF should be compared with the unmodified return value from the Standard Library function\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO34-C\n\nChecks for character values absorbed into EOF (rule partially covered)\nSplint 3.1.1\n\n\nRuleChecker\n24.04\nessential-type-assign Supported\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard STR00-C. Represent characters using an appropriate type Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java FIO08-J. Use an int to capture the return value of methods that read a character or byte Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Using character values that are indistinguishable from EOF [chreof] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-197 2017-06-14: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-197 and FIO34-C\nIndependent( FLP34-C, INT31-C) FIO34-C = Subset( INT31-C)\nTherefore: FIO34-C = Subset( CWE-197)\nBibliography\n[Kettlewell 2002] Section 1.2, \"<stdio.h> and Character Types\"\n[NIST 2006] SAMATE Reference Dataset Test Case ID 000-000-088\n[Summit 2005] Question 12.2",
        "language": "C"
    },
    {
        "rule_id": "FIO37-C",
        "rule_title": "Do not assume that fgets() or fgetws() returns a nonempty string when successful",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO37-C.+Do+not+assume+that+fgets%28%29+or+fgetws%28%29+returns+a+nonempty+string+when+successful",
        "content": "Errors can occur when incorrect assumptions are made about the type of data being read. These assumptions may be violated, for example, when binary data has been read from a file instead of text from a user's terminal or the output of a process is piped to stdin. (See FIO14-C. Understand the difference between text mode and binary mode with file streams.) On some systems, it may also be possible to input a null byte (as well as other binary codes) from the keyboard.\nSubclause 7.23.7.2 of the C Standard paragraph 3 [ISO/IEC 9899:2024] says,\nThe fgets function returns s if successful. If end-of-file is encountered and no characters have been read into the array, the contents of the array remain unchanged and a null pointer is returned. If a read error occurs during the operation, the members of the array have unspecified values and a null pointer is returned.\nThe wide-character function fgetws() has the same behavior. Therefore, if fgets() or fgetws() returns a non-null pointer, it is safe to assume that the array contains data. However, it is erroneous to assume that the array contains a nonempty string because the data may contain null characters.\nNoncompliant Code Example\nThis noncompliant code example attempts to remove the trailing newline (\\n) from an input line. The fgets() function is typically used to read a newline-terminated line of input from a stream. It takes a size parameter for the destination buffer and copies, at most, size - 1 characters from a stream to a character array.\n#include <stdio.h>\n#include <string.h>\n \nenum { BUFFER_SIZE = 1024 };\n\nvoid func(void) {\n  char buf[BUFFER_SIZE];\n\n  if (fgets(buf, sizeof(buf), stdin) == NULL) {\n    /* Handle error */\n  }\n  buf[strlen(buf) - 1] = '\\0';\n}\nThe strlen() function computes the length of a string by determining the number of characters that precede the terminating null character. A problem occurs if the first character read from the input by fgets() happens to be a null character. This may occur, for example, if a binary data file is read by the fgets() call [Lai 2006]. If the first character in buf is a null character, strlen(buf) returns 0, the expression strlen(buf) - 1 wraps around to a large positive value, and a write-outside-array-bounds error occurs.\nCompliant Solution\nThis compliant solution uses strchr() to replace the newline character in the string if it exists:\n#include <stdio.h>\n#include <string.h>\n \nenum { BUFFER_SIZE = 1024 };\n\nvoid func(void) {\n  char buf[BUFFER_SIZE];\n  char *p;\n\n  if (fgets(buf, sizeof(buf), stdin)) {\n    p = strchr(buf, '\\n');\n    if (p) {\n      *p = '\\0';\n    }\n  } else {\n    /* Handle error */\n  }\n}\nRisk Assessment\nIncorrectly assuming that character data has been read can result in an out-of-bounds memory write or other flawed logic.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO37-C\nHigh\nProbable\nYes\nYes\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\n\nAstr\u00e9e\n24.04\n\nSupported: Astr\u00e9e reports defects due to returned (empty) strings.\nAxivion Bauhaus Suite\n7.2.0\nCertC-FIO37\n\nCodeSonar\n9.1p0\n(general) Considers the possibility that fgets() and fgetws() may return empty strings (Warnings of various classes may be triggered depending on subsequent operations on those strings. For example, the noncompliant code example cited above would trigger a buffer underrun warning.)\nCompass/ROSE\n\n\nCould detect some violations of this rule (In particular, it could detect the noncompliant code example by searching for fgets(), followed by strlen() - 1, which could be \u22121. The crux of this rule is that a string returned by fgets() could still be empty, because the first char is '\\0'. There are probably other code examples that violate this guideline; they would need to be enumerated before ROSE could detect them.)\n\nCppcheck Premium\n24.11.0\npremium-cert-fio37-c\n\nHelix QAC\n2025.2\nDF4911, DF4912, DF4913\n\n\n Klocwork\n2025.2\nCERT.FIO.FGETS\n\n\nLDRA tool suite\n9.7.1\n44 S Enhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-FIO37-a\nAvoid accessing arrays out of bounds\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO37-C Checks for use of indeterminate string (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard FIO14-C. Understand the difference between text mode and binary mode with file streams Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard FIO20-C. Avoid unintentional truncation when using fgets() or fgetws() Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-241, Improper Handling of Unexpected Data Type 2017-07-05: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-241 and FIO37-C\nCWE-241 = Union( FIO37-C, list) where list =\nImproper handling of unexpected data type that does not come from the fgets() function.\nBibliography\n[ISO/IEC 9899:2024]\nSubclause 7.23.7.2, \"The fgets Function\"\nSubclause 7.31.3.2, \"The fgetws Function\"\n[Lai 2006]\n[Seacord 2013] Chapter 2, \"Strings\"",
        "language": "C"
    },
    {
        "rule_id": "FIO38-C",
        "rule_title": "Do not copy a FILE object",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO38-C.+Do+not+copy+a+FILE+object",
        "content": "According to the C Standard, 7.23.3, paragraph 6 [ISO/IEC 9899:2024],\nThe address of the FILE object used to control a stream may be significant; a copy of a FILE object is not required to serve in place of the original.\nConsequently, do not copy a FILE object.\nNoncompliant Code Example\nThis noncompliant code example can fail because a by-value copy of stdout is being used in the call to fputs():\n#include <stdio.h>\n  int main(void) {\n  FILE my_stdout = *stdout;\n  if (fputs(\"Hello, World!\\n\", &my_stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\nWhen compiled under Microsoft Visual Studio 2013 and run on Windows, this noncompliant example results in an \"access violation\" at runtime.\nCompliant Solution\nIn this compliant solution, a copy of the stdout pointer to the FILE object is used in the call to fputs():\n#include <stdio.h>\n  int main(void) {\n  FILE *my_stdout = stdout;\n  if (fputs(\"Hello, World!\\n\", my_stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\nRisk Assessment\nUsing a copy of a FILE object in place of the original may result in a crash, which can be used in a denial-of-service attack.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO38-C\nLow\nProbable\nYes\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nfile-dereference Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-FIO38 Fully implemented\nClang\n3.9\nmisc-non-copyable-objects Checked with clang-tidy\nCompass/ROSE\n\nCan detect simple violations of this rule\nCoverity\n2017.07\nMISRA C 2012 Rule 22.5\nPartially implemented\nCppcheck Premium 24.11.0\n\npremium-cert-fio38-c\n\nHelix QAC\n2025.2\nC1485, C5028\nC++3113, C++3114\n\nKlocwork\n2025.2\nMISRA.FILE_PTR.DEREF.2012\nMISRA.FILE_PTR.DEREF.CAST.2012\nMISRA.FILE_PTR.DEREF.INDIRECT.2012\nMISRA.FILE_PTR.DEREF.RETURN.2012\n\nLDRA tool suite\n9.7.1\n591 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO38-a\nA pointer to a FILE object shall not be dereferenced\nPC-lint Plus\n1.4\n9047\nPartially supported: reports when a FILE pointer is dereferenced\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO38-C Checks for misuse of a FILE object (rule fully covered)\nRuleChecker\n24.04\nfile-dereference\nPartially checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TS 17961:2013 Copying a FILE object [filecpy] Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 7.23.3, \"Files\"",
        "language": "C"
    },
    {
        "rule_id": "FIO39-C",
        "rule_title": "Do not alternately input and output from a stream without an intervening flush or positioning call",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO39-C.+Do+not+alternately+input+and+output+from+a+stream+without+an+intervening+flush+or+positioning+call",
        "content": "The C Standard, 7.23.5.3, paragraph 7 [ISO/IEC 9899:2024], places the following restrictions on update streams:\nWhen a file is opened with update mode . . ., both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the fflush function or to a file positioning function (fseek, fsetpos, or rewind), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file. Opening (or creating) a text file with update mode may instead open (or create) a binary stream in some implementations.\nThe following scenarios can result in undefined behavior. (See undefined behavior 156.)\n Receiving input from a stream directly following an output to that stream without an intervening call to fflush(), fseek(), fsetpos(), or rewind() if the file is not at end-of-file\n Outputting to a stream after receiving input from that stream without a call to fseek(), fsetpos(), or rewind() if the file is not at end-of-file\nConsequently, a call to fseek(), fflush(), or fsetpos() is necessary between input and output to the same stream. See ERR07-C. Prefer functions that support error checking over equivalent functions that don't for more information on why fseek() is preferred over rewind().\nNoncompliant Code Example\nThis noncompliant code example appends data to a file and then reads from the same file:\n#include <stdio.h>\n  enum { BUFFERSIZE = 32 };\n extern void initialize_data(char *data, size_t size);\n  void func(const char *file_name) {\n  char data[BUFFERSIZE];\n  char append_data[BUFFERSIZE];\n  FILE *file;\n   file = fopen(file_name, \"a+\");\n  if (file == NULL) {\n    /* Handle error */\n  }\n    initialize_data(append_data, BUFFERSIZE);\n   if (fwrite(append_data, 1, BUFFERSIZE, file) != BUFFERSIZE) {\n    /* Handle error */\n  }\n  if (fread(data, 1, BUFFERSIZE, file) < BUFFERSIZE) {\n    /* Handle there not being data */\n  }\n   if (fclose(file) == EOF) {\n    /* Handle error */\n  }\n}\nBecause there is no intervening flush or positioning call between the calls to fread() and fwrite(), the behavior is undefined.\nCompliant Solution\nIn this compliant solution, fseek() is called between the output and input, eliminating the undefined behavior 156:\n#include <stdio.h>\n  enum { BUFFERSIZE = 32 };\nextern void initialize_data(char *data, size_t size);\n  void func(const char *file_name) {\n  char data[BUFFERSIZE];\n  char append_data[BUFFERSIZE];\n  FILE *file;\n   file = fopen(file_name, \"a+\");\n  if (file == NULL) {\n    /* Handle error */\n  }\n   initialize_data(append_data, BUFFERSIZE);\n  if (fwrite(append_data, BUFFERSIZE, 1, file) != BUFFERSIZE) {\n    /* Handle error */\n  }\n   if (fseek(file, 0L, SEEK_SET) != 0) {\n    /* Handle error */\n  }\n   if (fread(data, BUFFERSIZE, 1, file) != 0) {\n    /* Handle there not being data */\n  }\n   if (fclose(file) == EOF) {\n    /* Handle error */\n  }\n}\nRisk Assessment\nAlternately inputting and outputting from a stream without an intervening flush or positioning call is undefined behavior 156.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO39-C\nLow\nLikely\nYes\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nAxivion Bauhaus Suite\n7.2.0\nCertC-FIO39\nCodeSonar\n9.1p0\nIO.IOWOP\nIO.OIWOP\nInput After Output Without Positioning\nOutput After Input Without Positioning\nCompass/ROSE\n\nCan detect simple violations of this rule\nCppcheck\n 2.15\nIOWithoutPositioning\nCppcheck Premium\n24.11.0\nIOWithoutPositioning\nHelix QAC\n2025.2\nDF4711, DF4712, DF4713\n\nKlocwork\n2025.2\nCERT.FIO.NO_FLUSH\n\nLDRA tool suite\n9.7.1\n84 D\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO39-a\nDo not alternately input and output from a stream without an intervening flush or positioning call\nPC-lint Plus\n1.4\n2478, 2479\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO39-C Checks for alternating input and output from a stream without flush or positioning call (rule fully covered)\nSecurity Reviewer - Static Reviewer\n6.02\nC17\nC77\nC78\nC79\nC80 Fully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C FIO50-CPP. Do not alternately input and output from a file stream without an intervening positioning call Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Interleaving stream inputs and outputs without a flush or positioning call [ioileave] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-664 2017-07-10: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-664 and FIO39-C\nCWE-664 = Union( FIO39-C, list) where list =\n\nImproper use of an object (besides alternating reading/writing a file stream without an intervening flush\n\nThis CWE is vague on what constitutes \u201cimproper control of a resource\u201d. It could include any violation of an object\u2019s method constraints (whether they are documented or not). Or it could be narrowly interpreted to mean object creation and object destruction (which are covered by other CWEs).\nBibliography\n[ISO/IEC 9899:2024] 7.23.5.3, \"The fopen Function\"",
        "language": "C"
    },
    {
        "rule_id": "FIO41-C",
        "rule_title": "Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO41-C.+Do+not+call+getc%28%29%2C+putc%28%29%2C+getwc%28%29%2C+or+putwc%28%29+with+a+stream+argument+that+has+side+effects",
        "content": "Do not invoke getc() or putc() or their wide-character analogues getwc() and putwc() with a stream argument that has side effects. The stream argument passed to these macros may be evaluated more than once if these functions are implemented as unsafe macros. (See PRE31-C. Avoid side effects in arguments to unsafe macros for more information.)\nThis rule does not apply to the character argument in putc() or the wide-character argument in putwc(), which is guaranteed to be evaluated exactly once.\nNoncompliant Code Example (getc())\nThis noncompliant code example calls the getc() function with an expression as the stream argument. If getc() is implemented as a macro, the file may be opened multiple times. (See FIO24-C. Do not open a file that is already open.)\n#include <stdio.h>\n  void func(const char *file_name) {\n  FILE *fptr;\n   int c = getc(fptr = fopen(file_name, \"r\"));\n  if (feof(fptr) || ferror(fptr)) {\n    /* Handle error */\n  }\n   if (fclose(fptr) == EOF) {\n    /* Handle error */\n  }\n}\nThis noncompliant code example also violates ERR33-C. Detect and handle standard library errors because the value returned by fopen() is not checked for errors.\nCompliant Solution (getc())\nIn this compliant solution, fopen() is called before getc() and its return value is checked for errors:\n#include <stdio.h>\n  void func(const char *file_name) {\n  int c;\n  FILE *fptr;\n   fptr = fopen(file_name, \"r\");\n  if (fptr == NULL) {\n    /* Handle error */\n  }\n   c = getc(fptr);\n  if (c == EOF) {\n    /* Handle error */\n  }\n   if (fclose(fptr) == EOF) {\n    /* Handle error */\n  }\n}\nNoncompliant Code Example (putc())\nIn this noncompliant example, putc() is called with an expression as the stream argument. If putc() is implemented as a macro, this expression might be evaluated multiple times.\n#include <stdio.h>\n  void func(const char *file_name) {\n  FILE *fptr = NULL;\n  int c = 'a';\n    while (c <= 'z') {\n    if (putc(c++, fptr ? fptr :\n         (fptr = fopen(file_name, \"w\"))) == EOF) {\n      /* Handle error */\n    }\n  }\n   if (fclose(fptr) == EOF) {\n    /* Handle error */\n  }\n}\nThis noncompliant code example might appear safe even if the putc() macro evaluates its stream argument multiple times, as the ternary conditional expression ostensibly prevents multiple calls to fopen(). However, the assignment to fptr and the evaluation of fptr as the controlling expression of the ternary conditional expression can take place between the same sequence points, resulting in undefined behavior 34 (a violation of EXP30-C. Do not depend on the order of evaluation for side effects). This code also violates ERR33-C. Detect and handle standard library errors because it fails to check the return value from fopen().\nCompliant Solution (putc())\nIn this compliant solution, the stream argument to putc() no longer has side effects:\n#include <stdio.h>\n  void func(const char *file_name) {\n  int c = 'a';\n  FILE *fptr = fopen(file_name, \"w\");\n    if (fptr == NULL) {\n    /* Handle error */\n  }\n   while (c <= 'z') {\n    if (putc(c++, fptr) == EOF) {\n      /* Handle error */\n    }\n  }\n   if (fclose(fptr) == EOF) {\n    /* Handle error */\n  }\n}\nThe expression c++ is perfectly safe because putc() guarantees to evaluate its character argument exactly once.\nNOTE: The output of this compliant solution differs depending on the character set. For example, when run on a machine using an ASCII-derived code set such as ISO-8859 or Unicode, this solution will print out the 26 lowercase letters of the English alphabet. However, if run with an EBCDIC-based code set, such as Codepage 037 or Codepage 285, punctuation marks or symbols may be output between the letters.\nRisk Assessment\nUsing an expression that has side effects as the stream argument to getc(), putc(), or getwc() can result in unexpected behavior and abnormal program termination.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO41-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nstream-argument-with-side-effects Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-FIO41\nCppcheck Premium\n24.11.0\npremium-cert-fio41-c\nHelix QAC\n2025.2\nC5036\nC++3225, C++3229\n\nLDRA tool suite\n9.7.1\n35 D, 1 Q, 9 S,\n30 S, 134 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO41-a\nCERT_C-FIO41-b\nDo not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing assignments, increment or decrement operators\nDo not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing function calls or function-like macro calls\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO41-C Checks for stream arguments with possibly unintended side effects (rule fully covered)\nRuleChecker\n24.04\nstream-argument-with-side-effects Fully checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard FIO24-C. Do not open a file that is already open Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard EXP30-C. Do not depend on the order of evaluation for side effects Prior to 2018-01-12: CERT: Unspecified Relationship",
        "language": "C"
    },
    {
        "rule_id": "FIO42-C",
        "rule_title": "Close files when they are no longer needed",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO42-C.+Close+files+when+they+are+no+longer+needed",
        "content": "A call to the fopen() or freopen() function must be matched with a call to fclose() before the lifetime of the last pointer that stores the return value of the call has ended or before normal program termination, whichever occurs first.\nIn general, this rule should also be applied to other functions with open and close resources, such as the POSIX open() and close() functions, or the Microsoft Windows CreateFile() and CloseHandle() functions.\nNoncompliant Code Example\nThis code example is noncompliant because the file opened by the call to fopen() is not closed before function func() returns:\n#include <stdio.h>\n  int func(const char *filename) {\n  FILE *f = fopen(filename, \"r\");\n  if (NULL == f) {\n    return -1;\n  }\n  /* ... */\n  return 0;\n}\nCompliant Solution\nIn this compliant solution, the file pointed to by f is closed before returning to the caller:\n#include <stdio.h>\n  int func(const char *filename) {\n  FILE *f = fopen(filename, \"r\");\n  if (NULL == f) {\n    return -1;\n  }\n  /* ... */\n  if (fclose(f) == EOF) {\n    return -1;\n  }\n  return 0;\n}\nNoncompliant Code Example (exit())\nThis code example is noncompliant because the resource allocated by the call to fopen() is not closed before the program terminates.  Although exit() closes the file, the program has no way of determining if an error occurs while flushing or closing the file.\n#include <stdio.h>\n#include <stdlib.h>\n   int main(void) {\n  FILE *f = fopen(filename, \"w\");\n  if (NULL == f) {\n    exit(EXIT_FAILURE);\n  }\n  /* ... */\n  exit(EXIT_SUCCESS);\n}\nCompliant Solution (exit())\nIn this compliant solution, the program closes f explicitly before calling exit(), allowing any error that occurs when flushing or closing the file to be handled appropriately:\n#include <stdio.h>\n#include <stdlib.h>\n int main(void) {\n  FILE *f = fopen(filename, \"w\");\n  if (NULL == f) {\n    /* Handle error */\n  }\n  /* ... */\n  if (fclose(f) == EOF) {\n    /* Handle error */\n  }\n  exit(EXIT_SUCCESS);\n}\nNoncompliant Code Example (POSIX)\nThis code example is noncompliant because the resource allocated by the call to open() is not closed before function func() returns:\n#include <stdio.h>\n#include <fcntl.h>\n  int func(const char *filename) {\n  int fd = open(filename, O_RDONLY, S_IRUSR);\n  if (-1 == fd) {\n    return -1;\n  }\n  /* ... */\n  return 0;\n}\nCompliant Solution (POSIX)\nIn this compliant solution, fd is closed before returning to the caller:\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n  int func(const char *filename) {\n  int fd = open(filename, O_RDONLY, S_IRUSR);\n  if (-1 == fd) {\n    return -1\n  }\n  /* ... */\n  if (-1 == close(fd)) {\n    return -1;\n  }\n  return 0;\n}\nNoncompliant Code Example (Windows)\nIn this noncompliant code example, the file opened by the Microsoft Windows CreateFile() function is not closed before func() returns:\n#include <Windows.h>\n int func(LPCTSTR filename) {\n  HANDLE hFile = CreateFile(filename, GENERIC_READ, 0, NULL,\n                            OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, NULL);\n  if (INVALID_HANDLE_VALUE == hFile) {\n    return -1;\n  }\n  /* ... */\n  return 0;\n}\nCompliant Solution (Windows)\nIn this compliant solution, hFile is closed by invoking the CloseHandle() function before returning to the caller:\n#include <Windows.h>\n  int func(LPCTSTR filename) {\n  HANDLE hFile = CreateFile(filename, GENERIC_READ, 0, NULL,\n                            OPEN_EXISTING,\n                            FILE_ATTRIBUTE_NORMAL, NULL);\n  if (INVALID_HANDLE_VALUE == hFile) {\n    return -1;\n  }\n  /* ... */ \n  if (!CloseHandle(hFile)) {\n    return -1;\n  }\n    return 0;\n}\nRisk Assessment\nFailing to properly close files may allow an attacker to exhaust system resources and can increase the risk that data written into in-memory file buffers will not be flushed in the event of abnormal program termination.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO42-C\nMedium\nUnlikely\nNo\nNo\nP2\nL3\nAutomated Detection\nThis rule is stricter than rule [fileclose] in ISO/IEC TS 17961:2013. Analyzers that conform to the technical standard may not detect all violations of this rule.\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nCodeSonar\n9.1p0\nALLOC.LEAK Leak\nCompass/ROSE\n\n\nCoverity\n2017.07\nRESOURCE_LEAK (partial)\nPartially implemented\nCppcheck\n 2.15\nresourceLeak\nCppcheck Premium\n24.11.0\nresourceLeak\nHelix QAC\n2025.2\nDF2701, DF2702, DF2703\n\nKlocwork\n2025.2\nRH.LEAK\n\nLDRA tool suite\n9.7.1\n49 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO42-a\nEnsure resources are freed\nPC-lint Plus\n1.4\n429\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO42-C Checks for resource leak (rule partially covered)\nSecurity Reviewer - Static Reviewer\n6.02\nC80 Fully implemented\nSonarQube C/C++ Plugin\n3.11\nS2095\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C FIO51-CPP. Close files when they are no longer needed Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java FIO04-J. Release resources when they are no longer needed Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Failing to close files or free dynamic memory when they are no longer needed [fileclose] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-404, Improper Resource Shutdown or Release 2017-07-06: CERT: Rule subset of CWE\nCWE 2.11 CWE-459 2017-07-06: CERT: Rule subset of CWE\nCWE 2.11 CWE-772 2017-07-06: CERT: Rule subset of CWE\nCWE 2.11 CWE-773 2017-07-06: CERT: Rule subset of CWE\nCWE 2.11 CWE-775 2017-07-06: CERT: Rule subset of CWE\nCWE 2.11 CWE-403\n2017-10-30:MITRE:Unspecified Relationship\n2018-10-18:CERT:Partial overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-773/CWE-775 and FIO42-C\nCWE-773 = CWE-775\nCWE-773 = Union( FIO42-C, list) where list =\nFailure to free resource handles besides files\nCWE-404/CWE-459/CWE-771/CWE-772 and FIO42-C/MEM31-C\nIntersection( FIO42-C, MEM31-C) = \u00d8\nCWE-404 = CWE-459 = CWE-771 = CWE-772\nCWE-404 = Union( FIO42-C, MEM31-C list) where list =\nFailure to free resources besides files or memory chunks, such as mutexes)\nCWE-403 and FIO42-C\nCWE-403 - FIO42-C = list, where list =\nA process opens and closes a sensitive file descriptor, but also executes a child process while the file descriptor is open.\nFIO42-C - CWE-403 = SPECIAL_CASES, where SPECIAL_CASES =\nA program opens a file descriptor and fails to close it, but does not invoke any child processes while the file descriptor is open.\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, open",
        "language": "C"
    },
    {
        "rule_id": "FIO45-C",
        "rule_title": "Avoid TOCTOU race conditions while accessing files",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files",
        "content": "A TOCTOU (time-of-check, time-of-use) race condition is possible when two or more concurrent processes are operating on a shared file system [Seacord 2013b]. Typically, the first access is a check to verify some attribute of the file, followed by a call to use the file. An attacker can alter the file between the two accesses, or replace the file with a symbolic or hard link to a different file. These TOCTOU conditions can be exploited when a program performs two or more file operations on the same file name or path name.\nA program that performs two or more file operations on a single file name or path name creates a race window between the two file operations. This race window comes from the assumption that the file name or path name refers to the same resource both times. If an attacker can modify the file, remove it, or replace it with a different file, then this assumption will not hold.\nNoncompliant Code Example\nIf an existing file is opened for writing with the w mode argument, the file's previous contents (if any) are destroyed. This noncompliant code example tries to prevent an existing file from being overwritten by first opening it for reading before opening it for writing. An attacker can exploit the race window between the two calls to fopen() to overwrite an existing file.\n#include <stdio.h>\n void open_some_file(const char *file) {\n  FILE *f = fopen(file, \"r\");\n  if (NULL != f) {\n    /* File exists, handle error */\n  } else {\n    f = fopen(file, \"w\");\n    if (NULL == f) {\n      /* Handle error */\n    }\n      /* Write to file */\n    if (fclose(f) == EOF) {\n      /* Handle error */\n    }\n  }\n}\nCompliant Solution\nThis compliant solution invokes fopen() at a single location and uses the x mode of fopen(), which was added in C11. This mode causes fopen() to fail if the file exists. This check and subsequent open is performed without creating a race window. The x mode provides exclusive access to the file only if the host environment provides this support.\n#include <stdio.h>\n void open_some_file(const char *file) {\n  FILE *f = fopen(file, \"wx\");\n  if (NULL == f) {\n    /* Handle error */\n  }\n  /* Write to file */\n  if (fclose(f) == EOF) {\n    /* Handle error */\n  }\n}\nCompliant Solution (POSIX)\nThis compliant solution uses the O_CREAT and O_EXCL flags of POSIX's open() function. These flags cause open() to fail if the file exists.\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n void open_some_file(const char *file) {\n  int fd = open(file, O_CREAT | O_EXCL | O_WRONLY);\n  if (-1 != fd) {\n    FILE *f = fdopen(fd, \"w\");\n    if (NULL != f) {\n      /* Write to file */\n       if (fclose(f) == EOF) {\n        /* Handle error */\n      }\n    } else {\n      if (close(fd) == -1) {\n        /* Handle error */\n      }\n    }\n  }\n}\nExceptions\nFIO45-C-EX2: Accessing a file name or path name multiple times is permitted if the file referenced resides in a secure directory. (For more information, see FIO15-C. Ensure that file operations are performed in a secure directory.)\nFIO45-C-EX3: Accessing a file name or path name multiple times is permitted if the program can verify that every operation operates on the same file.\nThis POSIX code example verifies that each subsequent file access operates on the same file. In POSIX, every file can be uniquely identified by using its device and i-node attributes. This code example checks that a file name refers to a regular file (and not a directory, symbolic link, or other special file) by invoking lstat(). This call also retrieves its device and i-node. The file is subsequently opened. Finally, the program verifies that the file that was opened is the same one (matching device and i-nodes) as the file that was confirmed as a regular file.\nAn attacker can still exploit this code if they have the ability to delete the benign file and create the malicious file within the race window between lstat() and open(). It is possible that the OS kernel will reuse the same device and i-node for both files. This can be mitigated by making sure that the attacker lacks the permissions to delete the benign file.\n#include <sys/stat.h>\n#include <fcntl.h>\n int open_regular_file(char *filename, int flags) {\n  struct stat lstat_info;\n  struct stat fstat_info;\n  int f;\n    if (lstat(filename, &lstat_info) == -1) {\n    /* File does not exist, handle error */\n  }\n    if (!S_ISREG(lstat_info.st_mode)) {\n    /* File is not a regular file, handle error */\n  }\n    if ((f = open(filename, flags)) == -1) {\n    /* File has disappeared, handle error */\n  }\n    if (fstat(f, &fstat_info) == -1) {\n    /* Handle error */\n  }\n    if (lstat_info.st_ino != fstat_info.st_ino  ||\n      lstat_info.st_dev != fstat_info.st_dev) {\n    /* Open file is not the expected regular file, handle error */\n  }\n    /* f is the expected regular open file */\n  return f;\n}\nRisk Assessment\nTOCTOU race conditions can result in unexpected behavior, including privilege escalation.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO45-C\nHigh\nProbable\nNo\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nIO.RACE File system race condition\nCoverity\n2017.07\nTOCTOU\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-fio45-c\nHelix QAC\n2025.2\nDF4851, DF4852, DF4853\n\nKlocwork\n2025.2\nSV.TOCTOU.FILE_ACCESS\nLDRA tool suite\n9.7.1\n75 D Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO45-a\nAvoid race conditions while accessing files\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO45-C\nChecks for file access between time of check and use (rule partially covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[Seacord 2013b] Chapter 7, \"Files\"",
        "language": "C"
    },
    {
        "rule_id": "FIO46-C",
        "rule_title": "Do not access a closed file",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO46-C.+Do+not+access+a+closed+file",
        "content": "Using the value of a pointer to a FILE object after the associated file is closed is undefined behavior. (See undefined behavior 153.) Programs that close the standard streams (especially stdout but also stderr and stdin) must be careful not to use these streams in subsequent function calls, particularly those that implicitly operate on them (such as printf(), perror(), and getc()).\nThis rule can be generalized to other file representations.\nNoncompliant Code Example\nIn this noncompliant code example, the stdout stream is used after it is closed:\n#include <stdio.h>\n  int close_stdout(void) {\n  if (fclose(stdout) == EOF) {\n    return -1;\n  }\n    printf(\"stdout successfully closed.\\n\");\n  return 0;\n}\nCompliant Solution\nIn this compliant solution, stdout is not used again after it is closed. This must remain true for the remainder of the program, or stdout must be assigned the address of an open file object. \n#include <stdio.h>\n  int close_stdout(void) {\n  if (fclose(stdout) == EOF) {\n    return -1;\n  }\n   fputs(\"stdout successfully closed.\", stderr);\n  return 0;\n}\nRisk Assessment\nUsing the value of a pointer to a FILE object after the associated file is closed is undefined behavior 153.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO46-C\nMedium\nUnlikely\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported\nCodeSonar\n9.1p0\nIO.UAC Use after close\nCompass/ROSE\n\n\nCoverity\n2017.07\nUSE_AFTER_FREE\nImplemented\nHelix QAC\n2025.2\nDF2696, DF2697, DF2698\n\nKlocwork\n2025.2\nSV.INCORRECT_RESOURCE_HANDLING.URH\n\nLDRA tool suite\n9.7.1\n48 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO46-a\nDo not use resources that have been freed\nPC-lint Plus\n1.4\n2471\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule FIO46-C\n\nChecks for use of previously closed resource (rule partially covered)\nSonarQube C/C++ Plugin\n3.11\nS3588\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, open\n[ISO/IEC 9899:2024] \nSubclause 7.23.3, \"Files\"\nSubclause 7.23.5.1, \"The fclose Function\"",
        "language": "C"
    },
    {
        "rule_id": "FIO01-C",
        "rule_title": "Be careful using functions that use file names for identification",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification",
        "content": "Many file-related security vulnerabilities result from a program accessing an unintended file object because file names are only loosely bound to underlying file objects. File names provide no information regarding the nature of the file object itself. Furthermore, the binding of a file name to a file object is reasserted every time the file name is used in an operation. File descriptors and FILE pointers are bound to underlying file objects by the operating system. (See FIO03-C. Do not make assumptions about fopen() and file creation.)\nAccessing files via file descriptors or FILE pointers rather than file names provides a greater degree of certainty as to which object is actually acted upon. It is recommended that files be accessed through file descriptors or FILE pointers where possible.\nThe following C functions rely solely on file names for file identification:\nremove()\nrename()\nfopen()\nfreopen()\nUse these functions with caution. See FIO10-C. Take care when using the rename() function, and FIO08-C. Take care when calling remove() on an open file.\nNoncompliant Code Example\nIn this noncompliant code example, the file identified by file_name is opened, processed, closed, and removed. However, it is possible that the file object identified by file_name in the call to remove() is not the same file object identified by file_name in the call to fopen().\nchar *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL) {\n  /* Handle error */\n}\n\n/*... Process file ...*/\n\nif (fclose(f_ptr) != 0) {\n  /* Handle error */\n}\n\nif (remove(file_name) != 0) {\n  /* Handle error */\n}\nCompliant Solution\nNot much can be done programmatically to ensure the file removed is the same file that was opened, processed, and closed except to make sure that the file is opened in a secure directory with privileges that would prevent the file from being manipulated by an untrusted user. (See FIO15-C. Ensure that file operations are performed in a secure directory.)\nNoncompliant Code Example (POSIX)\nIn this noncompliant code example, the function chmod() is called to set the permissions of a file. However, it is not clear whether the file object referred to by file_name refers to the same object in the call to fopen() and in the call to chmod().\nchar *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL)  {\n  /* Handle error */\n}\n\n/* ... */\n\nif (chmod(file_name, S_IRUSR) == -1) {\n  /* Handle error */\n}\nCompliant Solution (POSIX)\nThis compliant solution uses the POSIX fchmod() and open() functions [IEEE Std 1003.1:2013]. Using these functions guarantees that the file opened is the same file that is operated on.\nchar *file_name;\nint fd;\n\n/* Initialize file_name */\n\nfd = open(\n  file_name,\n  O_WRONLY | O_CREAT | O_EXCL,\n  S_IRWXU\n);\nif (fd == -1) {\n  /* Handle error */\n}\n\n/* ... */\n\nif (fchmod(fd, S_IRUSR) == -1) {\n  /* Handle error */\n}\nMitigation Strategies (POSIX)\nMany file-related race conditions can be eliminated by using\nfchown() rather than chown()\nfstat() rather than stat()\nfchmod() rather than chmod()\nor simply by ensuring the security of the working directory per FIO15-C. Ensure that file operations are performed in a secure directory.\nPOSIX functions that have no file descriptor counterpart should be used with caution:\nlink() and unlink()\nmkdir() and rmdir()\nmount() and unmount()\nlstat()\nmknod()\nsymlink()\nutime()\nRisk Assessment\nMany file-related vulnerabilities, such as time-of-check, time-of-use (TOCTOU) race conditions, can be exploited to cause a program to access an unintended file. Using FILE pointers or file descriptors to identify files instead of file names reduces the chance of accessing an unintended file. Remediation costs are medium because, although insecure functions can be easily identified, simple drop-in replacements are not always available.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO01-C\nMedium\nLikely\nYes\nNo\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nIO.RACE\nIO.TAINT.FNAME\nBADFUNC.TEMP.*\nBADFUNC.TMPFILE_S\nBADFUNC.TMPNAM_S\nFile System Race Condition\nTainted Filename\nA collection of warning classes that report uses of library functions associated with temporary file vulnerabilities (including name issues).\nUse of tmpfile_s\nUse of tmpnam_s\nCompass/ROSE\n\n\nCan detect some violations of this recommendation. In particular, it warns when chown(), stat(), or chmod() are called on an open file\nCoverity 6.5 TOCTOU Fully implemented\nHelix QAC\n2025.2\nC5011\nKlocwork\n2025.2\nSV.TOCTOU.FILE_ACCESS\n\nLDRA tool suite\n9.7.1\n592 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO01-a\nCERT_C-FIO01-c\nDon't use chmod(), chown(), chgrp()\nBe careful using functions that use file names for identification\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO01-CPP. Be careful using functions that use file names for identification\nMITRE CWE CWE-73, External control of file name or path\nCWE-367, Time-of-check, time-of-use race condition\nCWE-676, Use of potentially dangerous function\nBibliography\n[Apple Secure Coding Guide] \"Avoiding Race Conditions and Insecure File Operations\"\n[Drepper 2006] Section 2.2.1 \"Identification when Opening\"\n[IEEE Std 1003.1:2013] XSH, System Interfaces, fchmod\nXSH, System Interfaces, open\n[Seacord 2013] Chapter 8, \"File I/O\"",
        "language": "C"
    },
    {
        "rule_id": "FIO02-C",
        "rule_title": "Canonicalize path names originating from tainted sources",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO02-C.+Canonicalize+path+names+originating+from+tainted+sources",
        "content": "Path names, directory names, and file names may contain characters that make validation difficult and inaccurate. Furthermore, any path name component can be a symbolic link, which further obscures the actual location or identity of a file. To simplify file name validation, it is recommended that names be translated into their canonical form. Canonicalizing file names makes it much easier to verify a path, directory, or file name by making it easier to compare names.\nBecause the canonical form can vary between operating systems and file systems, it is best to use operating-system-specific mechanisms for canonicalization.\nAs an illustration, here is a function that ensures that a path name refers to a file in the user's home directory on POSIX systems:\n#include <pwd.h>\n#include <unistd.h>\n#include <string.h>\n int verify_file(char *const filename) {\n  /* Get /etc/passwd entry for current user */\n  struct passwd *pwd = getpwuid(getuid());\n  if (pwd == NULL) {\n    /* Handle error */\n    return 0;\n  }\n   const size_t len = strlen( pwd->pw_dir);\n  if (strncmp( filename, pwd->pw_dir, len) != 0) {\n    return 0;\n  }\n  /* Make sure there is only one '/', immediately after homedir */\n  if (strrchr( filename, '/') == filename + len) {\n    return 1;\n  }\n  return 0;\n}\nThe verify_file() function requires that the file name be an absolute path name. Furthermore, it can be deceived if the file name being referenced is actually a symbolic link to a file name not in the users's home directory.\nNoncompliant Code Example\nIn this noncompliant example, argv[1] contains a file name that originates from a tainted source and is opened for writing. Before this file name is used in file operations, it should be validated to ensure that it refers to an expected and valid file. Unfortunately, the file name referenced by argv[1] may contain special characters, such as directory characters, that make validation difficult if not impossible. Furthermore, any path name component in argv[1] may be a symbolic link, resulting in the file name referring to an invalid file even though it passes validation.\nIf validation is not performed correctly, the call to fopen() may result in an unintended file being accessed.\n/* Verify argv[1] is supplied */\n if (!verify_file(argv[1])) {\n  /* Handle error */\n}\n if (fopen(argv[1], \"w\") == NULL) {\n  /* Handle error */\n}\n /* ... */\nCompliant Solution (POSIX)\nCanonicalizing file names is difficult and involves an understanding of the underlying file system.\nThe POSIX realpath() function can assist in converting path names to their canonical form. According to Standard for Information Technology\u2014Portable Operating System Interface (POSIX\u00ae), Base Specifications, Issue 7 (IEEE Std 1003.1, 2013 Edition) [IEEE Std 1003.1:2013],\nThe realpath() function shall derive, from the pathname pointed to by file_name, an absolute pathname that names the same file, whose resolution does not involve '.', '..', or symbolic links.\nFurther verification, such as ensuring that two successive slashes or unexpected special files do not appear in the file name, must be performed. See Section 4.12, \"Pathname Resolution,\" of IEEE Std 1003.1, 2013 Edition, for more details on how path name resolution is performed [IEEE Std 1003.1:2013].\nMany manual pages for the realpath() function come with an alarming warning, such as this one from the Linux Programmer's Manual [Linux 2008]:\nAvoid using this function. It is broken by design since (unless using the non-standard resolved_path == NULL feature) it is impossible to determine a suitable size for the output buffer, resolved_path. According to POSIX a buffer of size PATH_MAX suffices, but PATH_MAX need not be a defined constant, and may have to be obtained using pathconf(3). And asking pathconf(3) does not really help, since on the one hand POSIX warns that the result of pathconf(3) may be huge and unsuitable for mallocing memory. And on the other hand pathconf(3) may return \u22121 to signify that PATH_MAX is not bounded.\nThe libc4 and libc5 implementation contains a buffer overflow (fixed in libc-5.4.13). As a result, set-user-ID programs like mount(8) need a private version.\nThe realpath() function was changed in POSIX.1-2008. Older versions of POSIX allow implementation-defined behavior in situations where the resolved_name is a null pointer. The current POSIX revision and many current implementations (led by glibc and Linux) allocate memory to hold the resolved name if a null pointer is used for this argument.\nThe following statement can be used to conditionally include code that depends on this revised form of the realpath() function:\n#if _POSIX_VERSION >= 200809L || defined (linux)\nConsequently, despite the alarming warnings, it is safe to call realpath() with resolved_name assigned the value NULL (on systems that support it), as shown in this compliant solution:\nchar *realpath_res = NULL;\n /* Verify argv[1] is supplied */\n realpath_res = realpath(argv[1], NULL);\nif (realpath_res == NULL) {\n  /* Handle error */\n}\n if (!verify_file(realpath_res)) {\n  /* Handle error */\n}\n if (fopen(realpath_res, \"w\") == NULL) {\n  /* Handle error */\n}\n /* ... */\n free(realpath_res);\nrealpath_res = NULL;\nIt is also safe to call realpath() with a non-null resolved_path provided that PATH_MAX is defined as a constant in <limits.h>. In this case, the realpath() function expects resolved_path to refer to a character array that is large enough to hold the canonicalized path. If PATH_MAX is defined, allocate a buffer of size PATH_MAX to hold the result of realpath(), as shown in this compliant solution:\nchar *realpath_res = NULL;\nchar *canonical_file name = NULL;\nsize_t path_size = 0;\n /* Verify argv[1] is supplied */\n path_size = (size_t)PATH_MAX;\n if (path_size > 0) {\n  canonical_filename = malloc(path_size);\n   if (canonical_filename == NULL) {\n    /* Handle error */\n  }\n   realpath_res = realpath(argv[1], canonical_filename);\n}\n if (realpath_res == NULL) {\n  /* Handle error */\n}\n if (!verify_file(realpath_res)) {\n  /* Handle error */\n}\nif (fopen(realpath_res, \"w\") == NULL ) {\n  /* Handle error */\n}\n /* ... */\n free(canonical_filename);\ncanonical_filename = NULL;\nCare still must be taken to avoid creating a time-of-check, time-of-use (TOCTOU) condition by using realpath() to check a file name.\nNoncompliant Code Example (POSIX)\nCalling the realpath() function with a non-null resolved_path when PATH_MAX is not defined as a constant is not safe. IEEE Std 1003.1, 2013 Edition [IEEE Std 1003.1:2013], effectively forbids such uses of realpath():\nIf resolved_name is not a null pointer and {PATH_MAX} is not defined as a constant in the <limits.h> header, the behavior is undefined.\nThe rationale from IEEE Std 1003.1, 2013 Edition, explains why this case is unsafe:\nSince realpath( ) has no length argument, if {PATH_MAX} is not defined as a constant in <limits.h>, applications have no way of determining how large a buffer they need to allocate for it to be safe to pass to realpath( ). A {PATH_MAX} value obtained from a prior pathconf( ) call is out-of-date by the time realpath( ) is called. Hence the only reliable way to use realpath( ) when {PATH_MAX} is not defined in <limits.h> is to pass a null pointer for resolved_name so that realpath( ) will allocate a buffer of the necessary size.\nPATH_MAX can vary among file systems (which is the reason for obtaining it with pathconf() and not sysconf()). A PATH_MAX value obtained from a prior pathconf() call can be invalidated, for example, if a directory in the path is replaced with a symlink to a different file system or if a new file system is mounted somewhere along the path.\nchar *realpath_res = NULL;\nchar *canonical_filename = NULL;\nsize_t path_size = 0;\nlong pc_result;\n /* Verify argv[1] is supplied */\n errno = 0;\n /* Query for PATH_MAX */\npc_result = pathconf(argv[1], _PC_PATH_MAX);\n if ( (pc_result == -1) && (errno != 0) ) {\n  /* Handle error */\n} else if (pc_result == -1) {\n  /* Handle error */\n} else if (pc_result <= 0) {\n  /* Handle error */\n}\npath_size = (size_t)pc_result;\n if (path_size > 0) {\n  canonical_filename = malloc(path_size);\n   if (canonical_filename == NULL) {\n    /* Handle error */\n  }\n   realpath_res = realpath(argv[1], canonical_filename);\n}\n if (realpath_res == NULL) {\n  /* Handle error */\n}\n if (!verify_file(realpath_res)) {\n  /* Handle error */\n}\n if (fopen(realpath_res, \"w\") == NULL) {\n  /* Handle error */\n}\n /* ... */\n free(canonical_filename);\ncanonical_filename = NULL;\nImplementation Details (Linux)\nThe libc4 and libc5 implementations of realpath() contain a buffer overflow (fixed in libc-5.4.13) [VU#743092]. Consequently, programs need a private version of this function in which this issue is known to be fixed.\nCompliant Solution (glibc)\nThe realpath() function can be difficult to use and inefficient. Another solution, available as a GNU extension, is canonicalize_file_name(). This function has the same effect as realpath(), but the result is always returned in a newly allocated buffer [Drepper 2006].\n/* Verify argv[1] is supplied */\n char *canonical_filename = canonicalize_file_name(argv[1]);\nif (canonical_filename == NULL) {\n  /* Handle error */\n}\n /* Verify file name */\n if (fopen(canonical_filename, \"w\") == NULL) {\n  /* Handle error */\n}\n /* ... */\n free(canonical_filename);\ncanonical_filename = NULL;\nBecause memory is allocated by canonicalize_file_name(), the programmer must remember to free the allocated memory.\nNoncompliant Code Example (Windows)\nThis noncompliant code example uses the Windows function GetFullPathName() for canonicalization [MSDN]:\n/* ... */\n enum { INITBUFSIZE = 256 };\nDWORD ret = 0;\nDWORD new_ret = 0;\nchar *canonical_filename;\nchar *new_file;\nchar *file_name;\n /* ... */\n file_name = (char *)malloc(strlen(argv[1])+1);\ncanonical_filename = (char *)malloc(INITBUFSIZE);\n if ( (file_name != NULL) && (canonical_filename != NULL) ) {\n  strcpy(file_name, argv[1]);\n  strcpy(canonical_filename, \"\");\n} else {\n  /* Handle error */\n}\n ret = GetFullPathName(\n  file_name,\n  INITBUFSIZE,\n  canonical_filename,\n  NULL\n);\n if (ret == 0) {\n  /* Handle error */\n}\nelse if (ret > INITBUFSIZE) {\n  new_file = (char *)realloc(canonical_filename, ret);\n  if (new_file == NULL) {\n    /* Handle error */\n  }\n   canonical_filename = new_file;\n   new_ret = GetFullPathName(\n    file_name,\n    ret,\n    canonical_filename,\n    NULL\n  );\n  if (new_ret > ret) {\n    /*\n     * The length of the path changed between calls\n     * to GetFullPathName(); handle error.\n     */\n  }\n  else if (new_ret == 0) {\n    /* Handle error */\n  }\n}\n if (!verify_file(canonical_filename)) {\n  /* Handle error */\n}\n/* Verify file name before using */\nThe GetFullPathName() function can be used to eliminate the .. and /./ components from a path name, but there are numerous other canonicalization issues that are not addressed by use of GetFullPathName(), including universal naming convention (UNC) shares, short (8.3) names, long names, Unicode names, trailing dots, forward slashes, backslashes, short cuts, and so on.\nCare also must be taken to avoid creating a TOCTOU condition by using GetFullPathName() to check a file name.\nCompliant Solution (Windows)\nProducing canonical file names for Windows operating systems is extremely complex and beyond the scope of this standard. The best advice is to try to avoid making decisions based on a path, directory, or file name [Howard 2002]. Alternatively, use operating-system-based mechanisms, such as access control lists (ACLs) or other authorization techniques.\nRisk Assessment\nFile-related vulnerabilities can often be exploited to cause a program with elevated privileges to access an unintended file. Canonicalizing a file path makes it easier to identify the reference file object.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO02-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nIO.TAINT.FNAME\nTainted Filename\nCompass/ROSE\n\n\nCould catch violations of this rule by enforcing that any call to open() or fopen() is preceded by a canonicalization routine\u2014that is, a call to realpath() or canonicalize_file_name(). This call will catch some false positives, as ROSE cannot tell when canonicalization is warranted. False positives can be reduced (but not eliminated) by only reporting instances of fopen() or open() where the file name string has some other processing done to it. This reflects the fact that canonicalization is only necessary for doing verification based on the file name string\nHelix QAC\n2025.2\nC5047\nC1611\nC1612\nC1613\nC3519\n\nKlocwork\n2025.2\nSV.DLLPRELOAD.NONABSOLUTE.DLL\nSV.TOCTOU.FILE_ACCESS\n\nLDRA tool suite\n9.7.1\n85 D\nPartially implemented\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. FIO02-C\nChecks for vulnerable path manipulation (rule fully covered)\nRelated Vulnerabilities\nCVE-2009-1760 results from a violation of this recommendation. Until version 0.4.13, libtorrent attempts to rule out unsafe file paths by checking only against the \"..\" string. An attacker can exploit this to access any file on the system by using more complex relative paths [xorl 2009].\nCVE-2014-9390 results from a violation of this recommendation. When git is used on a case-insensitive file system (e.g., NTFS under Windows, HFS+ under Mac OS X), a file named \".Git/config\" in the repository would overwrite the user's local \".git/config\" file.  This config file can define external commands (e.g., a custom diff utility), and it can lead to arbitrary code execution.  The commit that fixes this vulnerability is https://github.com/git/git/commit/77933f4449b8d6aa7529d627f3c7b55336f491db.  The release notes briefly discuss other canonicalization issues, in addition to case-insensitiivity, under Windows and Mac OS X.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO02-CPP. Canonicalize path names originating from untrusted sources\nCERT Oracle Secure Coding Standard for Java FIO16-J. Canonicalize path names before validating them\nISO/IEC TR 24772:2013 Path Traversal [EWR]\nMITRE CWE\nCWE-22, Path traversal\nCWE-23, Relative Path Traversal\nCWE-28, Path Traversal: '..\\filedir'\nCWE-40, Path Traversal: '\\\\UNC\\share\\name\\' (Windows UNC Share)\nCWE-41, Failure to resolve path equivalence\nCWE-59, Failure to resolve links before file access (aka \"link following\")\nCWE-73, External control of file name or path\nBibliography\n[Drepper 2006] Section 2.1.2, \"Implicit Memory Allocation\"\n[Howard 2002] Chapter 11, \"Canonical Representation Issues\"\n[Linux 2008] realpath(3)\npathconf(3)\n[MSDN] \"GetFullPathName Function\"\n[IEEE Std 1003.1:2013] Section 4.12, \"Pathname Resolution\"\nSystem Interfaces: realpath\n[Seacord 2013] Chapter 8, \"File I/O\"\n[VU#743092]\n[xorl 2009] CVE-2009-1760: libtorrent Arbitrary File Overwrite",
        "language": "C"
    },
    {
        "rule_id": "FIO03-C",
        "rule_title": "Do not make assumptions about fopen() and file creation",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO03-C.+Do+not+make+assumptions+about+fopen%28%29+and+file+creation",
        "content": "The C fopen() function is used to open an existing file or create a new one. The C11 version of the fopen() function provides a mode flag, x, that provides the mechanism needed to determine if the file that is to be opened exists. Not using this mode flag can lead to a program overwriting or accessing an unintended file.\nNoncompliant Code Example (fopen())\nIn this noncompliant code example, the file referenced by file_name is opened for writing. This example is noncompliant if the programmer's intent was to create a new file, but the referenced file already exists.\nchar *file_name;\nFILE *fp;\n /* Initialize file_name */\n fp = fopen(file_name, \"w\");\nif (!fp) {\n  /* Handle error */\n}\nCompliant Solution (fopen(\"x\"), C11)\nStarting in C11 a new mode suffix (\"x\") was added to the fopen() function which causes fopen() to return NULL if the file already exists or cannot be created [ISO/IEC 9899:2011].\nchar *file_name;\nFILE *fp;\n /* Initialize file_name */\n fp = fopen(file_name, \"wx\");\nif (!fp) {\n  /* Handle error */\n}\nCompliant Solution (open(), POSIX)\nThe open() function, as defined in the Standard for Information Technology\u2014Portable Operating System Interface (POSIX\u00ae), Base Specifications, Issue 7 [IEEE Std 1003.1:2013], is available on many platforms and provides finer control than fopen(). In particular, open() accepts the O_CREAT and O_EXCL flags. When used together, these flags instruct the open() function to fail if the file specified by file_name already exists.\nchar *file_name;\nint new_file_mode;\n /* Initialize file_name and new_file_mode */\n int fd = open(file_name, O_CREAT | O_EXCL | O_WRONLY, new_file_mode);\nif (fd == -1) {\n  /* Handle error */\n}\nCare should be taken when using O_EXCL with remote file systems because it does not work with NFS version 2. NFS version 3 added support for O_EXCL mode in open(). IETF RFC 1813 [Callaghan 1995] defines the EXCLUSIVE value to the mode argument of CREATE:\nEXCLUSIVE specifies that the server is to follow exclusive creation semantics, using the verifier to ensure exclusive creation of the target. No attributes may be provided in this case, since the server may use the target file metadata to store the createverf3 verifier.\nFor examples of how to check for the existence of a file without opening it, see recommendation FIO10-C. Take care when using the rename() function.\nCompliant Solution (fdopen(), POSIX)\nFor code that operates on FILE pointers and not file descriptors, the POSIX fdopen() function can be used to associate an open stream with the file descriptor returned by open(), as shown in this compliant solution [IEEE Std 1003.1:2013]:\nchar *file_name;\nint new_file_mode;\nFILE *fp;\nint fd;\n /* Initialize file_name and new_file_mode */\n fd = open(file_name, O_CREAT | O_EXCL | O_WRONLY, new_file_mode);\nif (fd == -1) {\n  /* Handle error */\n}\n fp = fdopen(fd, \"w\");\nif (fp == NULL) {\n  /* Handle error */\n}\nCompliant Solution (Windows)\nThe Win32 API  CreateFile() allows a programmer to create or open a file depending on the flags passed in. Passing in the CREATE_NEW flag ensures the call fails if the file already exists. This compliant solution demonstrates how to open a file for reading and writing without sharing access to the file such that the call fails if the file already exists.\nTCHAR *file_name;\nHANDLE hFile = CreateFile(file_name, GENERIC_READ | GENERIC_WRITE, 0, 0,\n                          CREATE_NEW, FILE_ATTRIBUTE_NORMAL, 0);\nif (INVALID_HANDLE_VALUE == hFile) {\n  DWORD err = GetLastError();\n  if (ERROR_FILE_EXISTS == err) {\n    /* Handle file exists error */\n  } else {\n    /* Handle other error */\n  }\n}\nRisk Assessment\nThe ability to determine whether an existing file has been opened or a new file has been created provides greater assurance that a file other than the intended file is not acted upon.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO03-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCoverity 6.5 OPEN_ARGS Fully implemented\nHelix QAC\n2025.2\nC5012\nLDRA tool suite\n9.7.1\n44 S Enhanced Enforcement\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. FIO03-C Checks for file not opened in exclusive mode\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO03-CPP. Do not make assumptions about fopen() and file creation\nBibliography\n[Callaghan 1995] IETF RFC 1813 NFS Version 3 Protocol Specification\n[IEEE Std 1003.1:2013] System Interfaces: open\n[ISO/IEC 9899:2011] Subclause 7.21.5.3, \"The fopen Function\"\n[Loosemore 2007] Section 12.3, \"Opening Streams\"\n[Seacord 2013] Chapter 8, \"File I/O\"",
        "language": "C"
    },
    {
        "rule_id": "FIO05-C",
        "rule_title": "Identify files using multiple file attributes",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO05-C.+Identify+files+using+multiple+file+attributes",
        "content": "Files can often be identified by attributes other than the file name, such as by comparing file ownership or creation time. Information about a file that has been created and closed can be stored and then used to validate the identity of the file when it is reopened.\nComparing multiple attributes of the file increases the likelihood that the reopened file is the same file that had been previously operated on.\nFile identification is less of an issue if applications maintain their files in secure directories, where they can be accessed only by the owner of the file and (possibly) by a system administrator. (See FIO15-C. Ensure that file operations are performed in a secure directory.)\nNoncompliant Code Example (Reopen)\nThis noncompliant code example opens a file for writing, closes it, opens the same named file for reading, and then closes it again. The logic relies solely on the file name to identify the file.\nchar *file_name;\n\n/* Initialize file_name */\n\nFILE *fd = fopen(file_name, \"w\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/*... Write to file ...*/\n\nfclose(fd);\nfd = NULL;\n\n/*\n * A race condition here allows for an attacker  \n * to switch out the file for another. \n */\n\n/* ... */\n\nfd = fopen(file_name, \"r\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/*... Read from file ...*/\n\nfclose(fd);\nfd = NULL;\nThere is no guarantee that the file opened for reading is the same file that is opened for writing. An attacker can replace the original file (for example, with a symbolic link) between the first fclose() and the second fopen().\nCompliant Solution (POSIX) (Device/I-node)\nReopening a file stream should generally be avoided. However, it may sometimes be necessary in long-running applications to avoid depleting available file descriptors.\nThis compliant solution uses a \"check, use, check\" pattern to ensure that the file opened for reading is the same file that was opened for writing. In this solution, the file is opened for writing using the open() function. If the file is successfully opened, the fstat() function is used to read information about the file into the orig_st structure. When the file is reopened for reading, information about the file is read into the new_st structure, and the st_dev and st_ino fields in orig_st and new_st are compared to improve identification.\nstruct stat orig_st;\nstruct stat new_st;\nchar *file_name;\n\n/* Initialize file_name */\n\nint fd = open(file_name, O_WRONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n\n/*... Write to file ...*/\n\nif (fstat(fd, &orig_st) == -1) {\n  /* Handle error */\n}\nclose(fd);\nfd = -1;\n\n/* ... */\n\nfd = open(file_name, O_RDONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n\nif (fstat(fd, &new_st) == -1) {\n  /* Handle error */\n}\n\nif ((orig_st.st_dev != new_st.st_dev) ||\n    (orig_st.st_ino != new_st.st_ino)) {\n  /* File was tampered with! */\n}\n\n/*... Read from file ...*/\n\nclose(fd);\nfd = -1;\nThis solution enables the program to recognize if an attacker has switched files between the first close() and the second open(). The program does not recognize whether the file has been modified in place, however.\nAlternatively, the same solution can be implemented using the C fopen() function to open the file and the POSIX fileno() function to convert the FILE object pointer to a file descriptor.\nThe structure members st_mode, st_ino, st_dev, st_uid, st_gid, st_atime, st_ctime, and st_mtime all should have meaningful values for all file types on POSIX-compliant systems. The st_ino field contains the file serial number. The st_dev field identifies the device containing the file. The st_ino and st_dev fields, taken together, uniquely identify the file. The st_dev value is not necessarily consistent across reboots or system crashes, however, so this field may not be useful for file identification if a system crash or reboot may have occurred before you attempt to reopen a file.\nCall the fstat() function on a file that is already opened instead of calling stat() on a file name followed by open(). Doing so ensures that the file for which the information is being collected is the same file that is already opened. See FIO01-C. Be careful using functions that use file names for identification for more information on avoiding race conditions resulting from the use of file names for identification.\nIt may also be necessary to call open() with O_NONBLOCK, as per FIO32-C. Do not perform operations on devices that are only appropriate for files, to ensure that the program does not hang when trying to open special files.\nThis compliant solution may not work in some cases. For instance, a long-running service might choose to occasionally reopen a log file to add log messages but leave the file closed so that the log file may be periodically rotated. In this case, the i-node number would change, and this solution would no longer apply.\nCompliant Solution (POSIX) (Open Only Once)\nA simpler solution is to not reopen the file. In this code example, the file is opened once for both writing and reading. Once writing is complete, the fseek() function resets the file pointer to the beginning of the file, and its contents are read back. (See void FIO07-C. Prefer fseek() to rewind().)\nBecause the file is not reopened, the possibility of an attacker tampering with the file between the writes and subsequent reads is eliminated.\nchar *file_name;\nFILE *fd;\n\n/* Initialize file_name */\n\nfd = fopen(file_name, \"w+\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/*... Write to file ...*/\n\n/* Go to beginning of file */\nfseek(fd, 0, SEEK_SET);\n\n/*... Read from file ...*/\n\nfclose(fd);\nfd = NULL;\nBe sure to use fflush() after writing data to the file, in accordance with FIO39-C. Do not alternately input and output from a stream without an intervening flush or positioning call.\nNoncompliant Code Example (Owner)\nIn this noncompliant code example, the programmer's intent is to open a file for reading, but only if the user running the process owns the specified file. This requirement is more restrictive than that imposed by the operating system, which requires only that the effective user have permissions to read the file. The code, however, relies solely on the file name to identify the file.\nchar *file_name;\nFILE *fd;\n\n/* Initialize file_name */\n\nfd = fopen(file_name, \"r+\");\nif (fd == NULL) {\n  /* Handle error */\n}\n\n/* Read user's file */\n\nfclose(fd);\nfd = NULL; \nIf this code is run with superuser privileges, for example, as part of a setuid-root program, an attacker can exploit this program to read files for which the real user normally lacks sufficient privileges, including files not owned by the user.\nCompliant Solution (POSIX) (Owner)\nIn this compliant solution, the file is opened using the open() function. If the file is successfully opened, the fstat() function is used to read information about the file into the stat structure. This information is compared with existing information about the real user (obtained by the getuid() and getgid() functions).\nstruct stat st;\nchar *file_name;\n\n/* Initialize file_name */\n\nint fd = open(file_name, O_RDONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n\nif ((fstat(fd, &st) == -1) ||\n   (st.st_uid != getuid()) ||\n   (st.st_gid != getgid())) {\n  /* File does not belong to user */\n}\n\n/*... Read from file ...*/\n\nclose(fd);\nfd = -1;\nBy matching the file owner's user and group IDs to the process's real user and group IDs, this program now successfully restricts access to files owned by the real user of the program. This solution can be used to verify that the owner of the file is the one the program expects, reducing opportunities for attackers to replace configuration files with malicious ones, for example.\nAlternatively, the same solution can be implemented using the C fopen() function to open the file and the POSIX fileno() function to convert the FILE object pointer to a file descriptor.\nRisk Assessment\nMany file-related vulnerabilities are exploited to cause a program to access an unintended file. Proper file identification is necessary to prevent exploitation.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO05-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCompass/ROSE\n\n\nCould report possible violations of this rule merely by reporting any open() or fopen() call that did not have a subsequent call to fstat()\nLDRA tool suite\n9.7.1\n44 S Enhanced Enforcement\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO05-CPP. Identify files using multiple file attributes\nISO/IEC TR 24772:2013 Path Traversal [EWR]\nMITRE CWE CWE-37, Path issue\u2014Slash absolute path\nCWE-38, Path Issue\u2014Backslash absolute path\nCWE-39, Path Issue\u2014Drive letter or Windows volume\nCWE-62, UNIX hard link\nCWE-64, Windows shortcut following (.LNK)\nCWE-65, Windows hard link\nBibliography\n[Drepper 2006] Section 2.2.1 \"Identification when Opening\"\n[IEEE Std 1003.1:2013] System Interfaces: open\nSystem Interfaces: fstat\n[Seacord 2013] Chapter 8, \"File I/O\"",
        "language": "C"
    },
    {
        "rule_id": "FIO06-C",
        "rule_title": "Create files with appropriate access permissions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions",
        "content": "Creating a file with insufficiently restrictive access permissions may allow an unprivileged user to access that file. Although access permissions are heavily dependent on the file system, many file-creation functions provide mechanisms to set (or at least influence) access permissions. When these functions are used to create files, appropriate access permissions should be specified to prevent unintended access.\nWhen setting access permissions, it is important to make sure that an attacker cannot alter them. (See FIO15-C. Ensure that file operations are performed in a secure directory.)\nNoncompliant Code Example (fopen())\nThe fopen() function does not allow the programmer to explicitly specify file access permissions. In this noncompliant code example, if the call to fopen() creates a new file, the access permissions are implementation-defined:\nchar *file_name;\nFILE *fp;\n /* Initialize file_name */\n fp = fopen(file_name, \"w\");\nif (!fp){\n  /* Handle error */\n}\nImplementation Details\nOn POSIX-compliant systems, the permissions may be restricted by the value of the POSIX umask() function [IEEE Std 1003.1:2013].\nThe operating system modifies the access permissions by computing the intersection of the inverse of the umask and the permissions requested by the process [Viega 2003]. For example, if the variable requested_permissions contained the permissions passed to the operating system to create a new file, the variable actual_permissions would be the actual permissions that the operating system would use to create the file:\nrequested_permissions = 0666;\nactual_permissions = requested_permissions & ~umask();\nFor OpenBSD and Linux operating systems, any file created will have mode S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH (0666), as modified by the process's umask value. (See fopen(3) in the OpenBSD Manual Pages [OpenBSD].)\nNoncompliant Code Example (open(), POSIX)\nUsing the POSIX open() function to create a file but failing to provide access permissions for that file may cause the file to be created with overly permissive access permissions. This omission has been known to lead to vulnerabilities\u2014for example, CVE-2006-1174.\nchar *file_name;\nint fd;\n /* Initialize file_name */\n fd = open(file_name, O_CREAT | O_WRONLY);\n/* Access permissions were missing */\n if (fd == -1){\n  /* Handle error */\n}\nThis example also violates EXP37-C. Call functions with the correct number and type of arguments.\nCompliant Solution (open(), POSIX)\nAccess permissions for the newly created file should be specified in the third argument to open(). Again, the permissions are modified by the value of umask().\nchar *file_name;\nint file_access_permissions;\n /* Initialize file_name and file_access_permissions */\n int fd = open(\n  file_name,\n  O_CREAT | O_WRONLY,\n  file_access_permissions\n);\nif (fd == -1){\n  /* Handle error */\n}\nJohn Viega and Matt Messier also provide the following advice [Viega 2003]:\nDo not rely on setting the umask to a \"secure\" value once at the beginning of the program and then calling all file or directory creation functions with overly permissive file modes. Explicitly set the mode of the file at the point of creation. There are two reasons to do this. First, it makes the code clear; your intent concerning permissions is obvious. Second, if an attacker managed to somehow reset the umask between your adjustment of the umask and any of your file creation calls, you could potentially create sensitive files with wide-open permissions.\nRisk Assessment\nCreating files with weak access permissions may allow unintended access to those files.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO06-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADFUNC.CREATEFILE\n(customization)\nUse of CreateFile\nCodeSonar's custom checking infrastructure allows users to implement checks such as the following.\nA check for all uses of fopen().\nA check for calls to open() with only two arguments.\nA check for calls to open() where the third argument does not satisfy some specified requirement.\nHelix QAC\n2025.2\nC5013\nLDRA tool suite\n9.7.1\n44 S Enhanced Enforcement\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. FIO06-C Checks for file opened without setting access permissions.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO06-CPP. Create files with appropriate access permissions\nCERT Oracle Secure Coding Standard for Java FIO01-J. Create files with appropriate access permissions\nISO/IEC TR 24772:2013 Missing or Inconsistent Access Control [XZN]\nMITRE CWE CWE-276, Insecure default permissions\nCWE-279, Insecure execution-assigned permissions\nCWE-732, Incorrect permission assignment for critical resource\nBibliography\n[CVE]\n[Dowd 2006] Chapter 9, \"UNIX 1: Privileges and Files\"\n[IEEE Std 1003.1:2013] XSH, System Interfaces, open\nXSH, System Interfaces, umask\n[ISO/IEC 9899:2011] Subclause K.3.5.2.1, \"The fopen_s Function\"\n[OpenBSD]\n[Viega 2003] Section 2.7, \"Restricting Access Permissions for New Files on UNIX\"",
        "language": "C"
    },
    {
        "rule_id": "FIO08-C",
        "rule_title": "Take care when calling remove() on an open file",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO08-C.+Take+care+when+calling+remove%28%29+on+an+open+file",
        "content": "Invoking remove() on an open file is implementation-defined. Removing an open file is sometimes recommended to hide the names of temporary files that may be prone to attack. (See FIO21-C. Do not create temporary files in shared directories.)\nIn cases requiring the removal of an open file, a more strongly defined function, such as the POSIX unlink() function, should be considered. To be strictly conforming and portable, remove() should not be called on an open file.\nNoncompliant Code Example\nThis noncompliant code example shows a case where a file is removed while it is still open:\nchar *file_name;\nFILE *file;\n /* Initialize file_name */\n file = fopen(file_name, \"w+\");\nif (file == NULL) {\n  /* Handle error condition */\n}\n /* ... */\n if (remove(file_name) != 0) {\n  /* Handle error condition */\n}\n /* Continue performing I/O operations on file */\n fclose(file);\nSome implementations will not remove the file specified by file_name because the stream is still open.\nImplementation Details\nCode compiled for Microsoft Windows prevents the remove() call from succeeding when the file is open, meaning that the file link will remain after execution completes.\nCompliant Solution (POSIX)\nThis compliant solution uses the POSIX unlink() function to remove the file. The unlink() function is guaranteed to unlink the file from the file system hierarchy but keep the file on disk until all open instances of the file are closed [IEEE Std 1003.1:2013].\nFILE *file;\nchar *file_name;\n /* Initialize file_name */\n file = fopen(file_name, \"w+\");\nif (file == NULL) {\n  /* Handle error condition */\n}\n if (unlink(file_name) != 0) {\n  /* Handle error condition */\n}\n /* Continue performing I/O operations on file */\n fclose(file);\nNote that there is a race window between the fopen() call and the unlink() call, which could be exploited. This exploitation can be mitigated if the operations occur in a secure directory; see FIO45-C. Avoid TOCTOU race conditions while accessing files for more information.\nRisk Assessment\nCalling remove() on an open file has different implications for different implementations and may cause abnormal termination if the removed file is written to or read from, or it may result in unintended information disclosure from files not deleted as intended.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO08-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\n(customization) Users can implement a custom check for calls to remove() on a file that is currently open.\nCompass/ROSE\n\n\n\nHelix QAC\n2025.2\nC5014\nLDRA tool suite\n9.7.1\n81 D\nFully implemented\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. FIO08-C\nChecks for function remove() called on open file\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO08-CPP. Take care when calling remove() on an open file\nBibliography\n[IEEE Std 1003.1:2013] unlink()",
        "language": "C"
    },
    {
        "rule_id": "FIO10-C",
        "rule_title": "Take care when using the rename() function",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO10-C.+Take+care+when+using+the+rename%28%29+function",
        "content": "The rename() function has the following prototype:\nint rename(const char *src_file, const char *dest_file);\nIf the file referenced by dest_file exists prior to calling rename(), the behavior is implementation-defined. On POSIX systems, the destination file is removed. On Windows systems, the rename() fails. Consequently, issues arise when trying to write portable code or when trying to implement alternative behavior.\nPreserve Existing Destination File\nIf the desired behavior is to ensure that the destination file is not erased or overwritten, POSIX programmers must implement additional safeguards.\nNoncompliant Code Example (POSIX)\nThis code example is noncompliant because any existing destination file is removed by rename():\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\nCompliant Solution (POSIX)\nIf the programmer's intent is not to remove an existing destination file, the POSIX access() function can be used to check for the existence of a file [IEEE Std 1003.1:2013]. This compliant solution renames the source file only if the destination file does not exist:\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n if (access(dest_file, F_OK) != 0) {\n  if (rename(src_file, dest_file) != 0) {\n    /* Handle error condition */\n  }\n}\nelse {\n  /* Handle file-exists condition */\n}\nThis code contains an unavoidable race condition between the call to access() and the call to rename() and can consequently be safely executed only when the destination file is located within a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory.)\nOn file systems where the program does not have sufficient permissions in the directory to view the file, access() may return -1 even when the file exists. In such cases, rename() will also fail because the program lacks adequate permissions to perform the operation.\nIn situations where the source file is supposed not to be a directory or symbolic link, an alternative solution is to use link() to link the source file to the destination file and then use unlink() (or remove()) to delete the source file. Because link() fails if the destination file exists, the need for calling access() is avoided. However, this solution has two race conditions related to the source file. First, before calling link(), the program must use lstat() to check that the source file is not a directory or symbolic link. Second, the source file could change during the time window between the link() and the unlink(). Consequently, this alternative solution can be safely executed only when the source file is located within a secure directory.\nCompliant Solution (Windows)\nOn Windows, the rename() function fails if a\nfile or directory specified by newname already exists or could not be created (invalid path). [MSDN]\nConsequently, it is unnecessary to explicitly check for the existence of the destination file before calling rename().\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\nRemove Existing Destination File\nIf the desired behavior is to ensure that the destination file is erased by the rename() operation, Windows programmers must write additional code.\nNoncompliant Code Example (Windows)\nIf the intent of the programmer is to remove the file referenced by dest_file if it exists prior to calling rename(), this code example is noncompliant on Windows platforms because rename() will fail:\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error */\n}\nCompliant Solution (Windows)\nOn Windows systems, it is necessary to explicitly remove the destination file before calling rename() if the programmer wants the file to be overwritten and the rename() operation to succeed:\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n if (_access_s(dest_file, 0) == 0) {\n  if (remove(dest_file) != 0) {\n    /* Handle error condition */\n  }\n}\n if (rename(src_file, dest_file) != 0) {\n  /* Handle error condition */\n}\nThis code contains unavoidable race conditions between the calls to _access_s(), remove(), and rename() and can consequently be safely executed only within a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory.)  Another option would be to use the MoveFileEx API and pass in the MOVEFILE_REPLACE_EXISTING flag:\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n if (!MoveFileEx(src_file, dest_file, MOVEFILE_REPLACE_EXISTING)) {\n  /* Handle error condition */\n}\nAlthough this code is not portable, it does avoid the race condition when using _access_s(), remove(), and rename().\nCompliant Solution (POSIX)\nOn POSIX systems, if the destination file exists prior to calling rename(), the file is automatically removed:\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\nif (rename(src_file, dest_file) != 0) {\n  /* Handle error condition */\n}\nPortable Behavior\nA programmer who wants an application to behave the same on any C implementation must first determine what behavior to implement.\nCompliant Solution (Remove Existing Destination File)\nThis compliant solution ensures that any destination file is portably removed:\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n (void)remove(dest_file);\n if (rename(src_file, dest_file) != 0) {\n  /* Handle error condition */\n}\nThis code contains an unavoidable race condition between the call to remove() and the call to rename() and consequently can be safely executed only within a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory.)\nThe return value of remove() is deliberately not checked because it is expected to fail if the file does not exist. If the file exists but cannot be removed, the rename() call will also fail, and the error will be detected at that point. This is a valid exception (EXP12-C-EX1) to EXP12-C. Do not ignore values returned by functions.\nCompliant Solution (Preserve Existing Destination File)\nThis compliant solution renames the source file only if the destination file does not exist:\nconst char *src_file = /* ... */;\nconst char *dest_file = /* ... */;\n if (!file_exists(dest_file)) {\n  if (rename(src_file, dest_file) != 0) {\n    /* Handle error condition */\n  }\n}\nelse {\n  /* Handle file-exists condition */\n}\nThis code contains an unavoidable race condition between the call to file_exists() and the call to rename() and can consequently be safely executed only within a secure directory. (See FIO15-C. Ensure that file operations are performed in a secure directory.)\nThe file_exists() function is provided by the application and is not shown here because it must be implemented differently on different platforms. (On POSIX systems, it would use access(); on Windows, _access_s(); and on other platforms, whatever function is available to test file existence.)\nRisk Assessment\nCalling rename() has implementation-defined behavior when the new file name refers to an existing file. Incorrect use of rename() can result in a file being unexpectedly overwritten or other unexpected behavior.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO10-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\n(customization) Users can add a custom check for all uses of rename().\nHelix QAC\n2025.2\nC5015\nLDRA tool suite\n9.7.1\n592 S Fully Implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO10-CPP. Take care when using the rename() function\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, access\n[MSDN] rename()",
        "language": "C"
    },
    {
        "rule_id": "FIO13-C",
        "rule_title": "Never push back anything other than one read character",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO13-C.+Never+push+back+anything+other+than+one+read+character",
        "content": "Subclause 7.21.7.10 of the C Standard [ISO/IEC 9899:2011] defines ungetc() as follows:\nThe ungetc function pushes the character specified by c (converted to an unsigned char) back onto the input stream pointed to by stream. Pushed-back characters will be returned by subsequent reads on that stream in the reverse order of their pushing. A successful intervening call (with the stream pointed to by stream) to a file positioning function (fseek, fsetpos, or rewind) discards any pushed-back characters for the stream. The external storage corresponding to the stream is unchanged.\nOne character of pushback is guaranteed.\nConsequently, multiple calls to ungetc() on the same stream must be separated by a call to a read function or a file-positioning function (which will discard any data pushed by ungetc()).\nLikewise, for ungetwc(), C guarantees only one wide character of pushback (subclause 7.29.3.10). Consequently, multiple calls to ungetwc() on the same stream must be separated by a call to a read function or a file-positioning function (which will discard any data pushed by ungetwc()).\nNoncompliant Code Example\nIn this noncompliant code example, more than one character is pushed back on the stream referenced by fp:\nFILE *fp;\nchar *file_name;\n /* Initialize file_name */\n fp = fopen(file_name, \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n /* Read data */\n if (ungetc('\\n', fp) == EOF) {\n  /* Handle error */\n}\nif (ungetc('\\r', fp) == EOF) {\n  /* Handle error */\n}\n /* Continue */\nCompliant Solution\nIf more than one character needs to be pushed by ungetc(), then fgetpos() and fsetpos() should be used before and after reading the data instead of pushing it back with ungetc(). Note that this solution applies only if the input is seekable.\nFILE *fp;\nfpos_t pos;\nchar *file_name;\n /* Initialize file_name */\n fp = fopen(file_name, \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n /* Read data */\n if (fgetpos(fp, &pos)) {\n  /* Handle error */\n}\n /* Read the data that will be \"pushed back\" */\n if (fsetpos(fp, &pos)) {\n  /* Handle error */\n}\n /* Continue */\nRemember to always call fgetpos() before fsetpos(). (See FIO44-C. Only use values for fsetpos() that are returned from fgetpos().)\nRisk Assessment\nIf used improperly, ungetc() and ungetwc() can cause data to be truncated or lost.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO13-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\n(customization) Users can implement a custom check that triggers a warning when ungetc() is called twice on the same stream without an intervening call to a read function or a file-positioning function.\nCompass/ROSE\n\n\nCan detect simple violations of this recommendation. In particular, it warns when two calls to ungetc() on the same stream are not interspersed with a file-positioning or file-read function. It cannot handle cases where ungetc() is called from inside a loop\nLDRA tool suite\n9.7.1\n83 D\nPartially implemented\nPC-lint Plus\n1.4\n2470\nFully supported\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2011] Subclause 7.21.7.10, \"The ungetc Function\"",
        "language": "C"
    },
    {
        "rule_id": "FIO14-C",
        "rule_title": "Understand the difference between text mode and binary mode with file streams",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO14-C.+Understand+the+difference+between+text+mode+and+binary+mode+with+file+streams",
        "content": "Input and output are mapped into logical data streams whose properties are more uniform than their various inputs and outputs. Two forms of mapping are supported, one for text streams and one for binary streams. They differ in the actual representation of data as well as in the functionality of some C functions.\nText Streams\nRepresentation\nCharacters may have to be altered to conform to differing conventions for representing text in the host environment. As a consequence, data read to or written from a text stream will not necessarily compare equal to the stream's byte content.\nThe following code opens the file myfile as a text stream:\nchar *file_name;\n\n/* Initialize file_name */\n\nFILE *file = fopen(file_name, \"w\");\n/* Check for errors */\nfputs(\"\\n\", file);\nEnvironments may model line breaks differently. For example, on Windows, this code writes 2 bytes (a carriage return and then a newline) to the file, whereas on POSIX systems, this code writes only 1 byte (a newline).\nfseek()\nFor a text stream, the offset for fseek() must be either 0 or a value returned by an earlier successful call to the ftell() function (on a stream associated with the same file) with a mode of SEEK_SET.\nungetc()\nThe ungetc() function causes the file position indicator to be unspecified until all pushed-back characters are read. As a result, care must be taken that file-position-related functions are not used while this is true.\nBinary Streams\nRepresentation\nA binary stream is an ordered sequence of characters that can transparently record internal data. As a consequence, data read from or written to a binary stream will necessarily compare equal to the stream's byte content.\nThe following code opens the file myfile as a binary stream:\nchar *file_name;\n\n/* Initialize file_name */\n\nFILE *file = fopen(file_name, \"wb\");\n/* Check for errors */\nfputs(\"\\n\", file);\nRegardless of environment, this code writes exactly 1 byte (a newline).\nfseek()\nAccording to the C Standard, a binary stream may be terminated with an unspecified number of null characters and need not meaningfully support fseek() calls with a mode of SEEK_END. Consequently, do not call fseek() on a binary stream with a mode of SEEK_END.\nungetc()\nThe ungetc() function causes the file-position indicator to be decremented by 1 for each successful call, with the value being indeterminate if it is 0 before any call. As a result, ungetc() must never be called on a binary stream where the file position indicator is 0.\nRisk Assessment\nFailure to understand file stream mappings can result in unexpectedly formatted files.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO14-C\nLow\nProbable\nNo\nNo\nP2\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO14-CPP. Understand the difference between text mode and binary mode with file streams",
        "language": "C"
    },
    {
        "rule_id": "FIO15-C",
        "rule_title": "Ensure that file operations are performed in a secure directory",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO15-C.+Ensure+that+file+operations+are+performed+in+a+secure+directory",
        "content": "File operations should be performed in a secure directory. In most cases, a secure directory is a directory in which no one other than the user, or possibly the administrator, has the ability to create, rename, delete, or otherwise manipulate files. (Other users may read or search the directory but generally may not modify the directory's contents in any way.) Also, other users must not be able to delete or rename files in the parent of the secure directory and all higher directories, although creating new files or deleting or renaming files they own is permissible.\nPerforming file operations in a secure directory eliminates the possibility that an attacker might tamper with the files or file system to exploit a file system vulnerability in a program. These vulnerabilities often exist because there is a loose binding between the file name and the actual file. (See FIO01-C. Be careful using functions that use file names for identification.) In some cases, file operations can be performed securely anywhere. In other cases, the only way to ensure secure file operations is to perform the operation within a secure directory.\nEnsuring that file systems are configured in a safe manner is typically a system administration function. However, programs can often check that a file system is securely configured before performing file operations that may lead to security vulnerabilities if the system is misconfigured. There is a slight possibility that file systems will be reconfigured in an insecure manner while a process is running and after the check has been made. As a result, it is always advisable to implement your code in a secure manner (that is, consistent with the other rules and recommendations in this section) even when running in a secure directory.\nNoncompliant Code Example\nIn this noncompliant code example, the file identified by file_name is opened, processed, closed, and removed:\nchar *file_name;\nFILE *fp;\n /* Initialize file_name */\n fp = fopen(file_name, \"w\");\nif (fp == NULL) {\n  /* Handle error */\n}\n /* ... Process file ... */\n if (fclose(fp) != 0) {\n  /* Handle error */\n}\n if (remove(file_name) != 0) {\n  /* Handle error */\n}\nAn attacker can replace the file object identified by file_name with a link to an arbitrary file before the call to fopen(). It is also possible that the file object identified by file_name in the call to remove() is not the same file object identified by file_name in the call to fopen(). If the file is not in a secure directory, for example, /tmp/app/tmpdir/passwd, then an attacker can manipulate the location of the file as follows:\n% cd /tmp/app/\n% rm -rf tmpdir\n% ln -s /etc tmpdir\nNot much can be done programmatically to ensure the file removed is the same file that was opened, processed, and closed, except to make sure that the file is opened in a secure directory with privileges that would prevent the file from being manipulated by an untrusted user.\nCompliant Solution (POSIX)\nThis sample implementation of the function secure_dir() ensures that the directory fullpath and all directories above it are owned by either the user or the superuser and that other users do not have write access to the directories. When checking directories, it is important to traverse from the root to the leaf to avoid a dangerous race condition in which an attacker who has privileges to at least one of the directories can rename and re-create a directory after the privilege verification.\nfullpath need not be canonicalized (see FIO02-C. Canonicalize path names originating from tainted sources). If the path contains a symbolic link, this routine recursively invokes itself on the linked-to directory and ensures it is also secure. A symbolically linked directory may be secure if both its source and linked-to directory are secure.\nNote that this function is effective only on file systems that are fully compatible with UNIX permissions, and it may not behave normally for file systems with other permission mechanisms, such as AFS (Andrew File System).\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <libgen.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n enum { MAX_SYMLINKS = 5 };\n /* Returns nonzero if directory is secure, zero otherwise */\nint secure_dir(const char *fullpath) {\n  static unsigned int num_symlinks = 0;\n  char *path_copy = NULL;\n  char **dirs = NULL;\n  int num_of_dirs = 1;\n  int secure = 1;\n  int i, r;\n  struct stat buf;\n  uid_t my_uid = geteuid();\n  size_t linksize;\n  char* link;\n      if (!fullpath || fullpath[0] != '/') {\n    /* Handle error */\n  }\n      if (num_symlinks > MAX_SYMLINKS) {  /* Could be a symlink loop */\n    /* Handle error */\n  }\n     if (!(path_copy = strdup(fullpath))) {\n    /* Handle error */\n  }\n     /* Figure out how far it is to the root */\n  char* path_parent = path_copy;\n  for (; ((strcmp(path_parent, \"/\") != 0) &&\n          (strcmp(path_parent, \"//\") != 0) &&\n          (strcmp(path_parent, \".\") != 0));\n       path_parent = dirname(path_parent)) {\n    num_of_dirs++;\n  } /* Now num_of_dirs indicates # of dirs we must check */\n  free(path_copy);\n  path_copy = NULL;\n     if (!(dirs = (char **)malloc(num_of_dirs * sizeof(char *)))) {\n    /* Handle error */\n  }\n      if (!(dirs[num_of_dirs - 1] = strdup(fullpath))) {\n    /* Handle error */\n  }\n     if (!(path_copy = strdup(fullpath))) {\n    /* Handle error */\n  }\n     /* Now fill the dirs array */\n  path_parent = path_copy;\n  for (i = num_of_dirs - 2; i >= 0; i--) {\n    path_parent = dirname(path_parent);\n    if (!(dirs[i] = strdup(path_parent))) {\n      /* Handle error */\n    }\n  }\n  free(path_copy);\n  path_copy = NULL;\n     /*\n   * Traverse from the root to the fullpath,\n   * checking permissions along the way.\n   */\n for (i = 0; i < num_of_dirs; i++) {\n    if (lstat(dirs[i], &buf) != 0) {\n      /* Handle error */\n    }\n          if (S_ISLNK(buf.st_mode)) { /* Symlink, test linked-to file */\n      linksize = buf.st_size + 1;\n      if (!(link = (char *)malloc(linksize))) {\n        /* Handle error */\n      }\n              r = readlink(dirs[i], link, linksize);\n      if (r == -1) {\n        /* Handle error */\n      } else if (r >= linksize) {\n        /* Handle truncation error */\n      }\n      link[r] = '\\0';\n        num_symlinks++;\n      r = secure_dir(link);\n      num_symlinks--;\n              if (!r) {\n        secure = 0;\n          free(link);\n        link = NULL;\n        break;\n      }\n              free(link);\n      link = NULL;\n              continue;\n    }\n          if (!S_ISDIR(buf.st_mode)) { /* Not a directory */\n      secure = 0;\n      break;\n    }\n          if ((buf.st_uid != my_uid) && (buf.st_uid != 0)) {\n      /* Directory is owned by someone besides user or root */\n      secure = 0;\n      break;\n    }\n          if (buf.st_mode & (S_IWGRP | S_IWOTH)) { /* dir is writable by others */\n      secure = 0;\n      break;\n    }\n  }\n      for (i = 0; i < num_of_dirs; i++) {\n    free(dirs[i]);\n    dirs[i] = NULL;\n  }\n     free(dirs);\n  dirs = NULL;\n     return secure;\n}\nThis compliant solution uses the secure_dir() function to ensure that an attacker may not tamper with the file to be opened and subsequently removed. Note that once the path name of a directory has been checked using secure_dir(), all further file operations on that directory must be performed using the same path.\nchar *dir_name;\nconst char *file_name = \"passwd\"; /* File name within the secure directory */\nFILE *fp;\n /* Initialize dir_name */\n if (!secure_dir(dir_name)) {\n  /* Handle error */\n}\n if (chdir(dir_name) == -1) {\n  /* Handle error */\n}\n fp = fopen(file_name, \"w\");\nif (fp == NULL) {\n  /* Handle error */\n}\n /* ... Process file ... */\n if (fclose(fp) != 0) {\n  /* Handle error */\n}\n if (remove(file_name) != 0) {\n  /* Handle error */\n}\nRisk Assessment\nFailing to perform file I/O operations in a secure directory that cannot otherwise be securely performed can result in a broad range of file system vulnerabilities.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO15-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO15-CPP. Ensure that file operations are performed in a secure directory\nMITRE CWE CWE-379, Creation of temporary file in directory with insecure permissions\nCWE-552, Files or directories accessible to external parties\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, dirname\nXSH, System Interfaces, realpath\n[Viega 2003] Section 2.4, \"Determining Whether a Directory Is Secure\"",
        "language": "C"
    },
    {
        "rule_id": "FIO18-C",
        "rule_title": "Never expect fwrite() to terminate the writing process at a null character",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO18-C.+Never+expect+fwrite%28%29+to+terminate+the+writing+process+at+a+null+character",
        "content": "The C Standard, subclause 7.21.8.2 [ISO/IEC 9899:2011], defines the fwrite() function as follows:\nSynopsis \nsize_t fwrite(const void *restrict ptr, size_t size, size_t nmemb, FILE *restrict stream);\nDescription\nThe fwrite() function writes, from the array pointed to by ptr, up to nmemb elements whose size is specified by size, to the stream pointed to by stream. For each object, size calls are made to the fputc() function, taking the values (in order) from an array of unsigned char exactly overlaying the object. The file position indicator for the stream (if defined) is advanced by the number of bytes successfully written. If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.\nThe definition does not state that the fwrite() function will stop copying characters into the file if a null character is encountered. Therefore, when writing a null-terminated byte string to a file using the fwrite() function, always use the length of the string plus 1 (to account for the null character) as the nmemb parameter.\nNoncompliant Code Example\nIn this noncompliant code example, the size of the buffer is stored in size1, but size2 number of characters are written to the file. If size2 is greater than size1, write() will not stop copying characters at the null character.\n#include <stdio.h>\n#include <stdlib.h>\nchar *buffer = NULL;\nsize_t size1;\nsize_t size2;\nFILE *filedes;\n /* Assume size1 and size2 are appropriately initialized */\n filedes = fopen(\"out.txt\", \"w+\");\nif (filedes == NULL) {\n  /* Handle error */\n}\n buffer = (char *)calloc( 1, size1);\nif (buffer == NULL) {\n  /* Handle error */\n}\n fwrite(buffer, 1, size2, filedes);\n free(buffer);\nbuffer = NULL;\nfclose(filedes);\nCompliant Solution\nThis compliant solution ensures that the correct number of characters are written to the file:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n  char *buffer = NULL;\nsize_t size1;\nsize_t size2;\nFILE *filedes;\n /* Assume size1 is appropriately initialized */\n filedes = fopen(\"out.txt\", \"w+\");\nif (filedes == NULL){\n  /* Handle error */\n}\n buffer = (char *)calloc( 1, size1);\nif (buffer == NULL) {\n  /* Handle error */\n}\n /*\n * Accept characters in to the buffer.\n * Check for buffer overflow.\n */\n size2 = strlen(buffer) + 1;\n fwrite(buffer, 1, size2, filedes);\n free(buffer);\nbuffer = NULL;\nfclose(filedes);\nRisk Assessment\nFailure to follow the recommendation could result in a non-null-terminated string being written to a file, which will create problems when the program tries to read it back as a null-terminated byte string.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO18-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nLDRA tool suite\n9.7.1\n44 S Enhanced enforcement\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FIO18-CPP. Never expect write() to terminate the writing process at a null character\nBibliography\n[ISO/IEC 9899:2011] Subclause 7.21.8.2, \"The fwrite Function\"\n[IEEE Std 1003.1:2013] XSH, System Interfaces, fwrite",
        "language": "C"
    },
    {
        "rule_id": "FIO19-C",
        "rule_title": "Do not use fseek() and ftell() to compute the size of a regular file",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO19-C.+Do+not+use+fseek%28%29+and+ftell%28%29+to+compute+the+size+of+a+regular+file",
        "content": "Understanding the difference between text mode and binary mode is important when using functions that operate on file streams. (See FIO14-C. Understand the difference between text mode and binary mode with file streams for more information.)\nSubclause 7.21.9.2 of the C Standard [ISO/IEC 9899:2011] specifies the following behavior for fseek() when opening a binary file in binary mode:\nA binary stream need not meaningfully support fseek calls with a whence value of SEEK_END.\nIn addition, footnote 268 of subclause 7.21.3 says:\nSetting the file position indicator to end-of-file, as with fseek(file, 0, SEEK_END), has undefined behavior for a binary stream (because of possible trailing null characters) or for any stream with state-dependent encoding that does not assuredly end in the initial shift state.\nSeeking to the end of a binary stream in binary mode with fseek() is not meaningfully supported and is not a recommended method for computing the size of a file.\nSubclause 7.21.9.4 of the C Standard [ISO/IEC 9899:2011] specifies the following behavior for ftell() when opening a text file in text mode:\nFor a text stream, its file position indicator contains unspecified information, usable by the fseek function for returning the file position indicator for the stream to its position at the time of the ftell call.\nConsequently, the return value of ftell() for streams opened in text mode should never be used for offset calculations other than in calls to fseek().\nPOSIX [IEEE Std 1003.1:2013] provides several guarantees that the problems described in the C Standard do not occur on POSIX systems.\nFirst, the fopen page says:\nThe character 'b' shall have no effect, but is allowed for ISO C standard conformance.\nThis guarantees that binary files are treated the same as text files in POSIX.\nSecond, the fwrite page says:\nFor each object, size calls shall be made to the fputc() function, taking the values (in order) from an array of unsigned char exactly overlaying the object. The file-position indicator for the stream (if defined) shall be advanced by the number of bytes successfully written.\nThis means that the file position indicator, and consequently the file size, is directly based on the number of bytes actually written to a file.\nNoncompliant Code Example (Binary File)\nThis code example attempts to open a binary file in binary mode and use fseek() and ftell() to obtain the file size. This code is noncompliant on systems that do not provide the same guarantees as POSIX. On these systems, setting the file position indicator to the end of the file using fseek() is not guaranteed to work for a binary stream, and consequently, the amount of memory allocated may be incorrect, leading to a potential vulnerability.\nFILE *fp;\nlong file_size;\nchar *buffer;\n\nfp = fopen(\"foo.bin\", \"rb\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\nif (fseek(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n\nfile_size = ftell(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \nCompliant Solution (POSIX ftello())\nIf the code needs to handle large files, it is preferable to use fseeko() and ftello() because, for some implementations, they can handle larger file offsets than fseek() and ftell() can handle. If they are used, the file_size variable should have type off_t to avoid the possibility of overflow when assigning the return value of ftello() to it. This solution works only with regular files.\nFILE* fp;\nint fd;\noff_t file_size;\nchar *buffer;\nstruct stat st;\n  \nfd = open(\"foo.bin\", O_RDONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n\nfp = fdopen(fd, \"r\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\n/* Ensure that the file is a regular file */\nif ((fstat(fd, &st) != 0) || (!S_ISREG(st.st_mode))) {\n  /* Handle error */\n}\n \nif (fseeko(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n  \nfile_size = ftello(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n \nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \nCompliant Solution (POSIX fstat())\nThis compliant solution uses the size provided by the POSIX fstat() function, rather than by fseek() and ftell(), to obtain the size of the binary file. This solution works only with regular files.\noff_t file_size;\nchar *buffer;\nstruct stat stbuf;\nint fd;\n \nfd = open(\"foo.bin\", O_RDONLY);\nif (fd == -1) {\n  /* Handle error */\n}\n \nif ((fstat(fd, &stbuf) != 0) || (!S_ISREG(stbuf.st_mode))) {\n  /* Handle error */\n}\n \nfile_size = stbuf.st_size;\n \nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \nCompliant Solution (Windows)\nThis compliant solution uses the Windows _filelength() function to determine the size of the file on a 32-bit operating system. For a 64-bit operating system, consider using _filelengthi64 instead.\nint fd;\nlong file_size;\nchar *buffer;\n\n_sopen_s(&fd, \"foo.bin\", _O_RDONLY, _SH_DENYRW, _S_IREAD);\nif (fd == -1) {\n  /* Handle error */\n}\n\nfile_size = _filelength(fd);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \nCompliant Solution (Windows)\nThis compliant solution uses the Windows GetFileSizeEx() function to determine the size of the file on a 32- or 64-bit operating system:\nHANDLE file;\nLARGE_INTEGER file_size;\nchar *buffer;\n\n \nfile = CreateFile(TEXT(\"foo.bin\"), GENERIC_READ, 0, NULL, \n                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\nif (INVALID_FILE_HANDLE == file) {\n  /* Handle error */\n}\n \nif (!GetFileSizeEx(file, &file_size)) {\n  /* Handle error */\n}\n \n/* \n * Note: 32-bit portability issue with LARGE_INTEGER\n * truncating to a size_t.\n */\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \nNoncompliant Code Example (Text File)\nThis noncompliant code example attempts to open a text file in text mode and use fseek() and ftell() to obtain the file size:\nFILE *fp;\nlong file_size;\nchar *buffer;\n\nfp = fopen(\"foo.txt\", \"r\");\nif (fp == NULL) {\n  /* Handle error */\n}\n\nif (fseek(fp, 0 , SEEK_END) != 0) {\n  /* Handle error */\n}\n\nfile_size = ftell(fp);\nif (file_size == -1) {\n  /* Handle error */\n}\n\nbuffer = (char*)malloc(file_size);\nif (buffer == NULL) {\n  /* Handle error */\n}\n\n/* ... */ \nHowever, the file position indicator returned by ftell() with a file opened in text mode is useful only in calls to fseek(). As such, the value of file_size may not necessarily be a meaningful measure of the number of characters in the file, and consequently, the amount of memory allocated may be incorrect, leading to a potential vulnerability.\nThe Visual Studio documentation for ftell() [MSDN] states:\nThe value returned by ftell may not reflect the physical byte offset for streams opened in text mode, because text mode causes carriage return-linefeed translation. Use ftell with fseek to return to file locations correctly.\nAgain, this indicates that the return value of ftell() for streams opened in text mode is useful only in calls to fseek() and should not be used for any other purpose.\nCompliant Solution (Windows)\nThe compliant solution used for binary files on Windows can also be used for text files.\nCompliant Solution (POSIX)\nBecause binary files are treated the same as text files in POSIX, either compliant solution can be used for determining the size of a binary file under POSIX to determine the size of a text file as well.\nRisk Assessment\nUnderstanding the difference between text mode and binary mode with file streams is critical when working with functions that operate on them. Setting the file position indicator to end-of-file with fseek() has undefined behavior for a binary stream. In addition, the return value of ftell() for streams opened in text mode is useful only in calls to fseek(), not for determining file sizes or for any other use. As such, fstat() or other platform-equivalent functions should be used to determine the size of a file.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO19-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nLDRA tool suite\n9.7.1\n44 S Enhanced Enforcement\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, fopen\nXSH, System Interfaces, fwrite\n[ISO/IEC 9899:2011] Section 7.21.3, \"Files\"\nSection 7.21.9.2, \"The fseek Function\"\nSection 7.21.9.4, \"The ftell Function\"\n[MSDN] \"ftell\"",
        "language": "C"
    },
    {
        "rule_id": "FIO21-C",
        "rule_title": "Do not create temporary files in shared directories",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO21-C.+Do+not+create+temporary+files+in+shared+directories",
        "content": "Programmers frequently create temporary files in directories that are writable by everyone (examples are /tmp and /var/tmp on UNIX and %TEMP% on Windows) and may be purged regularly (for example, every night or during reboot).\nTemporary files are commonly used for auxiliary storage for data that does not need to, or otherwise cannot, reside in memory and also as a means of communicating with other processes by transferring data through the file system. For example, one process will create a temporary file in a shared directory with a well-known name or a temporary name that is communicated to collaborating processes. The file then can be used to share information among these collaborating processes.\nThis practice is dangerous because a well-known file in a shared directory can be easily hijacked or manipulated by an attacker. Mitigation strategies include the following:\nUse other low-level IPC (interprocess communication) mechanisms such as sockets or shared memory.\nUse higher-level IPC mechanisms such as remote procedure calls.\nUse a secure directory or a jail that can be accessed only by application instances (ensuring that multiple instances of the application running on the same platform do not compete).\nThere are many different IPC mechanisms; some require the use of temporary files, and others do not. An example of an IPC mechanism that uses temporary files is the POSIX mmap() function. Berkeley Sockets, POSIX Local IPC Sockets, and System V Shared Memory do not require temporary files. Because the multiuser nature of shared directories poses an inherent security risk, the use of shared temporary files for IPC is discouraged.\nWhen two or more users or a group of users have write permission to a directory, the potential for deception is far greater than it is for shared access to a few files. Consequently, temporary files in shared directories must be\nCreated unpredictable file names\nCreated with unique names\nOpened only if the file doesn't already exist (atomic open)\nOpened with exclusive access\nOpened with appropriate permissions\nRemoved before the program exits\nThe following table lists common temporary file functions and their respective conformance to these criteria:\nConformance of File Functions to Criteria for Temporary Files\n\ntmpnam\n(C)\ntmpfile\n(C/POSIX)\nmktemp\n(POSIX)\nmkstemp\n(POSIX)\n\n\n\n\n\nUnpredictable Name\nNot portably\nNot portably\nNot portably\nNot portably\nUnique Name\nYes\nYes\nYes\nYes\nAtomic open\nNo\nYes\nNo\nYes\nExclusive Access\nPossible\nNo\nPossible\nIf supported by OS\nAppropriate Permissions\nPossible\nIf supported by OS*\nPossible\nNot portably\nFile Removed\nNo\nYes*\nNo\nNo\n* If the program terminates abnormally, this behavior is implementation-defined.\nSecurely creating temporary files is error prone and dependent on the version of the C runtime library used, the operating system, and the file system. Code that works for a locally mounted file system, for example, may be vulnerable when used with a remotely mounted file system. Moreover, none of these functions are without problems. The only secure solution is to not create temporary files in shared directories.\nUnique and Unpredictable File Names\nPrivileged programs that create temporary files in world-writable directories can be exploited to overwrite protected system files. An attacker who can predict the name of a file created by a privileged program can create a symbolic link (with the same name as the file used by the program) to point to a protected system file. Unless the privileged program is coded securely, the program will follow the symbolic link instead of opening or creating the file that it is supposed to be using. As a result, a protected system file to which the symbolic link points can be overwritten when the program is executed [HP 2003]. Unprivileged programs can be similarly exploited to overwrite protected user files.\nExclusive Access\nExclusive access grants unrestricted file access to the locking process while denying access to all other processes and eliminates the potential for a race condition on the locked region. (See Secure Coding in C and C++, Chapter 8 [Seacord 2013].)\nFiles, or regions of files, can be locked to prevent two processes from concurrent access. Windows supports two types of file locks:\nShared locks, provided by LockFile(), prohibit all write access to the locked file region while allowing concurrent read access to all processes.\nExclusive locks, provided by LockFileEx(), grant unrestricted file access to the locking process while denying access to all other processes.\nIn both cases, the lock is removed by calling UnlockFile().\nBoth shared locks and exclusive locks eliminate the potential for a race condition on the locked region. The exclusive lock is similar to a mutual exclusion solution, and the shared lock eliminates race conditions by removing the potential for altering the state of the locked file region (one of the required properties for a race).\nThese Windows file-locking mechanisms are called mandatory locks because every process attempting to access a locked file region is subject to the restriction. Linux implements mandatory locks and advisory locks. An advisory lock is not enforced by the operating system, which severely diminishes its value from a security perspective. Unfortunately, the mandatory file lock in Linux is also largely impractical for the following reasons:\nMandatory locking works only on local file systems and does not extend to network file systems (such as NFS or AFS).\nFile systems must be mounted with support for mandatory locking, and this is disabled by default.\nLocking relies on the group ID bit that can be turned off by another process (thereby defeating the lock).\nRemoval before Termination\nRemoving temporary files when they are no longer required allows file names and other resources (such as secondary storage) to be recycled. In the case of abnormal termination, there is no sure method that can guarantee the removal of orphaned files. For this reason, temporary file cleaner utilities, which are invoked manually by a system administrator or periodically run by a daemon to sweep temporary directories and remove old files, are widely used. However, these utilities are themselves vulnerable to file-based exploits and often require the use of shared directories. During normal operation, it is the responsibility of the program to ensure that temporary files are removed either explicitly or through the use of library routines, such as tmpfile_s, which guarantee temporary file deletion upon program termination.\nNoncompliant Code Example (fopen()/open() with tmpnam())\nThis noncompliant code example creates a file with a hard-coded file_name (presumably in a shared directory such as /tmp or C:\\Temp):\n#include <stdio.h>\n  void func(const char *file_name) {\n  FILE *fp = fopen(file_name, \"wb+\");\n  if (fp == NULL) {\n    /* Handle error */\n  }\n}\nBecause the name is hard coded and consequently neither unique nor unpredictable, an attacker need only replace a file with a symbolic link, and the target file referenced by the link is opened and truncated.\nThis noncompliant code example attempts to remedy the problem by generating the file name at runtime using tmpnam(). The C tmpnam() function generates a string that is a valid file name and that is not the same as the name of an existing file. Files created using strings generated by the tmpnam() function are temporary in that their names should not collide with those generated by conventional naming rules for the implementation. The function is potentially capable of generating TMP_MAX different strings, but any or all of them may already be in use by existing files.\n#include <stdio.h>\n  void func(void) {\n  char file_name[L_tmpnam];\n  FILE *fp;\n   if (!tmpnam(file_name)) {\n    /* Handle error */\n  }\n   /* A TOCTOU race condition exists here */\n   fp = fopen(file_name, \"wb+\");\n  if (fp == NULL) {\n     /* Handle error */\n  }\n}\nBecause tmpnam() does not guarantee a unique name and fopen() does not provide a facility for an exclusive open, this code is still vulnerable.\nThe next noncompliant code example attempts to remedy the problem by using the POSIX open() function and providing a mechanism to indicate whether an existing file has been opened for writing or a new file has been created [IEEE Std 1003.1:2013]. If the O_CREAT and O_EXCL flags are used together, the open() function fails when the file specified by file_name already exists. To prevent an existing file from being opened and truncated, include the flags O_CREAT and O_EXCL when calling open():\n#include <stdio.h>\n  void func(void) {\n  char file_name[L_tmpnam];\n  int fd;\n   if (!(tmpnam(file_name))) {\n    /* Handle error */\n  }\n   /* A TOCTOU race condition exists here */\n   fd = open(file_name, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,\n            0600);\n  if (fd < 0) {\n     /* Handle error */\n  }\n}\nThis call to open() fails whenever file_name already exists, including when it is a symbolic link, but a temporary file is presumably still required. Additionally, the method used by tmpnam() to generate file names is not guaranteed to be unpredictable, which leaves room for an attacker to guess the file name ahead of time.\nCare should be observed when using O_EXCL with remote file systems because it does not work with NFS version 2. NFS version 3 added support for O_EXCL mode in open(); see IETF RFC 1813 [Callaghan 1995], particularly the EXCLUSIVE value to the mode argument of CREATE.\nMoreover, the open() function, as specified by the Standard for Information Technology\u2014Portable Operating System Interface (POSIX\u00ae), Base Specifications, Issue 7 [IEEE Std 1003.1:2013], does not include support for shared or exclusive locks. However, BSD systems support two additional flags that allow you to obtain these locks:\nO_SHLOCK: Atomically obtain a shared lock.\nO_EXLOCK: Atomically obtain an exclusive lock.\nNoncompliant Code Example (mktemp()/open(), POSIX)\nThe POSIX function mktemp() takes a given file name template and overwrites a portion of it to create a file name. The template may be any file name with exactly six X's appended to it (for example, /tmp/temp.XXXXXX). The six trailing X's are replaced with the current process number and/or a unique letter combination.\n#include <stdio.h>\n#include <stdlib.h>\n  void func(void) {\n  char file_name[] = \"tmp-XXXXXX\";\n  int fd;\n   if (!mktemp(file_name)) {\n    /* Handle error */\n  }\n   /* A TOCTOU race condition exists here */\n   fd = open(file_name, O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,\n            0600);\n  if (fd < 0) {\n    /* Handle error */\n  }\n}\nThe mktemp() function is marked \"LEGACY\" in the Open Group Base Specifications Issue 6 [Open Group 2004]. The manual page for mktemp() gives more detail:\nNever use mktemp(). Some implementations follow BSD 4.3 and replace XXXXXX by the current process id and a single letter, so that at most 26 different names can be returned. Since on the one hand the names are easy to guess, and on the other hand there is a race between testing whether the name exists and opening the file, every use of mktemp() is a security risk. The race is avoided by mkstemp(3).\nNoncompliant Code Example (tmpfile())\nThe tmpfile() function creates a temporary binary file that is different from any other existing file and that is automatically removed when it is closed or at program termination.\nIt should be possible to open at least TMP_MAX temporary files during the lifetime of the program. (This limit may be shared with tmpnam().) Subclause 7.21.4.4, paragraph 6, of the C Standard allows for the value of the macro TMP_MAX to be as small as 25.\nMost historic implementations provide only a limited number of possible temporary file names (usually 26) before file names are recycled.\n#include <stdio.h>\n  void func(void) {\n  FILE *fp = tmpfile();\n  if (fp == NULL) {\n    /* Handle error */\n  }\n}\nCompliant Solution (mkstemp(), POSIX)\nThe mkstemp() algorithm for selecting file names has shown to be immune to attacks. The mkstemp() function is available on systems that support the Open Group Base Specifications Issue 4, version 2 or later.\nA call to mkstemp() replaces the six X's in the template string with six randomly selected characters and returns a file descriptor for the file (opened for reading and writing), as in this compliant solution:\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n  extern int secure_dir(const char *sdn);\n  void func(void) {\n  const char *sdn = \"/home/usr1/\";\n  char sfn[] = \"/home/usr1/temp-XXXXXX\";\n  FILE *sfp;\n   if (!secure_dir(sdn)) {\n    /* Handle error */\n  }\n   int fd = mkstemp(sfn);\n  if (fd == -1) {\n    /* Handle error */\n  }\n   /*\n   * Unlink immediately to hide the file name. The race\n   * condition here is inconsequential if the file is created\n   * with exclusive permissions (glibc >= 2.0.7).\n   */\n  if (unlink(sfn) == -1) {\n    /* Handle error */\n  }\n   sfp = fdopen(fd, \"w+\");\n  if (sfp == NULL) {\n    close(fd);\n    /* Handle error */\n  }\n   /* Use temporary file */\n   fclose(sfp); /* Also closes fd */\n}\nThis solution is not serially reusable, however, because the mkstemp() function replaces the \"XXXXXX\" in template the first time it is invoked. This is not a problem as long as template is reinitialized before calling mkstemp() again. If template is not reinitialized, the mkstemp() function will return -1 and leave template unmodified because template did not contain six X's.\nThe Open Group Base Specification Issue 6 [Open Group 2004] does not specify the permissions the file is created with, so these are implementation-defined. However, IEEE Std 1003.1, 2013 Edition [IEEE Std 1003.1:2013] specifies them as S_IRUSR|S_IWUSR (0600).\nThis compliant solution invokes the user-defined function secure_dir() (such as the one defined in FIO15-C. Ensure that file operations are performed in a secure directory) to ensure the temporary file resides in a secure directory.\nImplementation Details\nFor GLIBC, versions 2.0.6 and earlier, the file is created with permissions 0666; for GLIBC, versions 2.0.7 and later, the file is created with permissions 0600. On NetBSD, the file is created with permissions 0600. This creates a security risk in that an attacker will have write access to the file immediately after creation. Consequently, programs need a private version of the mkstemp() function in which this issue is known to be fixed.\nIn many older implementations, the name is a function of process ID and time, so it is possible for the attacker to predict the name and create a decoy in advance. FreeBSD changed the mk*temp() family to eliminate the process ID component of the file name and replace the entire field with base-62 encoded randomness. This raises the number of possible temporary files for the typical use of six X's significantly, meaning that even mktemp() with six X's is reasonably (probabilistically) secure against guessing except under frequent usage [Kennaway 2000].\nRisk Assessment\nInsecure temporary file creation can lead to a program accessing unintended files and permission escalation on local systems.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO21-C\nMedium\nProbable\nNo\nNo\nP4\nL3\n Automated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADFUNC.TEMP.*\nBADFUNC.TMPFILE_S\nBADFUNC.TMPNAM_S\nA collection of checks that report uses of library functions associated with temporary file vulnerabilities\nUse of tmpfile_s\nUse of tmpnam_s\nCompass/ROSE\n\n\nCan detect violations of this recommendation. Specifically, Rose reports use of tmpnam(), tmpnam_s(), tmpfile(), and mktemp()\nCoverity 6.5 SECURE_TEMP Fully implemented\nHelix QAC\n2025.2\nC5016\nLDRA tool suite\n9.7.1\n44 S\nEnhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-FIO21-b\nUse secure temporary file name functions\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. FIO21-C Checks for non-secure temporary file (rec. partially covered)\n\nSecurity Reviewer - Static Reviewer\n6.02\nC76 Fully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nCERT C Secure Coding Standard FIO15-C. Ensure that file operations are performed in a secure directory\nSEI CERT C++ Coding Standard VOID FIO19-CPP. Do not create temporary files in shared directories\nCERT Oracle Secure Coding Standard for Java FIO03-J. Remove temporary files before termination\nISO/IEC TR 24772:2013 Path Traversal [EWR]\nMITRE CWE CWE-379, Creation of temporary file in directory with insecure permissions\nBibliography\n[HP 2003]\n[IEEE Std 1003.1:2013] XSH, System Interfaces: open\nXSH, System Interfaces: mkdopen, mksopen\n[ISO/IEC 9899:2011] Subclause 7.21.4.4, \"The tmpnam Function\"\n[Kennaway 2000]\n[Open Group 2004] mkstemp()\nmktemp()\nopen()\n[Seacord 2013] Chapter 3, \"Pointer Subterfuge\"\nChapter 8, \"File I/O\"\n[Viega 2003] Section 2.1, \"Creating Files for Temporary Use\"\n[Wheeler 2003] Chapter 7, \"Structure Program Internals and Approach\"",
        "language": "C"
    },
    {
        "rule_id": "FIO22-C",
        "rule_title": "Close files before spawning processes",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO22-C.+Close+files+before+spawning+processes",
        "content": "Standard FILE objects and their underlying representation (file descriptors on POSIX platforms or handles elsewhere) are a finite resource that must be carefully managed. The number of files that an implementation guarantees may be open simultaneously is bounded by the FOPEN_MAX macro defined in <stdio.h>. The value of the macro is guaranteed to be at least 8. Consequently, portable programs must either avoid keeping more than FOPEN_MAX files at the same time or be prepared for functions such as fopen() to fail due to resource exhaustion.\nFailing to close files when they are no longer needed may allow attackers to exhaust, and possibly manipulate, system resources. This phenomenon is sometimes called file descriptor leakage, although file pointers may also be used as an attack vector. In addition, keeping files open longer than necessary increases the risk that data written into in-memory file buffers will not be flushed in the event of abnormal program termination. To prevent file descriptor leaks and to guarantee that any buffered data will be flushed into permanent storage, files must be closed when they are no longer needed.\nThe behavior of a program is undefined when it uses the value of a pointer to a FILE object after the associated file is closed (see undefined behavior 153.) Programs that close the standard streams (especially stdout but also stderr and stdin) must be careful not to use the stream objects in subsequent function calls, particularly those that implicitly operate on such objects (such as printf(), perror(), and getc()).\nNoncompliant Code Example\nIn this noncompliant code example, derived from a vulnerability in OpenBSD's chpass program [NAI 1998], a file containing sensitive data is opened for reading. The get_validated_editor() function retrieves the registered editor from the EDITOR environment variable and sanitizes it to be a valid editor in accordance with FIO02-C. Canonicalize path names originating from tainted sources. The function returns a command for invoking the editor  which is subsequently passed as a command system() function. If the system() function is implemented in a way that spawns a child process, then the child process could inherit the file descriptors opened by its parent. If this happens, as it does in POSIX systems, the child process will be able to access the contents of the potentially sensitive file called file_name.\n#include <stdio.h>\n#include <stdlib.h>\n  extern const char *get_validated_editor(void);\n  void func(const char *file_name) {\n  FILE *f;\n  const char *editor;\n   f = fopen(file_name, \"r\");\n  if (f == NULL) {\n    /* Handle error */\n  }\n    editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle error */\n  }\n    if (system(editor) == -1) {\n    /* Handle error */\n  }\n}\nIf the command returned by get_validated_editor() will always be a simple path (such as /usr/bin/vim), and runs on a POSIX system, this program could be strengthened by using a call to execve() rather than system(), in accordance with ENV33-C. Do not call system().\nOn UNIX-based systems, child processes are typically spawned using a form of fork() and exec(), and the child process always inherits from its parent any file descriptors that do not have the close-on-exec flag set. Under Microsoft Windows, file-handle inheritance is determined on a per-file and per-spawned process basis. See WIN03-C. Understand HANDLE inheritance for more information.\nCompliant Solution\nIn this compliant solution, file_name is closed before launching the editor:\n#include <stdio.h>\n#include <stdlib.h>\n  extern const char *get_validated_editor(void);\n  void func(const char *file_name) {\n  FILE *f;\n  const char *editor;\n   f = fopen(file_name, \"r\");\n  if (f == NULL) {\n    /* Handle error */\n  }\n     fclose(f);\n  f = NULL;\n     editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle error */\n  }\n    /* Sanitize environment before calling system() */\n  if (system(editor) == -1) {\n    /* Handle error */\n  }\n}\nCompliant Solution (POSIX)\nSometimes it is not practical for a program to close all active file descriptors before issuing a system call such as system() or exec(). An alternative on POSIX systems is to use the FD_CLOEXEC flag, or O_CLOEXEC when available, to set the close-on-exec flag for the file descriptor:\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n  extern const char *get_validated_editor(void);\n  void func(const char *file_name) {\n  int flags;\n  char *editor;\n   int fd = open(file_name, O_RDONLY);\n  if (fd == -1) {\n    /* Handle error */\n  }\n   flags = fcntl(fd, F_GETFD);\n  if (flags == -1) {\n    /* Handle error */\n  }\n   if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) == -1) {\n    /* Handle error */\n  }\n   editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle getenv() error */\n  }\n    if (system(editor) == -1) {\n    /* Handle error */\n  }\n}\nCompliant Solution (Linux)\nSome systems (such as those with Linux kernel versions 2.6.23 and later) have an O_CLOEXEC flag that provides the close-on-exec function directly in open(). This flag is required by IEEE Std 1003.1 [IEEE Std 1003.1:2013]. In multithreaded programs, this flag should be used, if possible, because it prevents a timing hole between open() and fcntl() when using FD_CLOEXEC, during which another thread can create a child process while the file descriptor does not have close-on-exec set.\n#include <stdio.h>\n#include <stdlib.h>\n  extern const char *get_validated_editor(void);\n  void func(const char *file_name) {\n  char *editor;\n  int fd = open(file_name, O_RDONLY | O_CLOEXEC);\n  if (fd == -1) {\n    /* Handle error */\n  }\n    editor = get_validated_editor();\n  if (editor == NULL) {\n    /* Handle error */\n  }\n    if (system(editor) == -1) {\n    /* Handle error */\n  }\n}\nRisk Assessment\nFailing to properly close files may allow unintended access to, or exhaustion of, system resources.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO22-C\nMedium\nUnlikely\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCompass/ROSE\n\n\nKlocwork\n2025.2\nRH.LEAK\n\nLDRA tool suite\n9.7.1\n49 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO22-a\nEnsure resources are freed\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nCERT C Secure Coding Standard WIN03-C. Understand HANDLE inheritance \nSEI CERT C++ Coding Standard FIO51-CPP. Close files when they are no longer needed\nCERT Oracle Secure Coding Standard for Java FIO04-J. Release resources when they are no longer needed\nMITRE CWE CWE-403, UNIX file descriptor leak\nCWE-404, Improper resource shutdown or release\nCWE-770, Allocation of resources without limits or throttling\nBibliography\n[Dowd 2006] Chapter 10, \"UNIX Processes\" (\"File Descriptor Leaks,\" pp. 582\u2013587)\n[IEEE Std 1003.1:2013] XSH, System Interfaces, open\n[MSDN] Inheritance (Windows)\n[NAI 1998]",
        "language": "C"
    },
    {
        "rule_id": "FIO23-C",
        "rule_title": "Do not exit with unflushed data in stdout or stderr",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO23-C.+Do+not+exit+with+unflushed+data+in+stdout+or+stderr",
        "content": "Deprecated\nThis guideline does not apply to code that need conform only to C23. Code that must conform to older versions of the C standard should still comply with this guideline.\nThe C standard makes no guarantees as to when output to stdout (standard output) or stderr (standard error) is actually flushed. On many platforms, output to stdout is buffered unless stdout outputs to a terminal, and stderr output is typically not buffered. However, programs are free to modify the buffering rules for either stdout or stderr. Programs are also free to explicitly close stdout or stderr; if they do not do so, these streams will be closed upon program termination.\nClosing any output stream requires flushing any data that has not yet been written to the stream. The flushing operation (manually handled by the fflush() function) can fail for several reasons. The output stream may be directed to a file in a filesystem with no remaining free space, or to a network socket that fails. Checking for the success of a fflush() operation is mandatory for a secure program, and hence checking the result of a fclose() operation is also required.\nConsequently, any program that sends data to stdout or stderr must take care to flush the data before it terminates. Failing to flush the data (with a call to fflush() or fclose()), may cause the data to fail to be written and become lost.\nNoncompliant Code Example\nThis noncompliant code example sends some data to standard output. If standard output is directed to a file and an error occurs while flushing the data (after program termination), then the output may be lost.\n#include <stdio.h>\n  int main(void) {\n  printf(\"Hello, world!\\n\");\n  return 0;\n}\nCompliant Solution\nThis compliant solution explicitly closes stdout, and handles any errors that arise.\n#include <stdio.h>\n  int main(void) {\n  printf(\"Hello, world!\\n\");\n  if (fclose(stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\nNoncompliant Code Example (atexit())\nThis noncompliant code example closes standard output before exiting main(), but then tries to print to standard output in an exit handler.\n#include <stdio.h>\n  void cleanup(void) {\n  /* Do cleanup */\n   printf(\"All cleaned up!\\n\");\n}\n int main(void) {\n  atexit(cleanup);\n  printf(\"Doing important stuff\\n\");\n   /* Do important stuff */\n   if (fclose(stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\nCompliant Solution (atexit())\nThis compliant solution uses fflush() instead of fclose(), and the exit handler also uses fflush() to flush its output:\n#include <stdio.h>\n  void cleanup(void) {\n  /* Do cleanup */\n   printf(\"All cleaned up!\\n\");\n  if (fflush(stdout) == EOF) {\n    /* Handle error */\n  }\n}\n int main(void) {\n  atexit(cleanup);\n  printf(\"Doing important stuff\\n\");\n   /* Do important stuff */\n    if (fflush(stdout) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\nExceptions\nFIO23-C-EX1: Programs that do not send data to either output stream need not close them.\nFIO23-C-EX2: Programs that never run with buffered output streams need not close them.\nRisk Assessment\nFailing to flush data buffered for standard output or standard error may result in lost data.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO23-C\nMedium\nUnlikely\nNo\nYes\nP4\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.",
        "language": "C"
    },
    {
        "rule_id": "FIO24-C",
        "rule_title": "Do not open a file that is already open",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FIO24-C.+Do+not+open+a+file+that+is+already+open",
        "content": "Opening a file that is already open has implementation-defined behavior, according to the C Standard, 7.21.3, paragraph 8 [ISO/IEC 9899:2011]:\nFunctions that open additional (nontemporary) \ufb01les require a file name, which is a string. The rules for composing valid \ufb01le names are implementation-de\ufb01ned. Whether the same file can be simultaneously open multiple times is also implementation-de\ufb01ned.\nSome implementations do not allow multiple copies of the same file to be open at the same time. Consequently, portable code cannot depend on what will happen if this rule is violated. Even on implementations that do not outright fail to open an already-opened file, a TOCTOU (time-of-check, time-of-use) race condition exists in which the second open could operate on a different file from the first due to the file being moved or deleted (see FIO45-C. Avoid TOCTOU race conditions while accessing files for more details on TOCTOU race conditions).\nNoncompliant Code Example\nThis noncompliant code example logs the program's state at runtime:\n#include <stdio.h>\n \nvoid do_stuff(void) {\n  FILE *logfile = fopen(\"log\", \"a\");\n  if (logfile == NULL) {\n    /* Handle error */\n  }\n\n  /* Write logs pertaining to do_stuff() */\n  fprintf(logfile, \"do_stuff\\n\");\n}\n\nint main(void) {\n  FILE *logfile = fopen(\"log\", \"a\");\n  if (logfile == NULL) {\n    /* Handle error */\n  }\n\n  /* Write logs pertaining to main() */\n  fprintf(logfile, \"main\\n\");\n\n  do_stuff();\n \n  if (fclose(logfile) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\nBecause the file log is opened twice (once in main() and again in do_stuff()), this program has implementation-defined behavior.\nCompliant Solution\nIn this compliant solution, a reference to the file pointer is passed as an argument to functions that need to perform operations on that file. This reference eliminates the need to open the same file multiple times.\n#include <stdio.h>\n \nvoid do_stuff(FILE *logfile) {\n  /* Write logs pertaining to do_stuff() */\n  fprintf(logfile, \"do_stuff\\n\");\n}\n\nint main(void) {\n  FILE *logfile = fopen(\"log\", \"a\");\n  if (logfile == NULL) {\n    /* Handle error */\n  }\n\n  /* Write logs pertaining to main() */\n  fprintf(logfile, \"main\\n\");\n\n  do_stuff(logfile);\n \n  if (fclose(logfile) == EOF) {\n    /* Handle error */\n  }\n  return 0;\n}\nRisk Assessment\nSimultaneously opening a file multiple times can result in unexpected errors and nonportable behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFIO24-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nIO.RACE\n(customization)\nIO.BRAW\nFile system race condition\nUsers can implement a custom check that triggers a warning if a file-opening function is called on a file that is already open\nFile Open for Both Read and Write\nLDRA tool suite\n9.7.1\n75 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-FIO24-a Avoid race conditions while accessing files\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. FIO24-C Checks for situations where previously opened resources are reopened (rec. fully covered)\nRelated Guidelines\nCERT C Secure Coding Standard FIO45-C. Avoid TOCTOU race conditions while accessing files\nSEI CERT C++ Coding Standard VOID FIO21-CPP. Do not simultaneously open the same file multiple times\nMITRE CWE CWE-362, Concurrent Execution Using Shared Resource with Improper Synchronization (\"Race Condition\")\nCWE-675, Duplicate Operations on Resource\n Bibliography\n[ISO/IEC 9899:2011]  Subclause 7.21.3, \"Files\"",
        "language": "C"
    },
    {
        "rule_id": "ENV30-C",
        "rule_title": "Do not modify the object referenced by the return value of certain functions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ENV30-C.+Do+not+modify+the+object+referenced+by+the+return+value+of+certain+functions",
        "content": "Some functions return a pointer to an object that cannot be modified without causing undefined behavior. These functions include getenv(), setlocale(), localeconv(), asctime(), and strerror(). In such cases, the function call results must be treated as being const-qualified.\nThe C Standard, 7.24.4.6, paragraph 4 [ISO/IEC 9899:2024], defines getenv() as follows:\nThe getenv function returns a pointer to a string associated with the matched list member. The string pointed to shall not be modified by the program, but may be overwritten by a subsequent call to the getenv function. If the specified name cannot be found, a null pointer is returned.\nIf the string returned by getenv() must be altered, a local copy should be created. Altering the string returned by getenv() is undefined behavior. (See undefined behavior 189.)\nSimilarly, subclause 7.11.1.1, paragraph 8 [ISO/IEC 9899:2024], defines setlocale() as follows:\nThe pointer to string returned by the setlocale function is such that a subsequent call with that string value and its associated category will restore that part of the program'\u0080\u0099s locale. The string pointed to shall not be modified by the program, but may be overwritten by a subsequent call to the setlocale function.\n And subclause 7.11.2.1, paragraph 8 [ISO/IEC 9899:2024], defines localeconv() as follows:\nThe localeconv function returns a pointer to the filled-in object. The structure pointed to by the return value shall not be modified by the program, but may be overwritten by a subsequent call to the localeconv function. In addition, calls to the setlocale function with categories LC_ALL, LC_MONETARY, or LC_NUMERIC may overwrite the contents of the structure.\n\nAltering the string returned by setlocale() or the structure returned by localeconv() are undefined behaviors. (See undefined behaviors 119 and 121.) Furthermore, the C Standard imposes no requirements on the contents of the string by setlocale(). Consequently, no assumptions can be made as to the string's internal contents or structure.\nFinally, subclause 7.26.6.3, paragraph 4 [ISO/IEC 9899:2024], states\nThe strerror function returns a pointer to the string, the contents of which are locale-specific. The array pointed to shall not be modified by the program. The behavior is undefined if the returned value is used after a subsequent call to the strerror function, or after the thread which called the function to obtain the returned value has exited.\nAltering the string returned by strerror() is undefined behavior. (See undefined behavior 189.)\nNoncompliant Code Example (getenv())\nThis noncompliant code example modifies the string returned by getenv() by replacing all double quotation marks (\") with underscores (_):\n#include <stdlib.h>\n  void trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n void func(void) {\n  char *env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n  trstr(env,'\"', '_');\n}\nCompliant Solution (getenv()) (Environment Not Modified)\nIf the programmer does not intend to modify the environment, this compliant solution demonstrates how to modify a copy of the return value:\n#include <stdlib.h>\n#include <string.h>\n  void trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n  void func(void) {\n  const char *env;\n  char *copy_of_env;\n   env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n   copy_of_env = (char *)malloc(strlen(env) + 1);\n  if (copy_of_env == NULL) {\n    /* Handle error */\n  }\n   strcpy(copy_of_env, env);\n  trstr(copy_of_env,'\"', '_');\n  /* ... */\n  free(copy_of_env);\n}\nCompliant Solution (getenv()) (Modifying the Environment in POSIX)\nIf the programmer's intent is to modify the environment, this compliant solution, which saves the altered string back into the environment by using the POSIX setenv() and strdup() functions, can be used:\n#include <stdlib.h>\n#include <string.h>\n  void trstr(char *c_str, char orig, char rep) {\n  while (*c_str != '\\0') {\n    if (*c_str == orig) {\n      *c_str = rep;\n    }\n    ++c_str;\n  }\n}\n  void func(void) {\n  const char *env;\n  char *copy_of_env;\n   env = getenv(\"TEST_ENV\");\n  if (env == NULL) {\n    /* Handle error */\n  }\n   copy_of_env = strdup(env);\n  if (copy_of_env == NULL) {\n    /* Handle error */\n  }\n   trstr(copy_of_env,'\"', '_');\n   if (setenv(\"TEST_ENV\", copy_of_env, 1) != 0) {\n    /* Handle error */\n  }\n  /* ... */\n  free(copy_of_env);\n}\nNoncompliant Code Example (localeconv())\nIn this noncompliant example, the object returned by localeconv() is directly modified:\n#include <locale.h>\n  void f2(void) {\n  struct lconv *conv = localeconv();\n    if ('\\0' == conv->decimal_point[0]) {\n    conv->decimal_point = \".\";\n  }\n}\nCompliant Solution (localeconv()) (Copy)\nThis compliant solution modifies a copy of the object returned by localeconv():\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n  void f2(void) {\n  const struct lconv *conv = localeconv();\n  if (conv == NULL) {\n     /* Handle error */\n  }\n     struct lconv *copy_of_conv = (struct lconv *)malloc(\n    sizeof(struct lconv));\n  if (copy_of_conv == NULL) {\n    /* Handle error */\n  }\n    memcpy(copy_of_conv, conv, sizeof(struct lconv));\n    if ('\\0' == copy_of_conv->decimal_point[0]) {\n    copy_of_conv->decimal_point = \".\"; \n  }\n  /* ... */\n  free(copy_of_conv);\n}\nRisk Assessment\nModifying the object pointed to by the return value of getenv(), setlocale(), localeconv(), asctime(), or strerror() is undefined behavior. Even if the modification succeeds, the modified object can be overwritten by a subsequent call to the same function.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nENV30-C\nLow\nProbable\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nstdlib-const-pointer-assign Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-ENV30\nCodeSonar\n9.1p0\nBADFUNC.GETENV\nLANG.STRUCT.RPNTC\nUse of getenv\nReturned Pointer Not Treated as const\nCompass/ROSE\n\nCan detect violations of this rule. In particular, it ensures that the result of getenv() is stored in a const variable\nCppcheck Premium\n24.11.0\npremium-cert-env30-c\nHelix QAC\n2025.2\nC1492, C1493, C1494\nDF4751, DF4752, DF4753\n\nKlocwork\n2025.2\nMISRA.STDLIB.CTYPE.RANGE.2012_AMD1\nMISRA.STDLIB.ILLEGAL_REUSE.2012_AMD1\nMISRA.STDLIB.ILLEGAL_WRITE.2012_AMD1\n\nLDRA tool suite\n9.7.1\n107 D Partially Implemented\nParasoft C/C++test\n2024.2\nCERT_C-ENV30-a\nThe pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ENV30-C\n\nChecks for modification of internal buffer returned from nonreentrant standard function (rule fully covered)\nPVS-Studio\n7.38\nV675\nRuleChecker\n24.04\nstdlib-const-pointer-assign Partially checked\nSecurity Reviewer - Static Reviewer\n6.02\nC27\nC28\nC29\nFully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TS 17961:2013 Modifying the string returned by getenv, localeconv, setlocale, and strerror [libmod] Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, getenv\nXSH, System Interfaces, setlocale\nXSH, System Interfaces, localeconv\n[ISO/IEC 9899:2024] 7.11.1.1, \"The setlocale Function\"\n7.11.2.1, \"The localeconv Function\"\n7.24.4.6, \"The getenv Function\"\n7.26.6.3, \"The strerror Function\"",
        "language": "C"
    },
    {
        "rule_id": "ENV31-C",
        "rule_title": "Do not rely on an environment pointer following an operation that may invalidate it",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it",
        "content": "Some implementations provide a nonportable environment pointer that is valid when main() is called but may be invalidated by operations that modify the environment.\nThe C Standard, J.5.2 [ISO/IEC 9899:2024], states\nIn a hosted environment, the main function receives a third argument, char *envp[], that points to a null-terminated array of pointers to char, each of which points to a string that provides information about the environment for this execution of the program (5.1.2.3.2).\nConsequently, under a hosted environment supporting this common extension, it is possible to access the environment through a modified form of main():\nmain(int argc, char *argv[], char *envp[]){ /* ... */ }\nHowever, modifying the environment by any means may cause the environment memory to be reallocated, with the result that envp now references an incorrect location. For example, when compiled with GCC 4.8.1 and run on a 32-bit Intel GNU/Linux machine, the following code,\n#include <stdio.h>\n#include <stdlib.h>\n  extern char **environ;\n int main(int argc, const char *argv[], const char *envp[]) {\n  printf(\"environ:  %p\\n\", environ);\n  printf(\"envp:     %p\\n\", envp);\n  setenv(\"MY_NEW_VAR\", \"new_value\", 1);\n  puts(\"--Added MY_NEW_VAR--\");\n  printf(\"environ:  %p\\n\", environ);\n  printf(\"envp:     %p\\n\", envp);\n  return 0;\n}\nyields\n% ./envp-environ\nenviron: 0xbf8656ec\nenvp:    0xbf8656ec\n--Added MY_NEW_VAR--\nenviron: 0x804a008\nenvp:    0xbf8656ec\nIt is evident from these results that the environment has been relocated as a result of the call to setenv(). The external variable environ is updated to refer to the current environment; the envp parameter is not.\nAn environment pointer may also become invalidated by subsequent calls to getenv(). (See ENV34-C. Do not store pointers returned by certain functions for more information.)\nNoncompliant Code Example (POSIX)\nAfter a call to the POSIX setenv() function or to another function that modifies the environment, the envp pointer may no longer reference the current environment. The Portable Operating System Interface (POSIX\u00ae), Base Specifications, Issue 7 [IEEE Std 1003.1:2013], states\nUnanticipated results may occur if setenv() changes the external variable environ. In particular, if the optional envp argument to main() is present, it is not changed, and thus may point to an obsolete copy of the environment (as may any other copy of environ).\nThis noncompliant code example accesses the envp pointer after calling setenv():\n#include <stdio.h>\n#include <stdlib.h>\n  int main(int argc, const char *argv[], const char *envp[]) {\n  if (setenv(\"MY_NEW_VAR\", \"new_value\", 1) != 0) {\n    /* Handle error */\n  }\n  if (envp != NULL) {\n    for (size_t i = 0; envp[i] != NULL; ++i) {\n      puts(envp[i]);\n    }\n  }\n  return 0;\n}\nBecause envp may no longer point to the current environment, this program has unanticipated behavior.\nCompliant Solution (POSIX)\nUse environ in place of envp when defined:\n#include <stdio.h>\n#include <stdlib.h>\n  extern char **environ;\n int main(void) {\n  if (setenv(\"MY_NEW_VAR\", \"new_value\", 1) != 0) {\n    /* Handle error */\n  }\n  if (environ != NULL) {\n    for (size_t i = 0; environ[i] != NULL; ++i) {\n      puts(environ[i]);\n    }\n  }\n  return 0;\n}\nNoncompliant Code Example (Windows)\nAfter a call to the Windows _putenv_s() function or to another function that modifies the environment, the envp pointer may no longer reference the environment.\nAccording to the Visual C++ reference [MSDN]\nThe environment block passed to main and wmain is a \"frozen\" copy of the current environment. If you subsequently change the environment via a call to _putenv or _wputenv, the current environment (as returned by getenv / _wgetenv and the _environ / _wenviron variable) will change, but the block pointed to by envp will not change.\nThis noncompliant code example accesses the envp pointer after calling _putenv_s():\n#include <stdio.h>\n#include <stdlib.h>\n  int main(int argc, const char *argv[], const char *envp[]) {\n  if (_putenv_s(\"MY_NEW_VAR\", \"new_value\") != 0) {\n    /* Handle error */\n  }\n  if (envp != NULL) {\n    for (size_t i = 0; envp[i] != NULL; ++i) {\n      puts(envp[i]);\n    }\n  }\n  return 0;\n}\nBecause envp no longer points to the current environment, this program has unanticipated behavior.\nCompliant Solution (Windows)\nThis compliant solution uses the _environ variable in place of envp:\n#include <stdio.h>\n#include <stdlib.h>\n  _CRTIMP extern char **_environ;\n int main(int argc, const char *argv[]) {\n  if (_putenv_s(\"MY_NEW_VAR\", \"new_value\") != 0) {\n    /* Handle error */\n  }\n  if (_environ != NULL) {\n    for (size_t i = 0; _environ[i] != NULL; ++i) {\n      puts(_environ[i]);\n    }\n  }\nreturn 0;\n}\nCompliant Solution\nThis compliant solution can reduce remediation time when a large amount of noncompliant envp code exists. It replaces\nint main(int argc, char *argv[], char *envp[]) {\n  /* ... */\n}\nwith\n#if defined (_POSIX_) || defined (__USE_POSIX)\n  extern char **environ;\n  #define envp environ\n#elif defined(_WIN32)\n  _CRTIMP extern char **_environ;\n  #define envp _environ\n#endif\n int main(int argc, char *argv[]) {\n  /* ... */\n}\nThis compliant solution may need to be extended to support other implementations that support forms of the external variable environ.\nRisk Assessment\nUsing the envp environment pointer after the environment has been modified can result in undefined behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nENV31-C\nLow\nProbable\nYes\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n  Supported\nCompass/ROSE\n\n\n\nCppcheck Premium\n24.9.0\npremium-cert-env31-c\n\nHelix QAC\n2025.2\nDF4991, DF4992, DF4993\n\nLDRA tool suite\n9.7.1\n118 S Fully Implemented\nParasoft C/C++test\n2024.2\nCERT_C-ENV31-a\nDo not rely on an environment pointer following an operation that may invalidate it\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ENV31-C Checks for environment pointer invalidated by previous operation (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C VOID ENV31-CPP. Do not rely on an environment pointer following an operation that may invalidate it Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, setenv\n[ISO/IEC 9899:2024] J.5.2, \"Environment Arguments\"\n[MSDN] _environ, _wenviron,\ngetenv, _wgetenv,\n_putenv_s, _wputenv_s",
        "language": "C"
    },
    {
        "rule_id": "ENV32-C",
        "rule_title": "All exit handlers must return normally",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ENV32-C.+All+exit+handlers+must+return+normally",
        "content": "The C Standard provides three functions that cause an application to terminate normally: _Exit(), exit(), and quick_exit(). These are collectively called exit functions. When the exit() function is called, or control transfers out of the main() entry point function, functions registered with atexit() are called (but not at_quick_exit()). When the quick_exit() function is called, functions registered with at_quick_exit() (but not atexit()) are called. These functions are collectively called exit handlers.  When the _Exit() function is called, no exit handlers or signal handlers are called.\nExit handlers must terminate by returning. It is important and potentially safety-critical for all exit handlers to be allowed to perform their cleanup actions. This is particularly true because the application programmer does not always know about handlers that may have been installed by support libraries. Two specific issues include nested calls to an exit function and terminating a call to an exit handler by invoking longjmp.\nA nested call to an exit function is undefined behavior. (See undefined behavior 187.) This behavior can occur only when an exit function is invoked from an exit handler or when an exit function is called from within a signal handler. (See SIG30-C. Call only asynchronous-safe functions within signal handlers.)\nIf a call to the longjmp() function is made that would terminate the call to a function registered with atexit(), the behavior is undefined behavior 187. \nNoncompliant Code Example\nIn this noncompliant code example, the exit1() and exit2() functions are registered by atexit() to perform required cleanup upon program termination. However, if some_condition evaluates to true, exit() is called a second time, resulting in undefined behavior 187.\n#include <stdlib.h>\n void exit1(void) {\n  /* ... Cleanup code ... */\n  return;\n}\n  void exit2(void) {\n  extern int some_condition;\n  if (some_condition) {\n    /* ... More cleanup code ... */\n    exit(0);\n  }\n  return;\n}\n int main(void) {\n  if (atexit(exit1) != 0) {\n    /* Handle error */\n  }\n  if (atexit(exit2) != 0) {\n    /* Handle error */\n  }\n  /* ... Program code ... */\n  return 0;\n}\nFunctions registered by the atexit() function are called in the reverse order from which they were registered. Consequently, if exit2() exits in any way other than by returning, exit1() will not be executed. The same may also be true for atexit() handlers installed by support libraries.\nCompliant Solution\nA function that is registered as an exit handler by atexit() must exit by returning, as in this compliant solution:\n#include <stdlib.h>\n void exit1(void) {\n  /* ... Cleanup code ... */\n  return;\n}\n  void exit2(void) {\n  extern int some_condition;\n  if (some_condition) {\n    /* ... More cleanup code ... */\n  }\n  return;\n}\n int main(void) {\n  if (atexit(exit1) != 0) {\n    /* Handle error */\n  }\n  if (atexit(exit2) != 0) {\n    /* Handle error */\n  }\n  /* ... Program code ... */\n  return 0;\n}\nNoncompliant Code Example\nIn this noncompliant code example, exit1() is registered by atexit() so that upon program termination, exit1() is called. The exit1() function jumps back to main() to return, with undefined results.\n#include <stdlib.h>\n#include <setjmp.h>\n jmp_buf env;\nint val;\n void exit1(void) {\n  longjmp(env, 1);\n}\n int main(void) {\n  if (atexit(exit1) != 0) {\n    /* Handle error */\n  }\n  if (setjmp(env) == 0) {\n    exit(0);\n  } else {\n    return 0;\n  }\n}\nCompliant Solution\nThis compliant solution does not call longjmp()but instead returns from the exit handler normally:\n#include <stdlib.h>\n void exit1(void) {\n  return;\n}\n int main(void) {\n  if (atexit(exit1) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\nRisk Assessment\nTerminating a call to an exit handler in any way other than by returning is undefined behavior and may result in abnormal program termination or other unpredictable behavior. It may also prevent other registered handlers from being invoked.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nENV32-C\nMedium\nLikely\nYes\nNo\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nuser_defined\nbad-function\nbad-function-use\nSoundly supported\nAxivion Bauhaus Suite\n7.2.0\nCertC-ENV32\nCodeSonar\n9.1p0\nBADFUNC.ABORT\nBADFUNC.EXIT\nBADFUNC.LONGJMP\nUse of abort\nUse of exit\nUse of longjmp\nCompass/ROSE\n\n\nCan detect violations of this rule. In particular, it ensures that all functions registered with atexit() do not call functions such as exit()\nCppcheck Premium\n24.9.0\npremium-cert-env32-c\n\nHelix QAC\n2025.2\nDF4856, DF4857, DF4858\n\nKlocwork\n2025.2\nCERT.EXIT.HANDLER_TERMINATE\n\nLDRA tool suite\n9.7.1\n122 S\n7 S Enhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-ENV32-a\nProperly define exit handlers\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ENV32-C Checks for abnormal termination of exit handler (rule fully covered)\nRuleChecker\n24.04\nbad-function\nbad-function-use\nSupported\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard SIG30-C. Call only asynchronous-safe functions within signal handlers Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Structured Programming [EWD] Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24772:2013 Termination Strategy [REU] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-705, Incorrect Control Flow Scoping 2017-07-10: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-705 and ENV32-C\nCWE-705 = Union( ENV32-C, list) where list =\n\nImproper control flow besides a non-returning exit handler",
        "language": "C"
    },
    {
        "rule_id": "ENV34-C",
        "rule_title": "Do not store pointers returned by certain functions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions",
        "content": "The C Standard, 7.24.4.6, paragraph 4 [ISO/IEC 9899:2024], states\nThe getenv function returns a pointer to a string associated with the matched list member. The string pointed to shall not be modified by the program but may be overwritten by a subsequent call to the getenv function. If the specified name cannot be found, a null pointer is returned.\nThis paragraph gives an implementation the latitude, for example, to return a pointer to a statically allocated buffer. Consequently, do not store this pointer because the string data it points to may be overwritten by a subsequent call to the getenv() function or invalidated by modifications to the environment. This string should be referenced immediately and discarded. If later use is anticipated, the string should be copied so the copy can be safely referenced as needed.\nThe getenv() function is not thread-safe. Make sure to address any possible race conditions resulting from the use of this function.\nThe asctime(), localeconv(), setlocale(), and strerror() functions have similar restrictions. Do not access the objects returned by any of these functions after a subsequent call.\nNoncompliant Code Example\nThis noncompliant code example attempts to compare the value of the TMP and TEMP environment variables to determine if they are the same:\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n  void func(void) {\n  char *tmpvar;\n  char *tempvar;\n   tmpvar = getenv(\"TMP\");\n  if (!tmpvar) {\n    /* Handle error */\n  }\n  tempvar = getenv(\"TEMP\");\n  if (!tempvar) {\n    /* Handle error */\n  }\n  if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n}\nThis code example is noncompliant because the string referenced by tmpvar may be overwritten as a result of the second call to the getenv() function. As a result, it is possible that both tmpvar and tempvar will compare equal even if the two environment variables have different values.\nCompliant Solution\nThis compliant solution uses the malloc() and strcpy() functions to copy the string returned by getenv() into a dynamically allocated buffer:\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n  void func(void) {\n  char *tmpvar;\n  char *tempvar;\n   const char *temp = getenv(\"TMP\");\n  if (temp != NULL) {\n    tmpvar = (char *)malloc(strlen(temp)+1);\n    if (tmpvar != NULL) {\n      strcpy(tmpvar, temp);\n    } else {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n   temp = getenv(\"TEMP\");\n  if (temp != NULL) {\n    tempvar = (char *)malloc(strlen(temp)+1);\n    if (tempvar != NULL) {\n      strcpy(tempvar, temp);\n    } else {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n   if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n  free(tmpvar);\n  free(tempvar);\n}\nCompliant Solution (Windows)\nMicrosoft Windows provides the _dupenv_s() and wdupenv_s() functions for getting a value from the current environment [MSDN]. The _dupenv_s() function searches the list of environment variables for a specified name. If the name is found, a buffer is allocated; the variable's value is copied into the buffer, and the buffer's address and number of elements are returned. The _dupenv_s() and _wdupenv_s() functions provide more convenient alternatives to getenv_s() and _wgetenv_s() because each function handles buffer allocation directly.\nThe caller is responsible for freeing any allocated buffers returned by these functions by calling free().\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n  void func(void) {\n  char *tmpvar;\n  char *tempvar;\n  size_t len;\n   errno_t err = _dupenv_s(&tmpvar, &len, \"TMP\");\n  if (err) {\n    /* Handle error */\n  }\n  err = _dupenv_s(&tempvar, &len, \"TEMP\");\n  if (err) {\n    /* Handle error */\n  }\n   if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n  free(tmpvar);\n  tmpvar = NULL;\n  free(tempvar);\n  tempvar = NULL;\n}\nCompliant Solution (POSIX or C2x)\nPOSIX provides the strdup() function, which can make a copy of the environment variable string [IEEE Std 1003.1:2013]. The strdup() function is also included in Extensions to the C Library\u2014Part II [ISO/IEC TR 24731-2:2010]. Further, it is expected to be present in the C2x standard.\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n  void func(void) {\n  char *tmpvar;\n  char *tempvar;\n   const char *temp = getenv(\"TMP\");\n  if (temp != NULL) {\n    tmpvar = strdup(temp);\n    if (tmpvar == NULL) {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n   temp = getenv(\"TEMP\");\n  if (temp != NULL) {\n    tempvar = strdup(temp);\n    if (tempvar == NULL) {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n   if (strcmp(tmpvar, tempvar) == 0) {\n    printf(\"TMP and TEMP are the same.\\n\");\n  } else {\n    printf(\"TMP and TEMP are NOT the same.\\n\");\n  }\n  free(tmpvar);\n  tmpvar = NULL;\n  free(tempvar);\n  tempvar = NULL;\n}\nRisk Assessment\nStoring the pointer to the string returned by getenv(), localeconv(), setlocale(), or strerror() can result in overwritten data.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nENV34-C\nLow\nProbable\nYes\nNo\nP4\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCompass/ROSE\n\n\n\nCppcheck Premium\n24.9.0\npremium-cert-env34-c\n\nHelix QAC\n2025.2\nDF2681, DF2682, DF2683\n\nKlocwork\n2025.2\nMISRA.STDLIB.ILLEGAL_REUSE.2012_AMD1\n\n\nLDRA tool suite\n9.7.1\n133 D\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-ENV34-a\nPointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ENV34-C Checks for misuse of return value from nonreentrant standard function (rule fully covered)\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nC Secure Coding Standard ENV00-C. Do not store objects that can be overwritten by multiple calls to getenv() and similar functions Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TR 24731-2 5.3.1.1, \"The strdup Function\" Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Using an object overwritten by getenv, localeconv, setlocale, and strerror [libuse] Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[IEEE Std 1003.1:2013] Chapter 8, \"Environment Variables\"\nXSH, System Interfaces, strdup\n[ISO/IEC 9899:2024] Subclause 7.24.4, \"Communication with the Environment\"\nSubclause 7.24.4.6, \"The getenv Function\"\nSubclause K.3.6.2.1, \"The getenv_s Function\"\n[MSDN] _dupenv_s(), _wdupenv_s()\n[Viega 2003] Section 3.6, \"Using Environment Variables Securely\"",
        "language": "C"
    },
    {
        "rule_id": "ENV01-C",
        "rule_title": "Do not make assumptions about the size of an environment variable",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ENV01-C.+Do+not+make+assumptions+about+the+size+of+an+environment+variable",
        "content": "Do not make any assumptions about the size of environment variables because an adversary might have full control over the environment. If the environment variable needs to be stored, the length of the associated string should be calculated and the storage dynamically allocated (see STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator).\nNoncompliant Code Example\nThis noncompliant code example copies the string returned by getenv() into a fixed-size buffer:\nvoid f() {\n  char path[PATH_MAX]; /* Requires PATH_MAX to be defined */\n  strcpy(path, getenv(\"PATH\"));\n  /* Use path */\n}\nEven if your platform assumes that $PATH is defined, defines PATH_MAX, and enforces that paths not have more than PATH_MAX characters, the $PATH environment variable still is not required to have less than PATH_MAX chars. And if it has more than PATH_MAX chars, a buffer overflow will result. Also, if $PATH is not defined, then strcpy() will attempt to dereference a null pointer.\nCompliant Solution\nIn this compliant solution, the strlen() function is used to calculate the size of the string, and the required space is dynamically allocated:\nvoid f() {\n  char *path = NULL;\n  /* Avoid assuming $PATH is defined or has limited length */\n  const char *temp = getenv(\"PATH\");\n  if (temp != NULL) {\n    path = (char*) malloc(strlen(temp) + 1);\n    if (path == NULL) {\n      /* Handle error condition */\n    } else {\n      strcpy(path, temp);\n    }\n    /* Use path */\n    free(path);\n  }\n}\nCompliant Solution (POSIX or C2x)\nIn this compliant solution, the strdup() function is used to dynamically allocate a duplicate of the string:\nvoid f() {\n  char *path = NULL;\n  /* Avoid assuming $PATH is defined or has limited length */\n  const char *temp = getenv(\"PATH\");\n  if (temp != NULL) {\n    path = strdup(temp);\n    if (path == NULL) {\n      /* Handle error condition */\n    }\n    /* Use path */\n    free(path);\n  }\n}\nRisk Assessment\nMaking assumptions about the size of an environmental variable can result in a buffer overflow.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nENV01-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nLANG.MEM.BO\nLANG.MEM.TO\n(general)\nBuffer overrun\nType overrun\nCodeSonar's taint analysis includes handling for taint introduced through the environment\nCompass/ROSE\n\n\nCan detect violations of the rule by using the same method as STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator\nHelix QAC\n2025.2\nC3586\nC3587\nC3588\n\nKlocwork\n2025.2\nABV.ANY_SIZE_ARRAY\nABV.GENERAL\nABV.GENERAL.MULTIDIMENSION\nABV.ITERATOR\nABV.MEMBER\nABV.STACK\nABV.TAINTED\nABV.UNKNOWN_SIZE\nABV.UNICODE.BOUND_MAP\nABV.UNICODE.FAILED_MAP\nABV.UNICODE.NNTS_MAP\nABV.UNICODE.SELF_MAP\nParasoft C/C++test\n2024.2\nCERT_C-ENV01-a\nCERT_C-ENV01-b\nCERT_C-ENV01-c\nDon't use unsafe C functions that do write to range-unchecked buffers\nAvoid using unsafe string functions which may cause buffer overflows\nAvoid overflow when writing to a buffer\nPC-lint Plus\n1.4\n669\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. ENV01-C\nChecks for tainted NULL or non-null-terminated string (rec. partially covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nMITRE CWE CWE-119, Improper Restriction of Operations within the Bounds of a Memory Buffer\nCWE-123, Write-what-where Condition\nCWE-125, Out-of-bounds Read\nBibliography\n[IEEE Std 1003.1:2013] Chapter 8, \"Environment Variables\"\n[Viega 2003] Section 3.6, \"Using Environment Variables Securely\"",
        "language": "C"
    },
    {
        "rule_id": "ENV02-C",
        "rule_title": "Beware of multiple environment variables with the same effective name",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ENV02-C.+Beware+of+multiple+environment+variables+with+the+same+effective+name",
        "content": "The getenv() function searches an environment list for a string that matches a specified name and returns a pointer to a string associated with the matched list member.\nSubclause 7.22.4.6 of the C Standard [ISO/IEC 9899:2011] states:\nThe set of environment names and the method for altering the environment list are implementation-defined.\nDepending on the implementation, multiple environment variables with the same name may be allowed and can cause unexpected results if a program cannot consistently choose the same value. The GNU glibc library addresses this issue in getenv() and setenv() by always using the first variable it encounters and ignoring the rest. However, it is unwise to rely on this behavior.\nOne common difference between implementations is whether or not environment variables are case sensitive. Although UNIX-like implementations are generally case sensitive, environment variables are \"not case sensitive in Windows 98/Me and Windows NT/2000/XP\" [MSDN].\nDuplicate Environment Variable Detection (POSIX)\nThe following code defines a function that uses the POSIX environ array to manually search for duplicate key entries. Any duplicate environment variables are considered an attack, so the program immediately terminates if a duplicate is detected.\nextern char **environ;\n int main(void) {\n  if (multiple_vars_with_same_name()) {\n    printf(\"Someone may be tampering.\\n\");\n    return 1;\n  }\n   /* ... */\n   return 0;\n}\n int multiple_vars_with_same_name(void) {\n  size_t i;\n  size_t j;\n  size_t k;\n  size_t l;\n  size_t len_i;\n  size_t len_j;\n   for(size_t i = 0; environ[i] != NULL; i++) {\n    for(size_t j = i; environ[j] != NULL; j++) {\n      if (i != j) {\n        k = 0;\n        l = 0;\n         len_i = strlen(environ[i]);\n        len_j = strlen(environ[j]);\n         while (k < len_i && l < len_j) {\n          if (environ[i][k] != environ[j][l])\n            break;\n           if (environ[i][k] == '=')\n            return 1;\n           k++;\n          l++;\n        }\n      }\n    }\n  }\n  return 0;\n}\nNoncompliant Code Example\nThis noncompliant code example behaves differently when compiled and run on Linux and Microsoft Windows platforms:\nif (putenv(\"TEST_ENV=foo\") != 0) {\n  /* Handle error */\n}\nif (putenv(\"Test_ENV=bar\") != 0) {\n  /* Handle error */\n}\n const char *temp = getenv(\"TEST_ENV\");\n if (temp == NULL) {\n  /* Handle error */\n}\n printf(\"%s\\n\", temp);\nOn an IA-32 Linux machine with GCC 3.4.4, this code prints\nfoo\nwhereas, on an IA-32 Windows XP machine with Microsoft Visual C++ 2008 Express, it prints\nbar\nCompliant Solution\nPortable code should use environment variables that differ by more than capitalization:\nif (putenv(\"TEST_ENV=foo\") != 0) {\n  /* Handle error */\n}\nif (putenv(\"OTHER_ENV=bar\") != 0) {\n  /* Handle error */\n}\n const char *temp = getenv(\"TEST_ENV\");\n if (temp == NULL) {\n  /* Handle error */\n}\n printf(\"%s\\n\", temp);\nRisk Assessment\nAn attacker can create multiple environment variables with the same name (for example, by using the POSIX execve() function). If the program checks one copy but uses another, security checks may be circumvented.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nENV02-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCompass/ROSE\n\n\n\nParasoft C/C++test\n2024.2\nCERT_C-ENV02-a\nUsage of system properties (environment variables) should be restricted\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID ENV00-CPP. Beware of multiple environment variables with the same effective name\nISO/IEC TR 24772:2013 Executing or Loading Untrusted Code [XYS]\nMITRE CWE CWE-462, Duplicate key in associative list (Alist)\nCWE-807, Reliance on untrusted inputs in a security decision\nBibliography\n[ISO/IEC 9899:2011] Section 7.22.4, \"Communication with the Environment\"\n[MSDN] getenv()",
        "language": "C"
    },
    {
        "rule_id": "ENV03-C",
        "rule_title": "Sanitize the environment when invoking external programs",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs",
        "content": "Many programs and libraries, including the shared library loader on both UNIX and Windows systems, depend on environment variable settings. Because environment variables are inherited from the parent process when a program is executed, an attacker can easily sabotage variables, causing a program to behave in an unexpected and insecure manner [Viega 2003].\nAll programs, particularly those running with higher privileges than the caller (such as those with setuid/setgid flags), should treat their environment as untrusted user input. Because the environment is inherited by processes spawned by calls to the fork(), system(), or exec() functions, it is important to verify that the environment does not contain any values that can lead to unexpected behavior.\nThe best practice for such programs is to\nDrop privileges once they are no longer necessary. (See POS02-C. Follow the principle of least privilege.)\nAvoid calling system(). (See ENV33-C. Do not call system().)\nClear the environment and fill it with trusted or default values.\nThis recommendation is a more specific instance of STR02-C. Sanitize data passed to complex subsystems.\nSubclause 7.22.4.6 of the C Standard states that \"the set of environment names and the method for altering the environment list are implementation-defined.\" Consequently, it is important to understand which functions are available for clearing, modifying, and looking up default values for environment variables. Because some programs may behave in unexpected ways when certain environment variables are not set, it is important to understand which variables are necessary on your system and what are safe values for them.\nNoncompliant Code Example (POSIX, ls)\nThis noncompliant code example invokes the C system() function to execute the /bin/ls program. The system() function passes a string to the command processor in the host environment to be executed.\nif (system(\"/bin/ls dir.`date +%Y%m%d`\") == -1) {\n  /* Handle error */\n}\nAlthough IFS does not affect the command portion of this string, /bin/ls, it does determine how the argument is built after calling date. If the default shell does not ignore the incoming value of the IFS environment value, and an attacker sets IFS to \".\", the intended directory will not be found.\nCompliant Solution (POSIX, ls)\nThe nonstandard function clearenv() may be used to clear out the environment where available: otherwise, the environment can be cleared by obtaining the environment variable names from environ and removing each one using unsetenv().\nIn this compliant solution, the environment is cleared by clearenv(), and then the PATH and IFS variables are set to safe values before system() is invoked. Sanitizing shell commands can be difficult, and doing so can adversely affect the power and flexibility associated with them.\nchar *pathbuf;\nsize_t n;\n\nif (clearenv() != 0) {\n  /* Handle error */\n}\n\nn = confstr(_CS_PATH, NULL, 0);\nif (n == 0) {\n  /* Handle error */\n}\n\nif ((pathbuf = malloc(n)) == NULL) {\n  /* Handle error */\n}\n\nif (confstr(_CS_PATH, pathbuf, n) == 0) {\n  /* Handle error */\n}\n\nif (setenv(\"PATH\", pathbuf, 1) == -1) {\n  /* Handle error */\n}\n\nif (setenv(\"IFS\", \" \\t\\n\", 1) == -1) {\n  /* Handle error */\n}\n\nif (system(\"ls dir.`date +%Y%m%d`\") == -1) {\n  /* Handle error */\n}\nPOSIX also specifies the confstr() function, which can be used to look up default values for environment variables [IEEE Std 1003.1:2013]. The _CS_V7_ENV argument to confstr() retrieves a list of environment variable settings required for a default conforming environment [IEEE Std 1003.1:2013]. A space-separated list of variable=value pairs is returned, with variable names guaranteed not to contain equal signs (=), and variable=value pairs guaranteed not to contain spaces. Used together with the _CS_PATH request, this completely describes the minimum environment variable settings required to obtain a clean, conforming environment. On systems conforming to the POSIX.1-2008 standard, this should be used to create a sanitized environment.\nOn systems that have no clearenv() function, the following implementation can be used:\nextern char **environ;\n\nint clearenv(void) {\n  static char *namebuf = NULL;\n  static size_t lastlen = 0;\n\n  while (environ != NULL && environ[0] != NULL) {\n    size_t len = strcspn(environ[0], \"=\");\n    if (len == 0) {\n      /* Handle empty variable name (corrupted environ[]) */\n    }\n    if (len > lastlen) {\n      namebuf = realloc(namebuf, len+1);\n      if (namebuf == NULL) {\n        /* Handle error */\n      }\n      lastlen = len;\n    }\n    memcpy(namebuf, environ[0], len);\n    namebuf[len] = '\\0';\n    if (unsetenv(namebuf) == -1) {\n      /* Handle error */\n    }\n  }\n  return 0;\n}\nCompliant Solution (Windows)\nThere is no portable or guaranteed way to clear out the environment under Windows. Following ENV33-C. Do not call system(), care should be taken to use _execle(), _execlpe(), _execve(), or _execvpe() instead of system(), because they allow the environment to be explicitly specified.\nIf it is explicitly known which environment variables need to be kept, Secure Programming Cookbook for C and C++ [Viega 2003] defines a function, spc_sanitize_environment(), that will remove everything else.\nRisk Assessment\nInvoking an external program in an attacker-controlled environment is inherently dangerous.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nENV03-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nHelix QAC\n2025.2\nC5017\nLDRA tool suite\n9.7.1\n588 S Partially implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID ENV01-CPP. Sanitize the environment when invoking external programs\nCERT Oracle Secure Coding Standard for Java IDS07-J. Sanitize untrusted data passed to the Runtime.exec() method\nISO/IEC TR 24772:2013 Executing or Loading Untrusted Code [XYS]\nMITRE CWE CWE-78, Failure to sanitize data into an OS command (aka \"OS command injection\")\nCWE-88, Argument injection or modification\nCWE-426, Untrusted search path\nCWE-471, Modification of Assumed-Immutable Data (MAID)\nCWE-807, Reliance on intrusted inputs in a security decision\nBibliography\n[CA-1995-14] \"Telnetd Environment Vulnerability\"\n[Dowd 2006] Chapter 10, \"UNIX II: Processes\"\n[IEEE Std 1003.1:2013] Chapter 8, \"Environment Variables\"\nXSH, System Interfaces, confstr\n[ISO/IEC 9899:2011] Subclause 7.22.4, \"Communication with the Environment\"\n[Viega 2003] Section 1.1, \"Sanitizing the Environment\"\n[Wheeler 2003] Section 5.2, \"Environment Variables\"",
        "language": "C"
    },
    {
        "rule_id": "SIG30-C",
        "rule_title": "Call only asynchronous-safe functions within signal handlers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/SIG30-C.+Call+only+asynchronous-safe+functions+within+signal+handlers",
        "content": "Call only asynchronous-safe functions within signal handlers. For strictly conforming programs, only the C standard library functions abort(), _Exit(), quick_exit(), and signal() can be safely called from within a signal handler. \nThe C Standard, 7.14.1.1, paragraph 5 [ISO/IEC 9899:2024], states that if the signal occurs other than as the result of calling the abort() or raise() function, the behavior is undefined if\nIf the signal occurs other than as the result of calling the abort or raise function, the behavior is undefined if the signal handler refers to any object with static or thread storage duration that is not a lock-free atomic object and that is not declared with the constexpr storage-class specifier other than by assigning a value to an object declared as volatile sig_atomic_t, or the signal handler calls any function in the standard library other than\n\u2014  the abort function,\n\u2014  the _Exit function,\n\u2014  the quick_exit function,\n\u2014  the functions in <stdatomic.h> (except where explicitly stated otherwise) when the atomic arguments are lock-free,\n\u2014  the atomic_is_lock_free function with any atomic argument, or\n\u2014  the signal function with the first argument equal to the signal number corresponding to the signal that caused the invocation of the handler. Furthermore, if such a call to the signal function results in a SIG_ERR return, the object designated by errno has an indeterminate representation.294)\nImplementations may define a list of additional asynchronous-safe functions. These functions can also be called within a signal handler. This restriction applies to library functions as well as application-defined functions.\nAccording to the C Rationale, 7.14.1.1 [C99 Rationale 2003],\nWhen a signal occurs, the normal flow of control of a program is interrupted. If a signal occurs that is being trapped by a signal handler, that handler is invoked. When it is finished, execution continues at the point at which the signal occurred. This arrangement can cause problems if the signal handler invokes a library function that was being executed at the time of the signal.\nIn general, it is not safe to invoke I/O functions from within signal handlers. Programmers should ensure a function is included in the list of an implementation's asynchronous-safe functions for all implementations the code will run on before using them in signal handlers.\nNoncompliant Code Example\nIn this noncompliant example, the C standard library functions fputs() and free() are called from the signal handler via the function log_message(). Neither function is asynchronous-safe.\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n enum { MAXLINE = 1024 };\nchar *info = NULL;\n void log_message(void) {\n  fputs(info, stderr);\n}\n void handler(int signum) {\n  log_message();\n  free(info);\n  info = NULL;\n}\n int main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  info = (char *)malloc(MAXLINE);\n  if (info == NULL) {\n    /* Handle Error */\n  }\n   while (1) {\n    /* Main loop program code */\n     log_message();\n     /* More program code */\n  }\n  return 0;\n}\nCompliant Solution\nSignal handlers should be as concise as possible\u2014ideally by unconditionally setting a flag and returning. This compliant solution sets a flag of type volatile sig_atomic_t and returns; the log_message() and free() functions are called directly from main():\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n enum { MAXLINE = 1024 };\nvolatile sig_atomic_t eflag = 0;\nchar *info = NULL;\n void log_message(void) {\n  fputs(info, stderr);\n}\n void handler(int signum) {\n  eflag = 1;\n}\n int main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  info = (char *)malloc(MAXLINE);\n  if (info == NULL) {\n    /* Handle error */\n  }\n   while (!eflag) {\n    /* Main loop program code */\n     log_message();\n     /* More program code */\n  }\n   log_message();\n  free(info);\n  info = NULL;\n   return 0;\n}\nNoncompliant Code Example (longjmp())\nInvoking the longjmp() function from within a signal handler can lead to undefined behavior 132 if it results in the invocation of any non-asynchronous-safe functions. Consequently, neither longjmp() nor the POSIX siglongjmp() functions should ever be called from within a signal handler.\nThis noncompliant code example is similar to a vulnerability in an old version of Sendmail [VU #834865]. The intent is to execute code in a main() loop, which also logs some data. Upon receiving a SIGINT, the program transfers out of the loop, logs the error, and terminates.\nHowever, an attacker can exploit this noncompliant code example by generating a SIGINT just before the second if statement in log_message(). The result is that longjmp() transfers control back to main(), where log_message() is called again. However, the first if statement would not be executed this time (because buf is not set to NULL as a result of the interrupt), and the program would write to the invalid memory location referenced by buf0.\n#include <setjmp.h>\n#include <signal.h>\n#include <stdlib.h>\n enum { MAXLINE = 1024 };\nstatic jmp_buf env;\n void handler(int signum) {\n  longjmp(env, 1);\n}\n void log_message(char *info1, char *info2) {\n  static char *buf = NULL;\n  static size_t bufsize;\n  char buf0[MAXLINE];\n   if (buf == NULL) {\n    buf = buf0;\n    bufsize = sizeof(buf0);\n  }\n   /*\n   * Try to fit a message into buf, else reallocate\n   * it on the heap and then log the message.\n   */\n   /* Program is vulnerable if SIGINT is raised here */\n   if (buf == buf0) {\n    buf = NULL;\n  }\n}\n int main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  char *info1;\n  char *info2;\n   /* info1 and info2 are set by user input here */\n   if (setjmp(env) == 0) {\n    while (1) {\n      /* Main loop program code */\n      log_message(info1, info2);\n      /* More program code */\n    }\n  } else {\n    log_message(info1, info2);\n  }\n   return 0;\n}\nCompliant Solution\nIn this compliant solution, the call to longjmp() is removed; the signal handler sets an error flag instead:\n#include <signal.h>\n#include <stdlib.h>\n enum { MAXLINE = 1024 };\nvolatile sig_atomic_t eflag = 0;\n void handler(int signum) {\n  eflag = 1;\n}\n void log_message(char *info1, char *info2) {\n  static char *buf = NULL;\n  static size_t bufsize;\n  char buf0[MAXLINE];\n   if (buf == NULL) {\n    buf = buf0;\n    bufsize = sizeof(buf0);\n  }\n   /*\n   * Try to fit a message into buf, else reallocate\n   * it on the heap and then log the message.\n   */\n  if (buf == buf0) {\n    buf = NULL;\n  }\n}\n int main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  char *info1;\n  char *info2;\n   /* info1 and info2 are set by user input here */\n   while (!eflag) {\n    /* Main loop program code */\n    log_message(info1, info2);\n    /* More program code */\n  }\n   log_message(info1, info2);\n   return 0;\n}\nNoncompliant Code Example (raise())\nIn this noncompliant code example, the int_handler() function is used to carry out tasks specific to SIGINT and then raises SIGTERM. However, there is a nested call to the raise() function, which is undefined behavior 131.\n#include <signal.h>\n#include <stdlib.h>\n  void term_handler(int signum) {\n  /* SIGTERM handler */\n}\n  void int_handler(int signum) {\n  /* SIGINT handler */\n  if (raise(SIGTERM) != 0) {\n    /* Handle error */\n  }\n}\n  int main(void) {\n  if (signal(SIGTERM, term_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGINT, int_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n    /* Program code */\n  if (raise(SIGINT) != 0) {\n    /* Handle error */\n  }\n  /* More code */\n    return EXIT_SUCCESS;\n}\nCompliant Solution\nIn this compliant solution, int_handler() invokes term_handler() instead of raising SIGTERM: \n#include <signal.h>\n#include <stdlib.h>\n  void term_handler(int signum) {\n  /* SIGTERM handler */\n}\n  void int_handler(int signum) {\n  /* SIGINT handler */\n  /* Pass control to the SIGTERM handler */\n  term_handler(SIGTERM);\n}\n  int main(void) {\n  if (signal(SIGTERM, term_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGINT, int_handler) == SIG_ERR) {\n    /* Handle error */\n  }\n    /* Program code */\n  if (raise(SIGINT) != 0) {\n    /* Handle error */\n  }\n  /* More code */\n    return EXIT_SUCCESS;\n}\nImplementation Details\nPOSIX\nThe following table from the POSIX standard [IEEE Std 1003.1:2013] defines a set of functions that are asynchronous-signal-safe. Applications may invoke these functions, without restriction, from a signal handler.\n_Exit()\nfexecve()\nposix_trace_event()\nsigprocmask()\n_exit()\nfork()\npselect()\nsigqueue()\nabort()\nfstat()\npthread_kill()\nsigset()\naccept()\nfstatat()\npthread_self()\nsigsuspend()\naccess()\nfsync()\npthread_sigmask()\nsleep()\naio_error()\nftruncate()\nraise()\nsockatmark()\naio_return()\nfutimens()\nread()\nsocket()\naio_suspend()\ngetegid()\nreadlink()\nsocketpair()\nalarm()\ngeteuid()\nreadlinkat()\nstat()\nbind()\ngetgid()\nrecv()\nsymlink()\ncfgetispeed()\ngetgroups()\nrecvfrom()\nsymlinkat()\ncfgetospeed()\ngetpeername()\nrecvmsg()\ntcdrain()\ncfsetispeed()\ngetpgrp()\nrename()\ntcflow()\ncfsetospeed()\ngetpid()\nrenameat()\ntcflush()\nchdir()\ngetppid()\nrmdir()\ntcgetattr()\nchmod()\ngetsockname()\nselect()\ntcgetpgrp()\nchown()\ngetsockopt()\nsem_post()\ntcsendbreak()\nclock_gettime()\ngetuid()\nsend()\ntcsetattr()\nclose()\nkill()\nsendmsg()\ntcsetpgrp()\nconnect()\nlink()\nsendto()\ntime()\ncreat()\nlinkat()\nsetgid()\ntimer_getoverrun()\ndup()\nlisten()\nsetpgid()\ntimer_gettime()\ndup2()\nlseek()\nsetsid()\ntimer_settime()\nexecl()\nlstat()\nsetsockopt()\ntimes()\nexecle()\nmkdir()\nsetuid()\numask()\nexecv()\nmkdirat()\nshutdown()\nuname()\nexecve()\nmkfifo()\nsigaction()\nunlink()\nfaccessat()\nmkfifoat()\nsigaddset()\nunlinkat()\nfchdir()\nmknod()\nsigdelset()\nutime()\nfchmod()\nmknodat()\nsigemptyset()\nutimensat()\nfchmodat()\nopen()\nsigfillset()\nutimes()\nfchown()\nopenat()\nsigismember()\nwait()\nfchownat()\npause()\nsignal()\nwaitpid()\nfcntl()\npipe()\nsigpause()\nwrite()\nfdatasync()\npoll()\nsigpending()\n \nAll functions not listed in this table are considered to be unsafe with respect to signals. In the presence of signals, all POSIX functions behave as defined when called from or interrupted by a signal handler, with a single exception: when a signal interrupts an unsafe function and the signal handler calls an unsafe function, the behavior is undefined.\nThe C Standard, 7.14.1.1, paragraph 4 [ISO/IEC 9899:2024], states\nIf the signal occurs as the result of calling the abort or raise function, the signal handler shall not call the raise function.\nHowever, in the description of signal(), POSIX [IEEE Std 1003.1:2013] states\nThis restriction does not apply to POSIX applications, as POSIX.1-2008 requires raise() to be async-signal-safe.\nSee also undefined behavior 131. \nOpenBSD\nThe OpenBSD signal() manual page lists a few additional functions that are asynchronous-safe in OpenBSD but \"probably not on other systems\" [OpenBSD], including snprintf(), vsnprintf(), and syslog_r() but only when the syslog_data struct is initialized as a local variable.\nRisk Assessment\nInvoking functions that are not asynchronous-safe from within a signal handler is undefined behavior 132.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSIG30-C\nHigh\nLikely\nYes\nNo\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nsignal-handler-unsafe-call Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-SIG30\nCodeSonar\n9.1p0\nBADFUNC.SIGNAL\nUse of signal\nCompass/ROSE\n\nCan detect violations of the rule for single-file programs\nCppcheck Premium\n24.11.0\npremium-cert-sig30-c\nHelix QAC\n2025.2\nC2028, C2030\nKlocwork\n2025.2\nCERT.SIG.SIG_HANDLER.ASYNC_SAFE\n\nLDRA tool suite\n9.7.1\n88 D, 89 D \nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-SIG30-a\nProperly define signal handlers\nPC-lint Plus\n1.4\n2670, 2761\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule SIG30-C\n\nChecks for function called from signal handler not asynchronous-safe (rule fully covered)\nRuleChecker\n24.04\nsignal-handler-unsafe-call Partially checked\nSplint\n3.1.1\n\n\nRelated Vulnerabilities\nFor an overview of software vulnerabilities resulting from improper signal handling, see Michal Zalewski's paper \"Delivering Signals for Fun and Profit\" [Zalewski 2001].\nCERT Vulnerability Note VU #834865, \"Sendmail signal I/O race condition,\" describes a vulnerability resulting from a violation of this rule. Another notable case where using the longjmp() function in a signal handler caused a serious vulnerability is wu-ftpd 2.4 [Greenman 1997]. The effective user ID is set to 0 in one signal handler. If a second signal interrupts the first, a call is made to longjmp(), returning the program to the main thread but without lowering the user's privileges. These escalated privileges can be used for further exploitation.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TS 17961:2013 Calling functions in the C Standard Library other than abort, _Exit, and signal from within a signal handler [asyncsig] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-479, Signal Handler Use of a Non-reentrant Function 2017-07-10: CERT: Exact\nBibliography\n[C99 Rationale 2003] Subclause 5.2.3, \"Signals and Interrupts\"\nSubclause 7.14.1.1, \"The signal Function\"\n[Dowd 2006] Chapter 13, \"Synchronization and State\"\n[Greenman 1997]\n[IEEE Std 1003.1:2013] XSH, System Interfaces, longjmp\nXSH, System Interfaces, raise\n[ISO/IEC 9899:2024] 7.14.1.1, \"The signal Function\"\n[OpenBSD] signal() Man Page\n[VU #834865]\n[Zalewski 2001] \"Delivering Signals for Fun and Profit\"\n\n\nadjust column widths",
        "language": "C"
    },
    {
        "rule_id": "SIG31-C",
        "rule_title": "Do not access shared objects in signal handlers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers",
        "content": "Accessing or modifying shared objects in signal handlers can result in race conditions that can leave data in an inconsistent state. The two exceptions (C Standard, 5.1.2.3, paragraph 5) to this rule are the ability to read from and write to lock-free atomic objects and variables of type volatile sig_atomic_t. Accessing any other type of object from a signal handler is undefined behavior. (See undefined behavior 131.)\nThe need for the volatile keyword is described in DCL22-C. Use volatile for data that cannot be cached.\nThe type sig_atomic_t is the integer type of an object that can be accessed as an atomic entity even in the presence of asynchronous interrupts. The type of sig_atomic_t is implementation-defined, though it provides some guarantees. Integer values ranging from SIG_ATOMIC_MIN through SIG_ATOMIC_MAX, inclusive, may be safely stored to a variable of the type. In addition, when sig_atomic_t is a signed integer type, SIG_ATOMIC_MIN must be no greater than \u2212127 and SIG_ATOMIC_MAX no less than 127. Otherwise, SIG_ATOMIC_MIN must be 0 and SIG_ATOMIC_MAX must be no less than 255. The macros SIG_ATOMIC_MIN and SIG_ATOMIC_MAX are defined in the header <stdint.h>.\nAccording to the C99 Rationale [C99 Rationale 2003], other than calling a limited, prescribed set of library functions,\nthe C89 Committee concluded that about the only thing a strictly conforming program can do in a signal handler is to assign a value to a volatile static variable which can be written uninterruptedly and promptly return.\nHowever, this issue was discussed at the April 2008 meeting of ISO/IEC WG14, and it was agreed that there are no known implementations in which it would be an error to read a value from a volatile sig_atomic_t variable, and the original intent of the committee was that both reading and writing variables of volatile sig_atomic_t would be strictly conforming.\nThe signal handler may also call a handful of functions, including abort(). (See SIG30-C. Call only asynchronous-safe functions within signal handlers for more information.)\nNoncompliant Code Example\nIn this noncompliant code example, err_msg is updated to indicate that the SIGINT signal was delivered.  The err_msg variable is a character pointer and not a variable of type volatile sig_atomic_t.\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n enum { MAX_MSG_SIZE = 24 };\nchar *err_msg;\n void handler(int signum) {\n  strcpy(err_msg, \"SIGINT encountered.\");\n}\n int main(void) {\n  signal(SIGINT, handler);\n   err_msg = (char *)malloc(MAX_MSG_SIZE);\n  if (err_msg == NULL) {\n    /* Handle error */\n  }\n  strcpy(err_msg, \"No errors yet.\");\n  /* Main code loop */\n  return 0;\n}\nCompliant Solution (Writing volatile sig_atomic_t)\nFor maximum portability, signal handlers should only unconditionally set a variable of type volatile sig_atomic_t and return, as in this compliant solution:\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n enum { MAX_MSG_SIZE = 24 };\nvolatile sig_atomic_t e_flag = 0;\n void handler(int signum) {\n  e_flag = 1;\n}\n int main(void) {\n  char *err_msg = (char *)malloc(MAX_MSG_SIZE);\n  if (err_msg == NULL) {\n    /* Handle error */\n  }\n   signal(SIGINT, handler);\n  strcpy(err_msg, \"No errors yet.\");\n  /* Main code loop */\n  if (e_flag) {\n    strcpy(err_msg, \"SIGINT received.\");\n  }\n  return 0;\n}\nCompliant Solution (Lock-Free Atomic Access)\nSignal handlers can refer to objects with static or thread storage durations that are lock-free atomic objects, as in this compliant solution:\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdatomic.h>\n  #ifdef __STDC_NO_ATOMICS__\n#error \"Atomics are not supported\"\n#elif ATOMIC_INT_LOCK_FREE == 0\n#error \"int is never lock-free\"\n#endif\n atomic_int e_flag = ATOMIC_VAR_INIT(0);\n  void handler(int signum) {\n  e_flag = 1;\n}\n int main(void) {\n  enum { MAX_MSG_SIZE = 24 };\n  char err_msg[MAX_MSG_SIZE];\n#if ATOMIC_INT_LOCK_FREE == 1\n  if (!atomic_is_lock_free(&e_flag)) {\n    return EXIT_FAILURE;\n  }\n#endif\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    return EXIT_FAILURE;\n  }\n  strcpy(err_msg, \"No errors yet.\");\n  /* Main code loop */\n  if (e_flag) {\n    strcpy(err_msg, \"SIGINT received.\");\n  }\n  return EXIT_SUCCESS;\n}\nExceptions\nSIG31-C-EX1:  The C Standard, 7.14.1.1 paragraph 5 [ISO/IEC 9899:2024], makes a special exception for errno when a valid call to the signal() function results in a SIG_ERR return, allowing errno to take an indeterminate value. (See ERR32-C. Do not rely on indeterminate values of errno.)\nthe signal function with the first argument equal to the signal number corresponding to the signal that caused the invocation of the handler. Furthermore, if such a call to the signal function results in a SIG_ERR return, the object designated by errno has an indeterminate representation.\nRisk Assessment\nAccessing or modifying shared objects in signal handlers can result in accessing data in an inconsistent state. Michal Zalewski's paper \"Delivering Signals for Fun and Profit\" [Zalewski 2001] provides some examples of vulnerabilities that can result from violating this and other signal-handling rules.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSIG31-C\nHigh\nLikely\nYes\nNo\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nsignal-handler-shared-access Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-SIG31\nCodeSonar\n9.1p0\nCONCURRENCY.DATARACE Data race\nCompass/ROSE\n\n\nCan detect violations of this rule for single-file programs\nCppcheck Premium\n24.9.0\npremium-cert-sig31-c\n\nHelix QAC\n2025.2\nC2029, C2030\nC++3854, C++3855\n\nLDRA tool suite\n9.7.1\n87 D\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-SIG31-a Properly define signal handlers\nPC-lint Plus\n1.4\n2765\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule SIG31-C Checks for shared data access within signal handler (rule partially covered)\nRuleChecker\n24.04\nsignal-handler-shared-access Partially checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TS 17961:2013 Accessing shared objects in signal handlers [accsig] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-662, Improper Synchronization 2017-07-10: CERT: Rule subset of CWE\nCWE 2.11 CWE-828, Signal Handler with Functionality that is not Asynchronous-Safe\n2017-10-30:MITRE:Unspecified Relationship\n2018-10-19:CERT:Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-662 and SIG31-C\nCWE-662 = Union( SIG31-C, list) where list =\nImproper synchronization of shared objects between threads\nImproper synchronization of files between programs (enabling TOCTOU race conditions\nCWE-828 and SIG31-C\nCWE-828 = SIG31-C + non-async-safe things besides shared objects.\nBibliography\n[C99 Rationale 2003] 5.2.3, \"Signals and Interrupts\"\n[ISO/IEC 9899:2024] Subclause 7.14.1.1, \"The signal Function\"\n[Zalewski 2001]",
        "language": "C"
    },
    {
        "rule_id": "SIG34-C",
        "rule_title": "Do not call signal() from within interruptible signal handlers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/SIG34-C.+Do+not+call+signal%28%29+from+within+interruptible+signal+handlers",
        "content": "A signal handler should not reassert its desire to handle its own signal. This is often done on nonpersistent platforms\u2014that is, platforms that, upon receiving a signal, reset the handler for the signal to SIG_DFL before calling the bound signal handler. Calling signal() under these conditions presents a race condition. (See SIG01-C. Understand implementation-specific details regarding signal handler persistence.)\nA signal handler may call signal() only if it does not need to be asynchronous-safe (that is, if all relevant signals are masked so that the handler cannot be interrupted).\nNoncompliant Code Example (POSIX)\nOn nonpersistent platforms, this noncompliant code example contains a race window, starting when the host environment resets the signal and ending when the handler calls signal(). During that time, a second signal sent to the program will trigger the default signal behavior, consequently defeating the persistent behavior implied by the call to signal() from within the handler to reassert the binding.\nIf the environment is persistent (that is, it does not reset the handler when the signal is received), the signal() call from within the handler() function is redundant.\n#include <signal.h>\n \nvoid handler(int signum) {\n  if (signal(signum, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  /* Handle signal */\n}\n \nvoid func(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n}\nCompliant Solution (POSIX)\nCalling the signal() function from within the signal handler to reassert the binding is unnecessary for persistent platforms, as in this compliant solution:\n#include <signal.h>\n \nvoid handler(int signum) {\n  /* Handle signal */\n}\n \nvoid func(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n}\nCompliant Solution (POSIX)\nPOSIX defines the sigaction() function, which assigns handlers to signals in a similar manner to signal() but allows the caller to explicitly set persistence. Consequently, the sigaction() function can be used to eliminate the race window on nonpersistent platforms, as in this compliant solution:\n#include <signal.h>\n#include <stddef.h>\n \nvoid handler(int signum) {\n  /* Handle signal */\n}\n\nvoid func(void) {\n  struct sigaction act;\n  act.sa_handler = handler;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGUSR1, &act, NULL) != 0) {\n    /* Handle error */\n  }\n}\nAlthough the handler in this example does not call signal(), it could do so safely because the signal is masked and the handler cannot be interrupted. If the same handler is installed for more than one signal, the signals must be masked explicitly in act.sa_mask to ensure that the handler cannot be interrupted because the system masks only the signal being delivered.\nPOSIX recommends that new applications should use sigaction() rather than signal(). The sigaction() function is not defined by the C Standard and is not supported on some platforms, including Windows.\nCompliant Solution (Windows)\nThere is no safe way to implement persistent signal-handler behavior on Windows platforms, and it should not be attempted. If a design depends on this behavior, and the design cannot be altered, it may be necessary to claim a deviation from this rule after completing an appropriate risk analysis.\nThe reason for this is that Windows is a nonpersistent platform as discussed above.  Just before calling the current handler function, Windows resets the handler for the next occurrence of the same signal to SIG_DFL. If the handler calls signal() to reinstall itself, there is still a race window. A signal might occur between the start of the handler and the call to signal(), which would invoke the default behavior instead of the desired handler.\nExceptions\nSIG34-C-EX1: For implementations with persistent signal handlers, it is safe for a handler to modify the behavior of its own signal. Behavior modifications include ignoring the signal, resetting to the default behavior, and having the signal handled by a different handler. A handler reasserting its binding is also safe but unnecessary.\nThe following code example resets a signal handler to the system's default behavior:\n#include <signal.h>\n \nvoid handler(int signum) {\n#if !defined(_WIN32)\n  if (signal(signum, SIG_DFL) == SIG_ERR) {\n    /* Handle error */\n  }\n#endif\n  /* Handle signal */\n}\n \nvoid func(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n}\nRisk Assessment\nTwo signals in quick succession can trigger a race condition on nonpersistent platforms, causing the signal's default behavior despite a handler's attempt to override it.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSIG34-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nsignal-handler-signal-call Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-SIG34\nCodeSonar\n9.1p0\nBADFUNC.SIGNAL Use of signal\nCompass/ROSE\n\nCan detect violations of this rule. However, false positives may occur on systems with persistent handlers\nCppcheck Premium\n24.11.0\npremium-cert-sig34-c\nHelix QAC\n2025.2\nC5021\nC++5022\n\nKlocwork\n2025.2\nMISRA.STDLIB.SIGNAL\n\n\nLDRA tool suite\n9.7.1\n97 D Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-SIG34-a\nProperly define signal handlers\nPC-lint Plus\n1.4\n2762, 2763\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule SIG34-C Checks for signal call from within signal handler (rule partially covered)\nRuleChecker\n24.04\nsignal-handler-signal-call Partially checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard SIG01-C. Understand implementation-specific details regarding signal handler persistence Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Calling signal from interruptible signal handlers [sigcall] Prior to 2018-01-12: CERT: Unspecified Relationship",
        "language": "C"
    },
    {
        "rule_id": "SIG35-C",
        "rule_title": "Do not return from a computational exception signal handler",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/SIG35-C.+Do+not+return+from+a+computational+exception+signal+handler",
        "content": "According to the C Standard, 7.14.1.1 paragraph 3 [ISO/IEC 9899:2024], if a signal handler returns when it has been entered as a result of a computational exception (that is, with the value of its argument of SIGFPE, SIGILL, SIGSEGV, or any other implementation-defined value corresponding to such an exception) returns, then the behavior is undefined. (See undefined behavior 130.)\nWhen a signal occurs and func points to a function, it is implementation-defined whether the equivalent of signal (sig, SIG_DFL); is executed or the implementation prevents some implementation- defined set of signals (at least including sig) from occurring until the current signal handling has completed; in the case of SIGILL, the implementation may alternatively define that no action is taken. Then the equivalent of (*func)(sig); is executed. If and when the function returns, if the value of sig is SIGFPE, SIGILL, SIGSEGV, or any other implementation-defined value corresponding to a computational exception, the behavior is undefined; otherwise the program will resume execution at the point it was interrupted.\nThe Portable Operating System Interface (POSIX\u00ae), Base Specifications, Issue 7 [IEEE Std 1003.1:2013], adds SIGBUS to the list of computational exception signal handlers:\nThe behavior of a process is undefined after it returns normally from a signal-catching function for a SIGBUS, SIGFPE, SIGILL, or SIGSEGV signal that was not generated by kill(), sigqueue(), or raise().\nDo not return from SIGFPE, SIGILL, SIGSEGV, or any other implementation-defined value corresponding to a computational exception, such as SIGBUS on POSIX systems, regardless of how the signal was generated.\nNoncompliant Code Example\nIn this noncompliant code example, the division operation has undefined behavior 41 if denom equals 0. (See INT33-C. Ensure that division and remainder operations do not result in divide-by-zero errors)  and may result in a SIGFPE signal to the program.)\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n volatile sig_atomic_t denom;\n void sighandle(int s) {\n  /* Fix the offending volatile */\n  if (denom == 0) {\n    denom = 1;\n  }\n}\n int main(int argc, char *argv[]) {\n  if (argc < 2) {\n    return 0;\n  }\n    char *end = NULL;\n  long temp = strtol(argv[1], &end, 10);\n    if (end == argv[1] || 0 != *end ||\n      ((LONG_MIN == temp || LONG_MAX == temp) && errno == ERANGE)) {\n    /* Handle error */\n  }\n    denom = (sig_atomic_t)temp;\n  signal(SIGFPE, sighandle);\n   long result = 100 / (long)denom;\n  return 0;\n}\nWhen compiled with some implementations, this noncompliant code example will loop infinitely if given the input 0. It illustrates that even when a SIGFPE handler attempts to fix the error condition while obeying all other rules of signal handling, the program still does not behave as expected.\nCompliant Solution\nThe only portably safe way to leave a SIGFPE, SIGILL, or SIGSEGV handler is to invoke abort(), quick_exit(), or _Exit(). In the case of SIGFPE, the default action is abnormal termination, so no user-defined handler is required:\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdlib.h>\n int main(int argc, char *argv[]) {\n  if (argc < 2) {\n    return 0;\n  }\n    char *end = NULL;\n  long denom = strtol(argv[1], &end, 10);\n    if (end == argv[1] || 0 != *end ||\n      ((LONG_MIN == denom || LONG_MAX == denom) && errno == ERANGE)) {\n    /* Handle error */\n  }\n    long result = 100 / denom;\n  return 0;\n}\nImplementation Details\nSome implementations define useful behavior for programs that return from one or more of these signal handlers. For example, Solaris provides the sigfpe() function specifically to set a SIGFPE handler that a program may safely return from. Oracle also provides platform-specific computational exceptions for the SIGTRAP, SIGBUS, and SIGEMT signals. Finally, GNU libsigsegv takes advantage of the ability to return from a SIGSEGV handler to implement page-level memory management in user mode.\nRisk Assessment\nReturning from a computational exception signal handler is undefined behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSIG35-C\nLow\nUnlikely\nNo\nNo\nP1\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAxivion Bauhaus Suite\n7.2.0\nCertC-SIG35\nCodeSonar\n9.1p0\nLANG.STRUCT.RFCESH\nReturn from Computational Exception Signal Handler\nCppcheck Premium\n24.11.0\npremium-cert-sig35-c\n\nHelix QAC\n2025.2\nDF4846, DF4847, DF4848\n\nKlocwork\n2025.2\nCERT.STDLIB.SIGNAL\n\n\nLDRA tool suite\n9.7.1\n44 S Enhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-SIG35-a Do not return from a computational exception signal handler\nPC-lint Plus\n1.4\n2671, 2764\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule SIG35-C Checks for return from computational exception signal handler (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[IEEE Std 1003.1:2013]\n2.4.1, Signal Generation and Delivery\n[ISO/IEC 9899:2024] Subclause 7.14.1.1, \"The signal Function\"",
        "language": "C"
    },
    {
        "rule_id": "CON37-C",
        "rule_title": "Do not call signal() in a multithreaded program",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON37-C.+Do+not+call+signal%28%29+in+a+multithreaded+program",
        "content": "Calling the signal() function in a multithreaded program is undefined behavior. (See undefined behavior 135.)\nNoncompliant Code Example\nThis noncompliant code example invokes the signal() function from a multithreaded program:\n#include <signal.h>\n#include <stddef.h>\n#include <threads.h>\n \nvolatile sig_atomic_t flag = 0;\n\nvoid handler(int signum) {\n  flag = 1;\n}\n\n/* Runs until user sends SIGUSR1 */\nint func(void *data) {\n  while (!flag) {\n    /* ... */\n  }\n  return 0;\n}\n\nint main(void) {\n  signal(SIGUSR1, handler); /* Undefined behavior */\n  thrd_t tid;\n  \n  if (thrd_success != thrd_create(&tid, func, NULL)) {\n    /* Handle error */\n  }\n  /* ... */\n  return 0;\n}\nNOTE: The SIGUSR1 signal value is not defined in the C Standard; consequently, this is not a C-compliant code example.\nCompliant Solution\nThis compliant solution uses an object of type atomic_bool to indicate when the child thread should terminate its loop:\n#include <stdatomic.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <threads.h>\n \natomic_bool flag = ATOMIC_VAR_INIT(false);\n\nint func(void *data) {\n  while (!flag) {\n    /* ... */\n  }\n  return 0;\n}\n\nint main(void) {\n  thrd_t tid;\n  \n  if (thrd_success != thrd_create(&tid, func, NULL)) {\n    /* Handle error */\n  }\n  /* ... */\n  /* Set flag when done */\n  flag = true;\n\n  return 0;\n}\nExceptions\nCON37-C-EX1: Implementations such as POSIX that provide defined behavior when multithreaded programs use custom signal handlers are exempt from this rule [IEEE Std 1003.1-2013].\nRisk Assessment\nMixing signals and threads causes undefined behavior 135.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON37-C\nLow\nProbable\nYes\nNo\nP4\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nAutomated Detection\nTool Version Checker Description\nAstr\u00e9e\n24.04\nstdlib-use-signal Fully checked\nCodeSonar\n9.1p0\nBADFUNC.SIGNAL Use of signal\nCoverity\n2017.07\nMISRA C 2012 Rule 21.5 Over-constraining\nCppcheck Premium\n24.11.0\npremium-cert-con37-c\nHelix QAC\n2025.2\nC5021\nC++5022\n\nKlocwork\n2025.2\nMISRA.STDLIB.SIGNAL\n\nLDRA tool suite\n9.7.1\n44 S Enhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-CON37-a\nThe signal handling facilities of <signal.h> shall not be used\nPC-lint Plus\n1.4\n586\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON37-C Checks for signal call in multithreaded program (rule fully covered)\nRuleChecker\n24.04\nstdlib-use-signal Fully checked\nBibliography\n[IEEE Std 1003.1-2013] XSH 2.9.1, \"Thread Safety\"",
        "language": "C"
    },
    {
        "rule_id": "ERR32-C",
        "rule_title": "Do not rely on indeterminate values of errno",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ERR32-C.+Do+not+rely+on+indeterminate+values+of+errno",
        "content": "According to the C Standard Annex J.2 (133) [ISO/IEC 9899:2024], the behavior of a program is undefined when\nthe value of errno is referred to after a signal occurred other than as the result of calling the abort or raise function and the corresponding signal handler obtained a SIG_ERR return from a call to the signal function.\nSee undefined behavior 133.\nA signal handler is allowed to call signal(); if that fails, signal() returns SIG_ERR and sets errno to a positive value. However, if the event that caused a signal was external (not the result of the program calling abort() or raise()), the only functions the signal handler may call are _Exit() or abort(), or it may call signal() on the signal currently being handled; if signal() fails, the value of errno is indeterminate.\nThis rule is also a special case of SIG31-C. Do not access shared objects in signal handlers. The object designated by errno is of static storage duration and is not a volatile sig_atomic_t. As a result, performing any action that would require errno to be set would normally cause undefined behavior 132. The C Standard, 7.14.1.1, paragraph 5, makes a special exception for errno in this case, allowing errno to take on an indeterminate value but specifying that there is no other undefined behavior. This special exception makes it possible to call signal() from within a signal handler without risking undefined behavior, but the handler, and any code executed after the handler returns, must not depend on the value of errno being meaningful.\nNoncompliant Code Example\nThe handler() function in this noncompliant code example attempts to restore default handling for the signal indicated by signum. If the request to set the signal to default can be honored, the signal() function returns the value of the signal handler for the most recent successful call to the signal() function for the specified signal. Otherwise, a value of SIG_ERR is returned and a positive value is stored in errno. Unfortunately, the value of errno is indeterminate because the handler() function is called when an external signal is raised, so any attempt to read errno (for example, by the perror() function) is undefined behavior:\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ntypedef void (*pfv)(int);\n\nvoid handler(int signum) {\n  pfv old_handler = signal(signum, SIG_DFL);\n  if (old_handler == SIG_ERR) {\n    perror(\"SIGINT handler\"); /* Undefined behavior */\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  pfv old_handler = signal(SIGINT, handler);\n  if (old_handler == SIG_ERR) {\n    perror(\"SIGINT handler\");\n    /* Handle error */\n  }\n\n  /* Main code loop */\n\n  return EXIT_SUCCESS;\n}\nThe call to perror() from handler() also violates SIG30-C. Call only asynchronous-safe functions within signal handlers.\nCompliant Solution\nThis compliant solution does not reference errno and does not return from the signal handler if the signal() call fails:\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ntypedef void (*pfv)(int);\n\nvoid handler(int signum) {\n  pfv old_handler = signal(signum, SIG_DFL);\n  if (old_handler == SIG_ERR) {\n    abort();\n  }\n}\n\nint main(void) {\n  pfv old_handler = signal(SIGINT, handler);\n  if (old_handler == SIG_ERR) {\n    perror(\"SIGINT handler\");\n    /* Handle error */\n  }\n\n  /* Main code loop */\n\n  return EXIT_SUCCESS;\n}\nNoncompliant Code Example (POSIX)\nPOSIX is less restrictive than C about what applications can do in signal handlers. It has a long list of asynchronous-safe functions that can be called. (See SIG30-C. Call only asynchronous-safe functions within signal handlers.) Many of these functions set errno on error, which can lead to a signal handler being executed between a call to a failed function and the subsequent inspection of errno. Consequently, the value inspected is not the one set by that function but the one set by a function call in the signal handler. POSIX applications can avoid this problem by ensuring that signal handlers containing code that might alter errno; always save the value of errno on entry and restore it before returning.\nThe signal handler in this noncompliant code example alters the value of errno. As a result, it can cause incorrect error handling if executed between a failed function call and the subsequent inspection of errno:\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/wait.h>\n\nvoid reaper(int signum) {\n  errno = 0;\n  for (;;) {\n    int rc = waitpid(-1, NULL, WNOHANG);\n    if ((0 == rc) || (-1 == rc && EINTR != errno)) {\n      break;\n    }\n  }\n  if (ECHILD != errno) {\n    /* Handle error */\n  }\n}\n\nint main(void) {\n  struct sigaction act;\n  act.sa_handler = reaper;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGCHLD, &act, NULL) != 0) {\n    /* Handle error */\n  }\n\n  /* ... */\n\n  return EXIT_SUCCESS;\n}\nCompliant Solution (POSIX)\nThis compliant solution saves and restores the value of errno in the signal handler:\n#include <signal.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/wait.h>\n\nvoid reaper(int signum) {\n  errno_t save_errno = errno;\n  errno = 0;\n  for (;;) {\n    int rc = waitpid(-1, NULL, WNOHANG);\n    if ((0 == rc) || (-1 == rc && EINTR != errno)) {\n      break;\n    }\n  }\n  if (ECHILD != errno) {\n    /* Handle error */\n  }\n  errno = save_errno;\n}\n\nint main(void) {\n  struct sigaction act;\n  act.sa_handler = reaper;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGCHLD, &act, NULL) != 0) {\n    /* Handle error */\n  }\n\n  /* ... */\n\n  return EXIT_SUCCESS;\n}\nRisk Assessment\nReferencing indeterminate values of errno is undefined behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nERR32-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nchained-errno-function-calls\nerrno-test-after-wrong-call\nSupported\nAxivion Bauhaus Suite\n7.2.0\nCertC-ERR32\nCompass/ROSE\n\n\nCould detect violations of this rule by looking for signal handlers that themselves call signal(). A violation is reported if the call fails and the handler therefore checks errno. A violation also exists if the signal handler modifies errno without first copying its value elsewhere\nCoverity\n2017.07\nMISRA C 2012 Rule 22.8\nMISRA C 2012 Rule 22.9\nMISRA C 2012 Rule 22.10\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-err32-c\nHelix QAC\n2025.2\nC2031\nDF4781, DF4782, DF4783\n\nKlocwork\n2025.2\nMISRA.INCL.SIGNAL.2012\nMISRA.STDLIB.SIGNAL\n\nLDRA tool suite\n9.7.1\n44 S Enhanced enforcement\nParasoft C/C++test 2024.2 CERT_C-ERR32-b\nProperly define signal handlers\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ERR32-C Checks for misuse of errno in a signal handler (rule fully covered)\nRuleChecker\n24.04\nchained-errno-function-calls\nerrno-test-after-wrong-call\nSupported\nSecurity Reviewer - Static Reviewer\n6.02\nC34 Fully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard SIG30-C. Call only asynchronous-safe functions within signal handlers Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard SIG31-C. Do not access shared objects in signal handlers Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] Subclause 7.14.1.1, \"The signal Function\"",
        "language": "C"
    },
    {
        "rule_id": "ERR30-C",
        "rule_title": "Take care when reading errno",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ERR30-C.+Take+care+when+reading+errno",
        "content": "The value of errno is initialized to zero at program startup, but it is never subsequently set to zero by any C standard library function. The value of errno may be set to nonzero by a C standard library function call whether or not there is an error, provided the use of errno is not documented in the description of the function. It is meaningful for a program to inspect the contents of errno only after an error might have occurred. More precisely, errno is meaningful only after a library function that sets errno on error has returned an error code.\nAccording to Question 20.4 of C-FAQ [Summit 2005],\nIn general, you should detect errors by checking return values, and use errno only to distinguish among the various causes of an error, such as \"File not found\" or \"Permission denied.\" (Typically, you use perror or strerror to print these discriminating error messages.) It's only necessary to detect errors with errno when a function does not have a unique, unambiguous, out-of-band error return (that is, because all of its possible return values are valid; one example is atoi [sic]). In these cases (and in these cases only; check the documentation to be sure whether a function allows this), you can detect errors by setting errno to 0, calling the function, and then testing errno. (Setting errno to 0 first is important, as no library function ever does that for you.)\nNote that atoi() is not required to set the value of errno.\nLibrary functions fall into the following categories:\nThose that set errno and return an out-of-band error indicator\nThose that set errno and return an in-band error indicator\nThose that do not promise to set errno\nThose with differing standards documentation\nLibrary Functions that Set errno and Return an Out-of-Band Error Indicator\nThe C Standard specifies that the functions listed in the following table set errno and return an out-of-band error indicator. That is, their return value on error can never be returned by a successful call.\nA program may check errno after invoking these library functions but is not required to do so. The program should not check the value of errno without first verifying that the function returned an error indicator. For example, errno should not be checked after calling signal() without first ensuring that signal() actually returned SIG_ERR.\nFunctions That Set errno and Return an Out-of-Band Error Indicator\nFunction Name\nReturn Value\nerrno Value\nftell() -1L  Positive \nfgetpos(), fsetpos()\nNonzero\nPositive\nmbrtowc(), mbsrtowcs()\n(size_t)(-1)\nEILSEQ\nsignal()\nSIG_ERR\nPositive\nwcrtomb(), wcsrtombs()\n(size_t)(-1)\nEILSEQ\nmbrtoc16(), mbrtoc32() (size_t)(-1)  EILSEQ\nc16rtomb(), c32rtomb() (size_t)(-1)  EILSEQ \nLibrary Functions that Set errno and Return an In-Band Error Indicator\nThe C Standard specifies that the functions listed in the following table set errno and return an in-band error indicator. That is, the return value when an error occurs is also a valid return value for successful calls. For example, the strtoul() function returns ULONG_MAX and sets errno to ERANGE if an error occurs. Because ULONG_MAX is a valid return value, the only way to confirm that an error occurred when LONG_MAX is returned is to check errno.\nThe fgetwc() and fputwc() functions return WEOF in multiple cases, only one of which results in setting errno. The string conversion functions will return the maximum or minimum representable value and set errno to ERANGE if the converted value cannot be represented by the data type. However, if the conversion cannot happen because the input is invalid, the function will return 0, and the output pointer parameter will be assigned the value of the input pointer parameter, provided the output parameter is non-null.\nA program that uses errno for error checking  a function that returns an in-band error indicator must set errno to 0 before calling one of these library functions and then inspect errno before a subsequent library function call.\nFunctions that Set errno and Return an In-Band Error Indicator\nFunction Name\nReturn Value\nerrno Value\nfgetwc(), fputwc()\nWEOF\nEILSEQ\nstrtol(), wcstol()\nLONG_MIN or LONG_MAX\nERANGE\nstrtoll(), wcstoll()\nLLONG_MIN or LLONG_MAX\nERANGE\nstrtoul(), wcstoul()\nULONG_MAX\nERANGE\nstrtoull(), wcstoull()\nULLONG_MAX\nERANGE\nstrtoumax(), wcstoumax()\nUINTMAX_MAX\nERANGE\nstrtod(), wcstod()\n0 or \u00b1HUGE_VAL\nERANGE\nstrtof(), wcstof()\n0 or \u00b1HUGE_VALF\nERANGE\nstrtold(), wcstold()\n0 or \u00b1HUGE_VALL\nERANGE\nstrtoimax(), wcstoimax()\nINTMAX_MIN, INTMAX_MAX\nERANGE\nLibrary Functions that Do Not Promise to Set errno\nThe C Standard fails to document the behavior of errno for some functions. For example, the setlocale() function normally returns a null pointer in the event of an error, but no guarantees are made about setting errno.\nAfter calling one of these functions, a program should not rely solely on the value of errno to determine if an error occurred. The function might have altered errno, but this does not ensure that errno will properly indicate an error condition. If the program does check errno after calling one of these functions, it should set errno to 0 before the function call.\nLibrary Functions with Differing Standards Documentation\nSome functions behave differently regarding errno in various standards. The fopen() function is one such example. When fopen() encounters an error, it returns a null pointer. The C Standard makes no mention of errno when describing fopen(). However, POSIX.1 declares that when fopen() encounters an error, it returns a null pointer and sets errno to a value indicating the error [IEEE Std 1003.1-2013]. The implication is that a program conforming to C but not to POSIX (such as a Windows program) should not check errno after calling fopen(), but a POSIX program may check errno if fopen() returns a null pointer.\nLibrary Functions and errno\nThe following uses of errno are documented in the C Standard:\nFunctions defined in <complex.h> may set errno but are not required to.\nFor numeric conversion functions in the strtod, strtol, wcstod, and wcstol families, if the correct result is outside the range of representable values, an appropriate minimum or maximum value is returned and the value ERANGE is stored in errno. For floating-point conversion functions in the strtod and wcstod families, if an underflow occurs, whether errno acquires the value ERANGE is implementation-defined. If the conversion fails, 0 is returned and errno is not set.\nThe numeric conversion function atof() and those in the atoi family \"need not affect the value of\" errno.\nFor mathematical functions in <math.h>, if the integer expression math_errhandling & MATH_ERRNO is nonzero, on a domain error, errno acquires the value EDOM; on an overflow with default rounding or if the mathematical result is an exact infinity from finite arguments, errno acquires the value ERANGE; and on an underflow, whether errno acquires the value ERANGE is implementation-defined.\nIf a request made by calling signal() cannot be honored, a value of SIG_ERR is returned and a positive value is stored in errno.\nThe byte I/O functions, wide-character I/O functions, and multibyte conversion functions store the value of the macro EILSEQ in errno if and only if an encoding error occurs.\nOn failure, fgetpos() and fsetpos() return nonzero and store an implementation-defined positive value in errno.\nOn failure, ftell() returns -1L and stores an implementation-defined positive value in errno.\nThe perror() function maps the error number in errno to a message and writes it to stderr.\nThe POSIX.1 standard defines the use of errno by many more functions (including the C standard library function). POSIX also has a small set of functions that are exceptions to the rule. These functions have no return value reserved to indicate an error, but they still set errno on error. To detect an error, an application must set errno to 0 before calling the function and check whether it is nonzero after the call. Affected functions include strcoll(), strxfrm(), strerror(), wcscoll(), wcsxfrm(), and fwide(). The C Standard allows these functions to set errno to a nonzero value on success. Consequently, this type of error checking should be performed only on POSIX systems.\nNoncompliant Code Example (strtoul())\nThis noncompliant code example fails to set errno to 0 before invoking strtoul(). If an error occurs, strtoul() returns a valid value (ULONG_MAX), so errno is the only means of determining if strtoul() ran successfully.\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n  void func(const char *c_str) {\n  unsigned long number;\n  char *endptr;\n     number = strtoul(c_str, &endptr, 0);\n  if (endptr == c_str || (number == ULONG_MAX\n                         && errno == ERANGE)) {\n    /* Handle error */\n  } else {\n    /* Computation succeeded */\n  }\n}\nAny error detected in this manner may have occurred earlier in the program or may not represent an actual error.\nCompliant Solution (strtoul())\nThis compliant solution sets errno to 0 before the call to strtoul() and inspects errno after the call:\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n  void func(const char *c_str) {\n  unsigned long number;\n  char *endptr;\n    errno = 0;\n  number = strtoul(c_str, &endptr, 0);\n  if (endptr == c_str || (number == ULONG_MAX\n                         && errno == ERANGE)) {\n    /* Handle error */\n  } else {\n    /* Computation succeeded */\n  }\n}\nNoncompliant Code Example (ftell())\nThis noncompliant code example, after calling ftell(), examines errno without first checking whether the out-of-band indicator returned by ftell() indicates an error.\n#include <errno.h>\n#include <stdio.h>\n void func(FILE* fp) {\n  errno=0;\n  ftell(fp);\n  if (errno) {\n    perror(\"ftell\");\n  }\n}\nCompliant Solution (ftell())\nThis compliant solution first detects that ftell() failed using its out-of-band error indicator. Once an error has been confirmed, reading errno (implicitly by using the perror() function) is permitted.\n#include <errno.h>\n#include <stdio.h>\n void func(FILE* fp) {\n  if (ftell(fp) == -1) {\n    perror(\"ftell\");\n  }\n}\nNoncompliant Code Example (fopen())\nThis noncompliant code example may fail to diagnose errors because fopen() might not set errno even if an error occurs:\n#include <errno.h>\n#include <stdio.h>\n  void func(const char *filename) {\n  FILE *fileptr;\n   errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (errno != 0) {\n    /* Handle error */\n  }\n}\nCompliant Solution (fopen(), C)\nThe C Standard makes no mention of errno when describing fopen(). In this compliant solution, the results of the call to fopen() are used to determine failure and errno is not checked:\n#include <stdio.h>\n  void func(const char *filename) {\n  FILE *fileptr = fopen(filename, \"rb\");\n  if (fileptr == NULL)  {\n    /* An error occurred in fopen() */\n  }\n}\nCompliant Solution (fopen(), POSIX)\nIn this compliant solution, errno is checked only after an error has already been detected by another means:\n#include <errno.h>\n#include <stdio.h>\n  void func(const char *filename) {\n  FILE *fileptr;\n   errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (fileptr == NULL)  {\n    /*\n     * An error occurred in fopen(); now it's valid\n     * to examine errno.\n     */\n    perror(filename);\n  }\n}\nRisk Assessment\nThe improper use of errno may result in failing to detect an error condition or in incorrectly identifying an error condition when none exists.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nERR30-C\nMedium\nProbable\nYes\nYes\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nerrno-reset Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-ERR30 Fully implemented\nCodeSonar\n9.1p0\nLANG.STRUCT.RC\nRedundant Condition\nCompass/ROSE\n\nCould detect violations of this rule by ensuring that each library function is accompanied by the proper treatment of errno\nCoverity\n2017.07\nMISRA C 2012 Rule 22.8\nMISRA C 2012 Rule 22.9\nMISRA C 2012 Rule 22.10\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-err30-c\nHelix QAC\n2025.2\nC2500, C2501, C2502, C2503 \nC++3172, C++3173, C++3174, C++3175, C++3176, C++3177, C++3178, C++3179, C++3183, C++3184\n\nKlocwork\n2025.2\nCXX.ERRNO.NOT_SET\nCXX.ERRNO.NOT_CHECKED\nCXX.ERRNO.INCORRECTLY_CHECKED\n\nLDRA tool suite\n9.7.1\n111 D, 121 D, 122 D, 132  D, 134 D\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-ERR30-a\nProperly use errno value\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ERR30-C\n\nChecks for:\nMisuse of errno\nErrno not reset\nRule fully covered.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard EXP12-C. Do not ignore values returned by functions Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Incorrectly setting and using errno [inverrno] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-456, Missing Initialization of a Variable 2017-07-05: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-456 and ERR30-C\nCWE-456 = EXP33-C\nCWE-456 = Union( ERR30-C, list) where list =\n\nReading potentially uninitialized variables besides errno\n\nCWE-248 and ERR30-C\nIntersection( CWE-248, ERR30-C) = \u00d8\nCWE-248 is only for languages that support exceptions.  It lists C++ and Java, but not C.\nBibliography\n[Brainbell.com] Macros and Miscellaneous Pitfalls\n[Horton 1990] Section 11, p. 168\nSection 14, p. 254\n[IEEE Std 1003.1-2013] XSH, System Interfaces, fopen\n[Koenig 1989] Section 5.4, p. 73\n[Summit 2005]",
        "language": "C"
    },
    {
        "rule_id": "ERR33-C",
        "rule_title": "Detect and handle standard library errors",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors",
        "content": "The majority of the standard library functions, including I/O functions and memory allocation functions, return either a valid value or a value of the correct return type that indicates an error (for example, \u22121 or a null pointer). Assuming that all calls to such functions will succeed and failing to check the return value for an indication of an error is a dangerous practice that may lead to unexpected or undefined behavior when an error occurs. It is essential that programs detect and appropriately handle all errors in accordance with an error-handling policy.\nThe successful completion or failure of each of the standard library functions listed in the following table shall be determined either by comparing the function\u2019s return value with the value listed in the column labeled \u201cError Return\u201d or by calling one of the library functions mentioned in the footnotes.\nStandard Library Functions\nFunction\nSuccessful Return\nError Return\naligned_alloc()\nPointer to space\nNULL\nasctime_s()\n0\nNonzero\nat_quick_exit()\n0\nNonzero\natexit()\n0\nNonzero\nbsearch()\nPointer to matching element\nNULL\nbsearch_s()\nPointer to matching element\nNULL\nbtowc()\nConverted wide character\nWEOF\nc16rtomb()\nNumber of bytes\n(size_t)(-1)\nc32rtomb()\nNumber of bytes\n(size_t)(-1)\ncalloc()\nPointer to space\nNULL\nclock()\nProcessor time\n(clock_t)(-1)\ncnd_broadcast()\nthrd_success\nthrd_error\ncnd_init()\nthrd_success\nthrd_nomem or thrd_error\ncnd_signal()\nthrd_success\nthrd_error\ncnd_timedwait()\nthrd_success\nthrd_timedout or thrd_error\ncnd_wait()\nthrd_success\nthrd_error\nctime_s()\n0\nNonzero\nfclose()\n0\nEOF (negative)\nfflush()\n0\nEOF (negative)\nfgetc()\nCharacter read\nEOF1\nfgetpos()\n0\nNonzero, errno > 0\nfgets()\nPointer to string\nNULL\nfgetwc()\nWide character read\nWEOF1\nfopen()\nPointer to stream\nNULL\nfopen_s()\n0\nNonzero\nfprintf()\nNumber of characters (nonnegative)\nNegative\nfprintf_s()\nNumber of characters (nonnegative)\nNegative\nfputc()\nCharacter written\nEOF2\nfputs()\nNonnegative\nEOF (negative)\nfputwc() Wide character written  WEOF\nfputws()\nNonnegative\nEOF (negative)\nfread()\nElements read\nElements read\nfreopen()\nPointer to stream\nNULL\nfreopen_s()\n0\nNonzero\nfscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nfscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nfseek()\n0\nNonzero\nfsetpos()\n0\nNonzero, errno > 0\nftell()\nFile position\n\u22121L, errno > 0\nfwprintf()\nNumber of wide characters (nonnegative)\nNegative\nfwprintf_s()\nNumber of wide characters (nonnegative)\nNegative\nfwrite()\nElements written\nElements written\nfwscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nfwscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\ngetc()\nCharacter read\nEOF1\ngetchar()\nCharacter read\nEOF1\ngetenv()\nPointer to string\nNULL\ngetenv_s()\nPointer to string\nNULL\ngets_s()\nPointer to string\nNULL\ngetwc()\nWide character read\nWEOF\ngetwchar()\nWide character read\nWEOF\ngmtime()\nPointer to broken-down time\nNULL\ngmtime_s()\nPointer to broken-down time\nNULL\nlocaltime()\nPointer to broken-down time\nNULL\nlocaltime_s()\nPointer to broken-down time\nNULL\nmalloc()\nPointer to space\nNULL\nmblen(), s != NULL\nNumber of bytes\n\u22121\nmbrlen(), s != NULL\nNumber of bytes or status\n(size_t)(-1)\nmbrtoc16()\nNumber of bytes or status\n(size_t)(-1), errno == EILSEQ\nmbrtoc32()\nNumber of bytes or status\n(size_t)(-1), errno == EILSEQ\nmbrtowc(), s != NULL\nNumber of bytes or status\n(size_t)(-1), errno == EILSEQ\nmbsrtowcs()\nNumber of non-null elements\n(size_t)(-1), errno == EILSEQ\nmbsrtowcs_s()\n0\nNonzero\nmbstowcs()\nNumber of non-null elements\n(size_t)(-1)\nmbstowcs_s()\n0\nNonzero\nmbtowc(), s != NULL\nNumber of bytes\n\u22121\nmemchr()\nPointer to located character\nNULL\nmktime()\nCalendar time\n(time_t)(-1)\nmtx_init()\nthrd_success\nthrd_error\nmtx_lock()\nthrd_success\nthrd_error\nmtx_timedlock()\nthrd_success\nthrd_timedout or thrd_error\nmtx_trylock()\nthrd_success\nthrd_busy or thrd_error\nmtx_unlock()\nthrd_success\nthrd_error\nprintf_s()\nNumber of characters (nonnegative)\nNegative\nputc()\nCharacter written\nEOF2\nputwc()\nWide character written\nWEOF\nraise()\n0\nNonzero\nrealloc()\nPointer to space\nNULL\nremove()\n0\nNonzero\nrename()\n0\nNonzero\nsetlocale()\nPointer to string\nNULL\nsetvbuf()\n0\nNonzero\nscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nsignal()\nPointer to previous function\nSIG_ERR, errno > 0\nsnprintf()\nNumber of characters that would be written (nonnegative)\nNegative\nsnprintf_s()\nNumber of characters that would be written (nonnegative)\nNegative\nsprintf()\nNumber of non-null characters written\nNegative\nsprintf_s()\nNumber of non-null characters written\nNegative\nsscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nsscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nstrchr()\nPointer to located character\nNULL\nstrerror_s()\n0\nNonzero\nstrftime()\nNumber of non-null characters\n0\nstrpbrk()\nPointer to located character\nNULL\nstrrchr()\nPointer to located character\nNULL\nstrstr()\nPointer to located string\nNULL\nstrtod()\nConverted value\n0, errno == ERANGE\nstrtof()\nConverted value\n0, errno == ERANGE\nstrtoimax()\nConverted value\nINTMAX_MAX or INTMAX_MIN, errno == ERANGE\nstrtok()\nPointer to first character of a token\nNULL\nstrtok_s()\nPointer to first character of a token\nNULL\nstrtol()\nConverted value\nLONG_MAX or LONG_MIN, errno == ERANGE\nstrtold()\nConverted value\n0, errno == ERANGE\nstrtoll()\nConverted value\nLLONG_MAX or LLONG_MIN, errno == ERANGE\nstrtoumax()\nConverted value\nUINTMAX_MAX, errno == ERANGE\nstrtoul()\nConverted value\nULONG_MAX, errno == ERANGE\nstrtoull()\nConverted value\nULLONG_MAX, errno == ERANGE\nstrxfrm()\nLength of transformed string\n>= n\nswprintf()\nNumber of non-null wide characters\nNegative\nswprintf_s()\nNumber of non-null wide characters\nNegative\nswscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nswscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nthrd_create()\nthrd_success\nthrd_nomem or thrd_error\nthrd_detach()\nthrd_success\nthrd_error\nthrd_join()\nthrd_success\nthrd_error\nthrd_sleep()\n0\nNegative\ntime()\nCalendar time\n(time_t)(-1)\ntimespec_get()\nBase\n0\ntmpfile()\nPointer to stream\nNULL\ntmpfile_s()\n0\nNonzero\ntmpnam()\nNon-null pointer\nNULL\ntmpnam_s()\n0\nNonzero\ntss_create()\nthrd_success\nthrd_error\ntss_get()\nValue of thread-specific storage\n0\ntss_set()\nthrd_success\nthrd_error\nungetc()\nCharacter pushed back\nEOF (see below)\nungetwc()\nCharacter pushed back\nWEOF\nvfprintf()\nNumber of characters (nonnegative)\nNegative\nvfprintf_s()\nNumber of characters (nonnegative)\nNegative\nvfscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nvfscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nvfwprintf()\nNumber of wide characters (nonnegative)\nNegative\nvfwprintf_s()\nNumber of wide characters (nonnegative)\nNegative\nvfwscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nvfwscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nvprintf_s()\nNumber of characters (nonnegative)\nNegative\nvscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nvscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nvsnprintf()\nNumber of characters that would be written (nonnegative)\nNegative\nvsnprintf_s()\nNumber of characters that would be written (nonnegative)\nNegative\nvsprintf()\nNumber of non-null characters (nonnegative)\nNegative\nvsprintf_s()\nNumber of non-null characters (nonnegative)\nNegative\nvsscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nvsscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nvswprintf()\nNumber of non-null wide characters\nNegative\nvswprintf_s()\nNumber of non-null wide characters\nNegative\nvswscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nvswscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nvwprintf_s()\nNumber of wide characters (nonnegative)\nNegative\nvwscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nvwscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nwcrtomb()\nNumber of bytes stored\n(size_t)(-1)\nwcschr()\nPointer to located wide character\nNULL\nwcsftime()\nNumber of non-null wide characters\n0\nwcspbrk()\nPointer to located wide character\nNULL\nwcsrchr()\nPointer to located wide character\nNULL\nwcsrtombs()\nNumber of non-null bytes\n(size_t)(-1), errno == EILSEQ\nwcsrtombs_s()\n0\nNonzero\nwcsstr()\nPointer to located wide string\nNULL\nwcstod()\nConverted value\n0, errno == ERANGE\nwcstof()\nConverted value\n0, errno == ERANGE\nwcstoimax()\nConverted value\nINTMAX_MAX or INTMAX_MIN, errno == ERANGE\nwcstok()\nPointer to first wide character of a token\nNULL\nwcstok_s()\nPointer to first wide character of a token\nNULL\nwcstol()\nConverted value\nLONG_MAX or LONG_MIN, errno == ERANGE\nwcstold()\nConverted value\n0, errno == ERANGE\nwcstoll()\nConverted value\nLLONG_MAX or LLONG_MIN, errno == ERANGE\nwcstombs()\nNumber of non-null bytes\n(size_t)(-1)\nwcstombs_s()\n0\nNonzero\nwcstoumax()\nConverted value\nUINTMAX_MAX, errno == ERANGE\nwcstoul()\nConverted value\nULONG_MAX, errno == ERANGE\nwcstoull()\nConverted value\nULLONG_MAX, errno == ERANGE\nwcsxfrm()\nLength of transformed wide string\n>= n\nwctob()\nConverted character\nEOF\nwctomb(), s != NULL\nNumber of bytes stored\n\u22121\nwctomb_s(), s != NULL\nNumber of bytes stored\n\u22121\nwctrans()\nValid argument to towctrans\n0\nwctype()\nValid argument to iswctype\n0\nwmemchr()\nPointer to located wide character\nNULL\nwprintf_s()\nNumber of wide characters (nonnegative)\nNegative\nwscanf()\nNumber of conversions (nonnegative)\nEOF (negative)\nwscanf_s()\nNumber of conversions (nonnegative)\nEOF (negative)\nNote: According to FIO35-C. Use feof() and ferror() to detect end-of-file and file errors when sizeof(int) == sizeof(char), callers should verify end-of-file and file errors for the functions in this table as follows:\n1 By calling ferror() and feof()\n2 By calling ferror()\nThe ungetc() function does not set the error indicator even when it fails, so it is not possible to check for errors reliably unless it is known that the argument is not equal to EOF.\nThe C Standard 7.31.3.10 paragraph 3 [ISO/IEC 9899:2024] states that\n )ne wide character of pushback is guaranteed...\nso this should not be an issue if, at most, one character is ever pushed back before reading again. (See FIO13-C. Never push back anything other than one read character.)\nNoncompliant Code Example (setlocale())\nIn this noncompliant code example, the function utf8_to_wcs() attempts to convert a sequence of UTF-8 characters to wide characters. It first invokes setlocale() to set the global locale to the implementation-defined en_US.UTF-8 but does not check for failure. The setlocale() function will fail by returning a null pointer, for example, when the locale is not installed. The function may fail for other reasons as well, such as the lack of resources.  Depending on the sequence of characters pointed to by utf8, the subsequent call to mbstowcs() may fail or result in the function storing an unexpected sequence of wide characters in the supplied buffer wcs.\n#include <locale.h>\n#include <stdlib.h>\n \nint utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,\n                size_t *size) {\n  if (NULL == size) {\n    return -1;\n  }\n  setlocale(LC_CTYPE, \"en_US.UTF-8\");\n  *size = mbstowcs(wcs, utf8, n);\n  return 0;\n}\nCompliant Solution (setlocale())\nThis compliant solution checks the value returned by setlocale() and avoids calling mbstowcs() if the function fails. The function also takes care to restore the locale to its initial setting before returning control to the caller.\n#include <locale.h>\n#include <stdlib.h>\n \nint utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,\n                size_t *size) {\n  if (NULL == size) {\n    return -1;\n  }\n  const char *save = setlocale(LC_CTYPE, \"en_US.UTF-8\");\n  if (NULL == save) {\n    return -1;\n  }\n\n  *size = mbstowcs(wcs, utf8, n);\n  if (NULL == setlocale(LC_CTYPE, save)) {\n    return -1;\n  }\n  return 0;\n}\nNoncompliant Code Example (calloc())\nIn this noncompliant code example, temp_num, tmp2, and num_of_records are derived from a tainted source. Consequently, an attacker can easily cause calloc() to fail by providing a large value for num_of_records. \n#include <stdlib.h>\n#include <string.h>\n \nenum { SIG_DESC_SIZE = 32 };\n\ntypedef struct {\n  char sig_desc[SIG_DESC_SIZE];\n} signal_info;\n \nvoid func(size_t num_of_records, size_t temp_num,\n          const char *tmp2, size_t tmp2_size_bytes) {\n  signal_info *start = (signal_info *)calloc(num_of_records,\n                                          sizeof(signal_info));\n\n  if (tmp2 == NULL) {\n    /* Handle error */\n  } else if (temp_num > num_of_records || temp_num == 0) {\n    /* Handle error */\n  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {\n    /* Handle error */\n  }\n\n  signal_info *point = start + temp_num - 1;\n  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);\n  point->sig_desc[SIG_DESC_SIZE - 1] = '\\0';\n  /* ... */\n  free(start);\n}\nWhen calloc() fails, it returns a null pointer that is assigned to start. If start is null, an attacker can provide a value for temp_num that, when scaled by sizeof(signal_info), references a writable address to which control is eventually transferred. The contents of the string referenced by tmp2 can then be used to overwrite the address, resulting in an arbitrary code execution vulnerability.\nCompliant Solution (calloc())\nTo correct this error, ensure the pointer returned by calloc() is not null:\n#include <stdlib.h>\n#include <string.h>\n\nenum { SIG_DESC_SIZE = 32 };\n\ntypedef struct {\n  char sig_desc[SIG_DESC_SIZE];\n} signal_info;\n \nvoid func(size_t num_of_records, size_t temp_num,\n          const char *tmp2, size_t tmp2_size_bytes) {\n  signal_info *start = (signal_info *)calloc(num_of_records,\n                                           sizeof(signal_info));\n  if (start == NULL) {\n    /* Handle allocation error */\n  } else if (tmp2 == NULL) {\n    /* Handle error */\n  } else if (temp_num > num_of_records || temp_num == 0) {\n    /* Handle error */\n  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {\n    /* Handle error */\n  }\n\n  signal_info *point = start + temp_num - 1; \n  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);\n  point->sig_desc[SIG_DESC_SIZE - 1] = '\\0';\n  /* ... */\n  free(start);\n}\nNoncompliant Code Example (realloc())\nThis noncompliant code example calls realloc() to resize the memory referred to by p. However, if realloc() fails, it returns a null pointer and the connection between the original block of memory and p is lost, resulting in a memory leak.\n#include <stdlib.h>\n \nvoid *p;\nvoid func(size_t new_size) {\n  if (new_size == 0) {\n    /* Handle error */\n  }\n  p = realloc(p, new_size);\n  if (p == NULL) {\n   /* Handle error */\n  }\n}\nThis code example complies with MEM04-C. Do not perform zero-length allocations.\nCompliant Solution (realloc())\nIn this compliant solution, the result of realloc() is assigned to the temporary pointer q and validated before it is assigned to the original pointer p:\n#include <stdlib.h>\n \nvoid *p;\nvoid func(size_t new_size) {\n  void *q;\n\n  if (new_size == 0) {\n    /* Handle error */\n  }\n \n  q = realloc(p, new_size);\n  if (q == NULL) {\n   /* Handle error */\n  } else {\n    p = q;\n  }\n}\nNoncompliant Code Example (fseek())\nIn this noncompliant code example, the fseek() function is used to set the file position to a location offset in the file referred to by file prior to reading a sequence of bytes from the file. However, if an I/O error occurs during the seek operation, the subsequent read will fill the buffer with the wrong contents.\n#include <stdio.h>\n \nsize_t read_at(FILE *file, long offset,\n               void *buf, size_t nbytes) {\n  fseek(file, offset, SEEK_SET);\n  return fread(buf, 1, nbytes, file);\n}\nCompliant Solution (fseek())\nAccording to the C Standard, the fseek() function returns a nonzero value to indicate that an error occurred. This compliant solution tests for this condition before reading from a file to eliminate the chance of operating on the wrong portion of the file if fseek() fails:\n#include <stdio.h>\n \nsize_t read_at(FILE *file, long offset,\n               void *buf, size_t nbytes) {\n  if (fseek(file, offset, SEEK_SET) != 0) {\n    /* Indicate error to caller */\n    return 0;\n  }\n  return fread(buf, 1, nbytes, file);\n}\nNoncompliant Code Example (snprintf())\nIn this noncompliant code example, snprintf() is assumed to succeed. However, if the call fails (for example, because of insufficient memory, as described in GNU libc bug 441945), the subsequent call to log_message() has undefined behavior 174 because the character buffer is uninitialized and need not be null-terminated.\n#include <stdio.h>\n \nextern void log_message(const char *);\n\nvoid f(int i, int width, int prec) {\n  char buf[40];\n  snprintf(buf, sizeof(buf), \"i = %*.*i\", width, prec, i);\n  log_message(buf);\n  /* ... */\n}\nCompliant Solution (snprintf())\nThis compliant solution does not assume that snprintf() will succeed regardless of its arguments. It tests the return value of snprintf() before subsequently using the formatted buffer. This compliant solution also treats the case where the static buffer is not large enough for snprintf() to append the terminating null character as an error.\n#include <stdio.h>\n#include <string.h>\n \nextern void log_message(const char *);\n\nvoid f(int i, int width, int prec) {\n  char buf[40];\n  int n;\n  n = snprintf(buf, sizeof(buf), \"i = %*.*i\", width, prec, i);\n  if (n < 0 || n >= sizeof(buf)) {\n    /* Handle snprintf() error */\n    strcpy(buf, \"unknown error\");\n  }\n  log_message(buf);\n}\nCompliant Solution (snprintf(null))\nIf unknown, the length of the formatted string can be discovered by invoking snprintf() with a null buffer pointer to determine the size required for the output, then dynamically allocating a buffer of sufficient size, and finally calling snprintf() again to format the output into the dynamically allocated buffer. Even with this approach, the success of all calls still needs to be tested, and any errors must be appropriately handled. A possible optimization is to first attempt to format the string into a reasonably small buffer allocated on the stack and, only when the buffer turns out to be too small, dynamically allocate one of a sufficient size:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \nextern void log_message(const char *); \n \nvoid f(int i, int width, int prec) {\n  char buffer[20];\n  char *buf = buffer;\n  int n  = sizeof(buffer);\n  const char fmt[] = \"i = %*.*i\";\n\n  n = snprintf(buf, n, fmt, width, prec, i);\n  if (n < 0) {\n    /* Handle snprintf() error */\n    strcpy(buffer, \"unknown error\");\n    goto write_log;\n  }\n\n  if (n < sizeof(buffer)) {\n    goto write_log;\n  }\n\n  buf = (char *)malloc(n + 1);\n  if (NULL == buf) {\n    /* Handle malloc() error */\n    strcpy(buffer, \"unknown error\");\n    goto write_log;\n  }\n\n  n = snprintf(buf, n, fmt, width, prec, i);\n  if (n < 0) {\n    /* Handle snprintf() error */\n    strcpy(buffer, \"unknown error\");\n  }\n\nwrite_log:\n  log_message(buf);\n\n  if (buf != buffer) {\n    free(buf);\n  }\n}\nThis solution uses the goto statement, as suggested in MEM12-C. Consider using a goto chain when leaving a function on error when using and releasing resources.\nExceptions\nERR33-C-EX1: It is acceptable to ignore the return value of a function if:\nthat function cannot fail.\nits return value is inconsequential; that is, it does not indicate an error.\nit is one of a handful of functions whose return values are not traditionally checked.\nThese functions are listed in the following table:\nFunctions for which Return Values Need Not Be Checked\nFunction\nSuccessful Return\nError Return\nputchar()\nCharacter written\nEOF\nputwchar()\nWide character written\nWEOF\nputs()\nNonnegative\nEOF (negative)\nputws()\nNonnegative\nWEOF\nprintf(), vprintf()\nNumber of characters (nonnegative)\nNegative\nwprintf(), vwprintf()\nNumber of wide characters (nonnegative)\nNegative\nkill_dependency() The input parameter  NA\nmemcpy(), wmemcpy() The destination input parameter NA\nmemmove(), wmemmove() The destination input parameter  NA\nstrcpy(), wcscpy() The destination input parameter  NA\nstrncpy(), wcsncpy() The destination input parameter  NA \nstrcat(), wcscat() The destination input parameter  NA \nstrncat(), wcsncat() The destination input parameter  NA\nmemset(), wmemset() The destination input parameter NA \nThe return value of a call to fprintf() or one of its variants (vfprintf(), wfprintf(), vwfprintf()) or one of the file output functions fputc(), fputwc(), fputs(), fputws() may be ignored if the output is being directed to stdout or stderr . Otherwise, the return value must be checked.\nIf a function's return value is to be ignored, it is recommended that the function's return value should be explicitly cast to void to signify the programmer's intent:\nint main() {\n  (void) fprintf(stdout, \"Hello, world\\n\"); // fprintf() return value safely ignored\n}\nRisk Assessment\nFailing to detect error conditions can lead to unpredictable results, including abnormal program termination and denial-of-service attacks or, in some situations, could even allow an attacker to run arbitrary code.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nERR33-C\nHigh\nLikely\nYes\nYes\nP27\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nerror-information-unused\nerror-information-unused-computed Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-ERR33\nCodeSonar\n9.1p0\nLANG.FUNCS.IRV\nLANG.ERRCODE.NOTEST\nLANG.ERRCODE.NZ\nIgnored return value\nMissing Test of Error Code\nNon-zero Error Code\nCompass/ROSE\n\nCan detect violations of this recommendation when checking for violations of EXP12-C. Do not ignore values returned by functions and EXP34-C. Do not dereference null pointers\nCoverity\n2017.07\nMISRA C 2012 Rule 22.8\nMISRA C 2012 Rule 22.9\nMISRA C 2012 Rule 22.10\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-err33-c\nHelix QAC\n2025.2\nC3200\nC++3802, C++3803, C++3804\nDF2820, DF2821, DF2822, DF2823, DF2824, DF2930, DF2931, DF2932, DF2933, DF2934\n\nKlocwork\n2025.2\nNPD.CHECK.MUST\nNPD.FUNC.MUST\nSV.RVT.RETVAL_NOTTESTED\n\nLDRA tool suite\n9.7.1\n80 D\nPartially implemented\nParasoft C/C++test 2024.2\nCERT_C-ERR33-a\nCERT_C-ERR33-d\nCERT_C-ERR33-e\nThe value returned by a standard library function that may return an error should be used\nAlways check the returned value of non-void function\nProvide error handling for file opening errors right next to the call to fopen\nParasoft Insure++\n\nRuntime analysis\nPC-lint Plus\n1.4\n534\nPartially supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ERR33-C\n\nChecks for:\nErrno not checked\nReturn value of a sensitive function not checked\nUnprotected dynamic memory allocation\nRule partially covered.\nRuleChecker\n24.04\nerror-information-unused Partially checked\nTrustInSoft Analyzer\n1.38\npointer arithmetic Exhaustively verified.\nRelated Vulnerabilities\nThe vulnerability in Adobe Flash [VU#159523] arises because Flash neglects to check the return value from calloc(). Even when calloc() returns a null pointer, Flash writes to an offset from the return value. Dereferencing a null pointer usually results in a program crash, but dereferencing an offset from a null pointer allows an exploit to succeed without crashing the program.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard EXP34-C. Do not dereference null pointers Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard FIO13-C. Never push back anything other than one read character Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard MEM04-C. Do not perform zero-length allocations Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C Secure Coding Standard MEM12-C. Consider using a goto chain when leaving a function on error when using and releasing resources Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C ERR10-CPP. Check for error conditions Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C FIO04-CPP. Detect and handle input and output errors Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961:2013 Failing to detect and handle standard library errors [liberr] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-252, Unchecked Return Value 2017-07-06: CERT: Partial overlap\nCWE 2.11 CWE-253, Incorrect Check of Function Return Value 2017-07-06: CERT: Partial overlap\nCWE 2.11 CWE-391, Unchecked Error Condition 2017-07-06: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-252/CWE-253/CWE-391 and ERR33-C/POS34-C\nIndependent( ERR33-C, POS54-C, FLP32-C, ERR34-C) Intersection( CWE-252, CWE-253) = \u00d8 CWE-391 = Union( CWE-252, CWE-253) CWE-391 = Union( ERR33-C, POS34-C, list) where list =\n\nIgnoring return values of functions outside the C or POSIX standard libraries\n\nBibliography\n[DHS 2006] Handle All Errors Safely\n[Henricson 1997] Recommendation 12.1, \"Check for All Errors Reported from Functions\"\n[ISO/IEC 9899:2024] Subclause 7.31.3.10, \"The ungetc Function\"\n[VU#159523]",
        "language": "C"
    },
    {
        "rule_id": "ERR34-C",
        "rule_title": "Detect errors when converting a string to a number",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/ERR34-C.+Detect+errors+when+converting+a+string+to+a+number",
        "content": "The process of parsing an integer or floating-point number from a string can produce many errors. The string might not contain a number. It might contain a number of the correct type that is out of range (such as an integer that is larger than INT_MAX). The string may also contain extra information after the number, which may or may not be useful after the conversion. These error conditions must be detected and addressed when a string-to-number conversion is performed using a C Standard Library function.\nThe strtol(), strtoll(),  strtoimax(), strtoul(), strtoull(), strtoumax(), strtof(), strtod(), and strtold() functions convert the initial portion of a null-terminated byte string to a long int, long long int, intmax_t, unsigned long int, unsigned long long int, uintmax_t, float, double, and long double representation, respectively.\nUse one of the C Standard Library strto*() functions to parse an integer or floating-point number from a string. These functions provide more robust error handling than alternative solutions. Also, use the strtol() function to convert to a smaller signed integer type such as signed int, signed short, and signed char, testing the result against the range limits for that type. Likewise, use the strtoul() function to convert to a smaller unsigned integer type such as unsigned int, unsigned short, and unsigned char, and test the result against the range limits for that type. These range tests do nothing if the smaller type happens to have the same size and representation for a particular implementation.\nNoncompliant Code Example (atoi())\nThis noncompliant code example converts the string token stored in the buff to a signed integer value using the atoi() function:\n#include <stdlib.h>\n  void func(const char *buff) {\n  int si;\n   if (buff) {\n    si = atoi(buff);\n  } else {\n    /* Handle error */\n  }\n}\nThe atoi(), atol(), atoll(), and atof() functions convert the initial portion of a string token to int, long int, long long int, and double representation, respectively. Except for the behavior on error ([ISO/IEC 9899:2024], s7.24.1.2), they are equivalent to\natoi: (int)strtol(nptr, (char **)NULL, 10)\natol: strtol(nptr, (char **)NULL, 10)\natoll: strtoll(nptr, (char **)NULL, 10)\natof: strtod(nptr, (char **)NULL)\nUnfortunately, atoi() and related functions lack a mechanism for reporting errors for invalid values. Specifically, these functions:\ndo not need to set errno on an error;\nhave undefined behavior 16 if the value of the result cannot be represented;\nreturn 0 (or 0.0) if the string does not represent an integer (or decimal), which is indistinguishable from a correctly formatted, zero-denoting input string.\nNoncompliant Example (sscanf())\nThis noncompliant example uses the sscanf() function to convert a string token to an integer. The sscanf() function has the same limitations as atoi():\n#include <stdio.h>\n  void func(const char *buff) {\n  int matches;\n  int si;\n   if (buff) {\n    matches = sscanf(buff, \"%d\", &si);\n    if (matches != 1) {\n      /* Handle error */\n    }\n  } else {\n    /* Handle error */\n  }\n}\nThe sscanf() function returns the number of input items successfully matched and assigned, which can be fewer than provided for, or even 0 in the event of an early matching failure. However, sscanf() fails to report the other errors reported by strtol(), such as numeric overflow.\nCompliant Solution (strtol())\nThe strtol(), strtoll(), strtoimax()), strtoul(), strtoull(), strtoumax(), strtof(), strtod(), and strtold() functions convert a null-terminated byte string to long int, long long int, intmax_t, unsigned long int, unsigned long long int, uintmax_t, float, double, and long double representation, respectively.\nThis compliant solution uses strtol() to convert a string token to an integer and ensures that the value is in the range of int:\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdio.h>\n  void func(const char *buff) {\n  char *end;\n  int si;\n   errno = 0;\n   const long sl = strtol(buff, &end, 10);\n   if (end == buff) {\n    (void) fprintf(stderr, \"%s: not a decimal number\\n\", buff);\n  } else if ('\\0' != *end) {\n    (void) fprintf(stderr, \"%s: extra characters at end of input: %s\\n\", buff, end);\n  } else if ((LONG_MIN == sl || LONG_MAX == sl) && ERANGE == errno) {\n    (void) fprintf(stderr, \"%s out of range of type long\\n\", buff);\n  } else if (sl > INT_MAX) {\n    (void) fprintf(stderr, \"%ld greater than INT_MAX\\n\", sl);\n  } else if (sl < INT_MIN) {\n    (void) fprintf(stderr, \"%ld less than INT_MIN\\n\", sl);\n  } else {\n    si = (int)sl;\n     /* Process si */\n  }\n}\nRisk Assessment\nIt is rare for a violation of this rule to result in a security vulnerability unless it occurs in security-sensitive code. However, violations of this rule can easily result in lost or misinterpreted data. \nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nERR34-C\nMedium\nUnlikely\nYes\nYes\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAxivion Bauhaus Suite\n7.2.0\nCertC-ERR34\nClang\n3.9\ncert-err34-c Checked by clang-tidy\nCodeSonar\n9.1p0\nBADFUNC.ATOF\nBADFUNC.ATOI\nBADFUNC.ATOL\nBADFUNC.ATOLL\n(customization)\nUse of atof\nUse of atoi\nUse of atol\nUse of atoll\nUsers can add custom checks for uses of other undesirable conversion functions.\nCompass/ROSE\n\n\nCan detect violations of this recommendation by flagging invocations of the following functions:\natoi()\nscanf(), fscanf(), sscanf()\nOthers?\nHelix QAC\n2025.2\nC5030\nC++5016\n\nKlocwork\n2025.2\nCERT.ERR.CONV.STR_TO_NUM\nMISRA.STDLIB.ATOI\nSV.BANNED.RECOMMENDED.SCANF\n\nLDRA tool suite\n9.7.1\n44 S\nFully implemented\nParasoft C/C++test\n2024.2\nCERT_C-ERR34-a\nThe 'atof', 'atoi', 'atol' and 'atoll' functions from the 'stdlib.h' or 'cstdlib' library should not be used\nPC-lint Plus\n1.4\n586\nAssistance provided\nPolyspace Bug Finder\nR2025b\nCERT C: Rule ERR34-C Checks for unsafe conversion from string to numeric value (rule fully covered)\nSonarQube C/C++ Plugin\n3.11\nS989\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C INT06-CPP. Use strtol() or a related function to convert a string token to an integer Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-676, Use of potentially dangerous function 2017-05-18: CERT: Rule subset of CWE\nCWE 2.11 CWE-758 2017-06-29: CERT: Partial overlap\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-20 and ERR34-C\nIntersection( ERR34-C, CWE-20) = \u00d8\nCERT C does not define the concept of \u2018input validation\u2019. String-to-integer conversion (ERR34-C) may qualify as input validation, but this is outside the scope of the CERT rule.\nCWE-391 and ERR34-C\nCWE-391 = Union( ERR34-C, list) where list =\n\nFailure to errors outside of string-to-number conversion functions\n\nCWE-676 and ERR34-C\n\nIndependent( ENV33-C, CON33-C, STR31-C, EXP33-C, MSC30-C, ERR34-C)\n\n\nERR34-C implies that string-parsing functions (eg atoi() and scanf()) are dangerous.\n\n\nCWE-676 = Union( ERR34-C, list) where list =\n\n\nInvocation of dangerous functions besides the following:\n\n\natoi(), atol(), atoll(), atof(), The scanf()family\n\nCWE-758 and ERR34-C\nIndependent( INT34-C, INT36-C, MSC37-C, FLP32-C, EXP33-C, EXP30-C, ERR34-C, ARR32-C)\nIntersection( CWE-758, ERR34-C) =\n\nUndefined behavior arising from a non-representable numeric value being parsed by an ato*() or scanf() function\n\nCWE-758 \u2013 ERR34-C =\n\nUndefined behavior arising from using a function outside of the ato*() or scanf() family\n\nERR34-C \u2013 CWE-758 =\n\nThe ato*() or scanf() family receives input that is not a number when trying to parse one\n\nBibliography\n[ISO/IEC 9899:2024] Subclause 7.24.1, \"Numeric conversion functions\"\n[Klein 2002]",
        "language": "C"
    },
    {
        "rule_id": "DCL09-C",
        "rule_title": "Declare functions that return errno with a return type of errno_t",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/DCL09-C.+Declare+functions+that+return+errno+with+a+return+type+of+errno_t",
        "content": "When developing new code, declare functions that return errno with a return type of errno_t.  Many existing functions that return errno are declared as returning a value of type int. It is semantically unclear by inspecting the function declaration or prototype if these functions return an error status or a value or, worse, some combination of the two. (See ERR02-C. Avoid in-band error indicators.)\nC11 Annex K  introduced the new type errno_t that is defined to be type int in errno.h and elsewhere. Many of the functions defined in C11 Annex K return values of this type. The errno_t type should be used as the type of an object that may contain only values that might be found in errno. For example, a function that returns the value of errno should be declared as having the return type errno_t.\nThis recommendation depends on C11 Annex K being implemented. The following code can be added to remove this dependency:\n\n#ifndef __STDC_LIB_EXT1__\n  typedef int errno_t;\n#endif\n\nNoncompliant Code Example\nThis noncompliant code example shows a function called opener() that returns errno error codes. However, the function is declared as returning an int. Consequently, the meaning of the return value is not readily apparent.\n#include <errno.h>\n#include <stdio.h>\n  enum { NO_FILE_POS_VALUES = 3 };\n int opener(\n  FILE *file,\n  size_t *width,\n  size_t *height,\n  size_t *data_offset\n) {\n  size_t file_w;\n  size_t file_h;\n  size_t file_o;\n  fpos_t offset;\n   if (file == NULL) { return EINVAL; }\n  errno = 0;\n  if (fgetpos(file, &offset) != 0) { return errno; }\n  if (fscanf(file, \"%zu %zu %zu\", &file_w, &file_h, &file_o)\n        != NO_FILE_POS_VALUES) {\n    return -1;\n  }\n   errno = 0;\n  if (fsetpos(file, &offset) != 0) { return errno; }\n   if (width != NULL) { *width = file_w; }\n  if (height != NULL) { *height = file_h; }\n  if (data_offset != NULL) { *data_offset = file_o; }\n   return 0;\n}\nThis noncompliant code example nevertheless complies with ERR30-C. Take care when reading errno.\nCompliant Solution (POSIX)\nIn this compliant solution, the opener() function returns a value of type errno_t, providing a clear indication that this function returns an error code:\n#define __STDC_WANT_LIB_EXT1__ 1\n  #include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n     enum { NO_FILE_POS_VALUES = 3 };\n errno_t opener(\n  FILE *file,\n  size_t *width,\n  size_t *height,\n  size_t *data_offset\n) {\n  size_t file_w;\n  size_t file_h;\n  size_t file_o;\n  fpos_t offset;\n   if (NULL == file) { return EINVAL; }\n  errno = 0;\n  if (fgetpos(file, &offset) != 0 ) { return errno; }\n  if (fscanf(file, \"%zu %zu %zu\", &file_w, &file_h, &file_o)\n        != NO_FILE_POS_VALUES) {\n    return EIO;\n  }\n   errno = 0;\n  if (fsetpos(file, &offset) != 0 ) { return errno; }\n   if (width != NULL) { *width = file_w; }\n  if (height != NULL) { *height = file_h; }\n  if (data_offset != NULL) { *data_offset = file_o; }\n   return 0;\n}\nThis compliant solution is categorized as a POSIX solution because it returns EINVAL and EIO , which are defined by POSIX (IEEE Std 1003.1, 2013 Edition) but not by the C Standard.\nRisk Assessment\nFailing to test for error conditions can lead to vulnerabilities of varying severity. Declaring functions that return an errno with a return type of errno_t will not eliminate this problem but may reduce errors caused by programmers' misunderstanding the purpose of a return value.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nDCL09-C\nLow\nUnlikely\nNo\nYes\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAxivion Bauhaus Suite\n7.2.0\nCertC-DCL09\nLDRA tool suite\n 9.7.1\n634 S Partially Implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID DCL09-CPP. Declare functions that return errno with a return type of errno_t\nISO/IEC TR 24772:2013 Ignored Error Status and Unhandled Exceptions [OYB]\nBibliography\n[IEEE Std 1003.1:2013]",
        "language": "C"
    },
    {
        "rule_id": "FLP03-C",
        "rule_title": "Detect and handle floating-point errors",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/FLP03-C.+Detect+and+handle+floating-point+errors",
        "content": "Errors during floating-point operations are often neglected by programmers who instead focus on validating operands before an operation. Errors that occur during floating-point operations are admittedly difficult to determine and diagnose, but the benefits of doing so often outweigh the costs. This recommendation suggests ways to capture errors during floating-point operations.\nThe following code exhibits undefined behavior:\nint j = 0;\nint iResult = 1 / j;\nOn most implementations, integer division by zero is a terminal error, commonly printing a diagnostic message and aborting the program:\ndouble x = 0.0;\ndouble dResult = 1 / x;\nFloating-point division by zero also results in undefined behavior, although most implementations do not treat it as a terminal error. If additional precautions are not taken, it results in a silent error.\nThe most portable way to determine if a floating-point exceptional condition has occurred is to use the floating-point exception facilities provided by C in fenv.h.\nHowever, the C floating-point exception functions are not without problems. The following caveats exist regarding the interaction between floating-point exceptions and conversions:\nConversion from floating-point to integer may cause an \"invalid\" floating-point exception. If this occurs, the value of that integer is undefined and should not be used.\nMost implementations fail to raise \"invalid\" for conversions from any negative or \"large\" positive floating-point values to unsigned integer types or to signed char. (See tflt2int.c.)\nWhen a noninteger floating-point value is converted to an integer, the \"inexact\" floating-point exception is raised.\nFor information regarding floating-point number conversions, see FLP34-C. Ensure that floating-point conversions are within range of the new type.\nThe C Standard does not require all implementations to support floating-point exceptions. Each exception macro in fenv.h is defined if, and only if, the corresponding exception is supported. Only implementations that use IEC 60559 (formerly IEEE-754) floating-point arithmetic are required to support all five exceptions defined by C (see the C Standard, subclause 7.6.2 [ISO/IEC 9899:2011]). Nevertheless, these functions are the most portable solution for handling floating-point exceptions.\nA less portable but potentially more secure solution is to use the capabilities provided by the underlying implementation. If this approach is taken, the caveats of that system must be well understood. The following table provides a starting point for some common operating systems:\nOperating System\nHow to Handle Floating-Point Errors\nLinux\nSolaris 10\nAIX 5.3\nHP-UX 11.31\nMac OS X 10.5\nUse the C floating-point exception functions\nWindows\nUse either the C floating-point exception functions or structured exception handling through _fpieee_flt [MSDN]\nNoncompliant Code Example\nIn this noncompliant code example, floating-point operations are performed without checking for errors. Note that range checking has been intentionally omitted because the intent is to detect errors following the floating-point operation.\nvoid fpOper_noErrorChecking(void) {\n  /* ... */\n  double a = 1e-40, b, c = 0.1;\n  float x = 0, y;\n  /* Inexact and underflows */\n  y = a;\n  /* Divide-by-zero operation */\n  b = y / x;\n  /* Inexact (loss of precision) */\n  c = sin(30) * a;\n  /* ... */\n}\nHowever, exceptional conditions (as indicated by the comments) occur that may lead to unexpected arithmetic results.\nCompliant Solution (C)\nThis compliant solution uses C Standard functions to handle floating-point errors:\n#include <fenv.h>\n#pragma STDC FENV_ACCESS ON\n\nvoid fpOper_fenv(void) {\n  double a = 1e-40, b, c = 0.1;\n  float x = 0, y;\n  int fpeRaised;\n  /* ... */\n\n  feclearexcept(FE_ALL_EXCEPT);\n  /* Store a into y is inexact and underflows: */\n  y = a;\n  fpeRaised = fetestexcept(FE_ALL_EXCEPT);\n  /* fpeRaised has FE_INEXACT and FE_UNDERFLOW */\n\n  feclearexcept(FE_ALL_EXCEPT);\n\n  /* Divide-by-zero operation */\n  b = y / x;\n  fpeRaised = fetestexcept(FE_ALL_EXCEPT);\n  /* fpeRaised has FE_DIVBYZERO */\n\n  feclearexcept(FE_ALL_EXCEPT);\n\n  c = sin(30) * a;\n  fpeRaised = fetestexcept(FE_ALL_EXCEPT);\n  /* fpeRaised has FE_INEXACT */\n\n  feclearexcept(FE_ALL_EXCEPT);\n  /* ... */\n}\nCompliant Solution (Windows)\nMicrosoft Visual Studio 2008 and earlier versions do not support C functions to handle floating-point errors. Windows provides an alternative method using _statusfp(), _statusfp2(), and _clearfp().\nvoid fpOper_usingStatus(void) {\n  /* ... */\n  double a = 1e-40, b, c;\n  float x = 0, y;\n  unsigned int rv = _clearfp();\n\n  /* Store into y is inexact and underflows: */\n  y = a;\n  rv = _clearfp();  /* rv has _SW_INEXACT and _SW_UNDERFLOW */\n\n  /* Zero-divide */\n  b = y / x; rv = _clearfp(); /* rv has _SW_ZERODIVIDE */\n\n  /* Inexact */\n  c = sin(30) * a; rv = _clearfp(); /* rv has _SW_INEXACT */\n  /* ... */\n}\nCompliant Solution (Windows SEH)\nMicrosoft Visual Studio 2008 also uses structured exception handling (SEH) to handle floating-point operations. SEH provides more information about the error and allows the programmer to change the results of the floating-point operation that caused the error condition.\nvoid fp_usingSEH(void) {\n  /* ... */\n  double a = 1e-40, b, c = 0.1;\n  float x = 0, y;\n  unsigned int rv ;\n\n  unmask_fpsr();\n\n  _try {\n    /* Store into y is inexact and underflows: */\n    y = a;\n\n    /* Divide-by-zero operation */\n    b = y / x;\n\n    /* Inexact */\n    c = sin(30) * a;\n  }\n\n  _except (_fpieee_flt(\n             GetExceptionCode(),\n             GetExceptionInformation(),\n             fpieee_handler)) {\n  {\n  printf (\"fpieee_handler: EXCEPTION_EXECUTE_HANDLER\");\n  }\n\n  /* ... */\n}\n\nvoid unmask_fpsr(void) {\n  unsigned int u;\n  unsigned int control_word;\n  _controlfp_s(&control_word, 0, 0);\n  u = control_word & ~(_EM_INVALID\n                     | _EM_DENORMAL\n                     | _EM_ZERODIVIDE\n                     | _EM_OVERFLOW\n                     | _EM_UNDERFLOW\n                     | _EM_INEXACT);\n  _controlfp_s( &control_word, u, _MCW_EM);\n  return ;\n}\n\nint fpieee_handler(_FPIEEE_RECORD *ieee) {\n  /* ... */\n\n  switch (ieee->RoundingMode) {\n    case _FpRoundNearest:\n      /* ... */\n      break;\n\n      /*\n       * Other RMs include _FpRoundMinusInfinity,\n       * _FpRoundPlusInfinity, _FpRoundChopped.\n       */\n\n      /* ... */\n    }\n\n  switch (ieee->Precision) {\n    case _FpPrecision24:\n      /* ... */\n      break;\n\n      /* Other Ps include _FpPrecision53 */\n      /* ... */\n    }\n\n   switch (ieee->Operation) {\n     case _FpCodeAdd:\n       /* ... */\n       break;\n\n       /* \n        * Other Ops include _FpCodeSubtract, _FpCodeMultiply,\n        * _FpCodeDivide, _FpCodeSquareRoot, _FpCodeCompare,\n        * _FpCodeConvert, _FpCodeConvertTrunc.\n        */\n       /* ... */\n    }\n\n  /* \n   * Process the bitmap ieee->Cause.\n   * Process the bitmap ieee->Enable.\n   * Process the bitmap ieee->Status.\n   * Process the Operand ieee->Operand1, \n   * evaluate format and Value.\n   * Process the Operand ieee->Operand2, \n   * evaluate format and Value.\n   * Process the Result ieee->Result, \n   * evaluate format and Value.\n   * The result should be set according to the operation \n   * specified in ieee->Cause and the result formatted as \n   * specified in ieee->Result.\n   */\n\n  /* ... */\n}\nRisk Assessment\nUndetected floating-point errors may result in lower program efficiency, inaccurate results, or software vulnerabilities. Most processors stall for a significant duration when an operation incurs a NaN (not a number) value.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nFLP03-C\nLow\nProbable\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nfloat-division-by-zero Partially checked\nCompass/ROSE\n\n\nCould detect violations of this rule by ensuring that floating-point operations are surrounded by feclearexcept() and fetestexcept(). It would need to look for type conversions to float or double, divisions (by a number not known to be nonzero), and multiplication. It may be wisest to apply this to all floating-point operations in general\nLDRA tool suite\n9.7.1\n43 D Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-FLP03-a\nCERT_C-FLP03-b\nCERT_C-FLP03-c\nCERT_C-FLP03-d\nAvoid division by zero\nAvoid implicit conversions from wider to narrower floating type\nAvoid implicit conversions from narrower to wider floating type\nAvoid implicit conversions of floating point numbers from wider to narrower floating type\nParasoft Insure++\n\nRuntime analysis\nPC-lint Plus\n1.4\n736, 9120, 9227\nAssistance provided\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. FLP03-C\n\nChecks for:\nFloat conversion overflow\nFloat overflow\nFloat division by zero\nRec. partially covered.\nSecurity Reviewer - Static Reviewer\n6.02\nC87\nFully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this recommendation on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID FLP03-CPP. Detect and handle floating point errors\nMITRE CWE CWE-369, Divide by zero\nBibliography\n[IEEE Std 1003.1:2013] XBD, Headers, <fenv.h>\n[Intel 2001]\n[ISO/IEC 9899:2011] Subclause 7.6.2, \"Floating-Point Exceptions\"\n[Keil 2008]\n[MSDN] \"fpieee_flt (CRT)\"\n[SecurityFocus 2007]",
        "language": "C"
    },
    {
        "rule_id": "MSC11-C",
        "rule_title": "Incorporate diagnostic tests using assertions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC11-C.+Incorporate+diagnostic+tests+using+assertions",
        "content": "Incorporate diagnostic tests into your program using, for example, the assert() macro.\nThe assert macro expands to a void expression:\n#include <assert.h>\nvoid assert(scalar expression);\nWhen it is executed, if expression (which must have a scalar type) is false, the assert macro outputs information about the failed assertion (including the text of the argument, the name of the source file, the source line number, and the name of the enclosing function) on the standard error stream, in an implementation-defined format, and calls the abort() function.\nIn the following example, the test for integer wrap was omitted for the unsigned multiplication on the assumption that MAX_TABLE_SIZE * sizeof(char *) cannot exceed SIZE_MAX. Although we know this is true, it cannot do any harm to codify this assumption.\nassert(size <= SIZE_MAX/sizeof(char *));\ntable_size = size * sizeof(char *);\nAssertions are primarily intended for use during debugging and are generally turned off before code is deployed by defining the NDEBUG macro (typically as a flag passed to the compiler). Consequently, assertions should be used to protect against incorrect programmer assumptions and not for runtime error checking.\nAssertions should never be used to verify the absence of runtime (as opposed to logic) errors, such as\nInvalid user input (including command-line arguments and environment variables)\nFile errors (for example, errors opening, reading or writing files)\nNetwork errors (including network protocol errors)\nOut-of-memory conditions (for example, malloc() or similar failures)\nSystem resource exhaustion (for example, out-of-file descriptors, processes, threads)\nSystem call errors (for example, errors executing files, locking or unlocking mutexes)\nInvalid permissions (for example, file, memory, user)\nCode that protects against a buffer overflow, for example, cannot be implemented as an assertion because this code must be presented in the deployed executable.\nIn particular, assertions are generally unsuitable for server programs or embedded systems in deployment. A failed assertion can lead to a denial-of-service attack if triggered by a malicious user, such as size being derived, in some way, from client input. In such situations, a soft failure mode, such as writing to a log file and rejecting the request, is more appropriate.\nif (size > SIZE_MAX / sizeof(char *)) {\n  fprintf(log_file, \"%s: size %zu exceeds %zu bytes\\n\",\n          __FILE__, size, SIZE_MAX / sizeof(char *));\n  size = SIZE_MAX / sizeof(char *);\n}\ntable_size = size * sizeof(char *);\nNoncompliant Code Example (malloc())\nThis noncompliant code example uses the assert() macro to verify that memory allocation succeeded. Because memory availability depends on the overall state of the system and can become exhausted at any point during a process lifetime, a robust program must be prepared to gracefully handle and recover from its exhaustion. Consequently, using the assert() macro to verify that a memory allocation succeeded would be inappropriate because doing so might lead to an abrupt termination of the process, opening the possibility of a denial-of-service attack. See also MEM11-C. Do not assume infinite heap space and void MEM32-C. Detect and handle memory allocation errors.\nchar *dupstring(const char *c_str) {\n  size_t len;\n  char *dup;\n   len = strlen(c_str);\n  dup = (char *)malloc(len + 1);\n  assert(NULL != dup);\n   memcpy(dup, c_str, len + 1);\n  return dup;\n}\nCompliant Solution (malloc())\nThis compliant solution demonstrates how to detect and handle possible memory exhaustion:\nchar *dupstring(const char *c_str) {\n  size_t len;\n  char *dup;\n   len = strlen(c_str);\n  dup = (char*)malloc(len + 1);\n  /* Detect and handle memory allocation error */\n  if (NULL == dup) {\n      return NULL;\n  }\n   memcpy(dup, c_str, len + 1);\n  return dup;\n}\nRisk Assessment\nAssertions are a valuable diagnostic tool for finding and eliminating software defects that may result in vulnerabilities. The absence of assertions, however, does not mean that code is incorrect.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC11-C\nLow\nUnlikely\nNo\nNo\nP1\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nLANG.FUNCS.ASSERTS Not enough assertions\nCoverity\n2017.07\nASSERT_SIDE_EFFECT\nCan detect the specific instance where assertion contains an operation/function call that may have a side effect\nParasoft C/C++test\n2024.2\nCERT_C-MSC11-a\nAssert liberally to document internal assumptions and invariants\nSecurity Reviewer - Static Reviewer\n6.02\nCPPPBE Fully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nCERT C Secure Coding Standard ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy\nSEI CERT C++ Coding Standard VOID MSC11-CPP. Incorporate diagnostic tests using assertions\nMITRE CWE CWE-190, Reachable assertion",
        "language": "C"
    },
    {
        "rule_id": "CON30-C",
        "rule_title": "Clean up thread-specific storage",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON30-C.+Clean+up+thread-specific+storage",
        "content": "The tss_create() function creates a thread-specific storage pointer identified by a key. Threads can allocate thread-specific storage and associate the storage with a key that uniquely identifies the storage by calling the tss_set() function. If not properly freed, this memory may be leaked. Ensure that thread-specific storage is freed.\nNoncompliant Code Example\nIn this noncompliant code example, each thread dynamically allocates storage in the get_data() function, which is then associated with the global key by the call to tss_set() in the add_data() function. This memory is subsequently leaked when the threads terminate.\n#include <threads.h>\n#include <stdlib.h>\n /* Global key to the thread-specific storage */\ntss_t key;\nenum { MAX_THREADS = 3 };\n int *get_data(void) {\n  int *arr = (int *)malloc(2 * sizeof(int));\n  if (arr == NULL) {\n    return arr;  /* Report error  */\n  }\n  arr[0] = 10;\n  arr[1] = 42;\n  return arr;\n}\n int add_data(void) {\n  int *data = get_data();\n  if (data == NULL) {\n    return -1;  /* Report error */\n  }\n   if (thrd_success != tss_set(key, (void *)data)) {\n    /* Handle error */\n  }\n  return 0;\n}\n void print_data(void) {\n  /* Get this thread's global data from key */\n  int *data = tss_get(key);\n   if (data != NULL) {\n    /* Print data */\n  }\n}\n int function(void *dummy) {\n  if (add_data() != 0) {\n    return -1;  /* Report error */\n  }\n  print_data();\n  return 0;\n}\n int main(void) {\n  thrd_t thread_id[MAX_THREADS];\n   /* Create the key before creating the threads */\n  if (thrd_success != tss_create(&key, NULL)) {\n    /* Handle error */\n  }\n   /* Create threads that would store specific storage */\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {\n      /* Handle error */\n    }\n  }\n   for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_join(thread_id[i], NULL)) {\n      /* Handle error */\n    }\n  }\n   tss_delete(key);\n  return 0;\n}\nCompliant Solution\nIn this compliant solution, each thread explicitly frees the thread-specific storage returned by the tss_get() function before terminating:\n#include <threads.h>\n#include <stdlib.h>\n  /* Global key to the thread-specific storage */\ntss_t key;\n  int function(void *dummy) {\n  if (add_data() != 0) {\n    return -1;  /* Report error */\n  }\n  print_data();\n  free(tss_get(key));\n  return 0;\n}\n /* ... Other functions are unchanged */\nCompliant Solution\nThis compliant solution invokes a destructor function registered during the call to tss_create() to automatically free any thread-specific storage:\n#include <threads.h>\n#include <stdlib.h>\n /* Global key to the thread-specific storage */\ntss_t key;\nenum { MAX_THREADS = 3 };\n /* ... Other functions are unchanged */\n void destructor(void *data) {\n  free(data);\n}\n  int main(void) {\n  thrd_t thread_id[MAX_THREADS];\n   /* Create the key before creating the threads */\n  if (thrd_success != tss_create(&key, destructor)) {\n    /* Handle error */\n  }\n   /* Create threads that would store specific storage */\n  for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_create(&thread_id[i], function, NULL)) {\n      /* Handle error */\n    }\n  }\n   for (size_t i = 0; i < MAX_THREADS; i++) {\n    if (thrd_success != thrd_join(thread_id[i], NULL)) {\n      /* Handle error */\n    }\n  }\n   tss_delete(key);\n  return 0;\n}\n\nRisk Assessment\nFailing to free thread-specific objects results in memory leaks and could result in a denial-of-service attack.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON30-C\nMedium\nUnlikely\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nCodeSonar\n9.1p0\nALLOC.LEAK\nLeak\nCoverity\n2017.07\nALLOC_FREE_MISMATCH Partially implemented, correct implementation is more involved\nCppcheck Premium\n24.11.0\npremium-cert-con30-c\nHelix QAC\n2025.2\nC1780, C1781, C1782, C1783, C1784\n\nParasoft C/C++test\n2024.2\nCERT_C-CON30-a\nEnsure resources are freed\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON30-C Checks for thread-specific memory leak (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.",
        "language": "C"
    },
    {
        "rule_id": "CON31-C",
        "rule_title": "Do not destroy a mutex while it is locked",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON31-C.+Do+not+destroy+a+mutex+while+it+is+locked",
        "content": "Mutexes are used to protect shared data structures being concurrently accessed. If a mutex is destroyed while a thread is blocked waiting for that mutex, critical sections and shared data are no longer protected.\nThe C Standard, 7.28.4.1, paragraph 2 [ISO/IEC 9899:2024], states\nThe mtx_destroy function releases any resources used by the mutex pointed to by mtx. No threads can be blocked waiting for the mutex pointed to by mtx.\nThis statement implies that destroying a mutex while a thread is waiting on it is undefined behavior.\nNoncompliant Code Example\nThis noncompliant code example creates several threads that each invoke the do_work() function, passing a unique number as an ID. The do_work() function initializes the lock mutex if the argument is 0 and destroys the mutex if the argument is max_threads - 1. In all other cases, the do_work() function provides normal processing. Each thread, except the final cleanup thread, increments the atomic completed variable when it is finished.\nUnfortunately, this code contains several race conditions, allowing the mutex to be destroyed before it is unlocked. Additionally, there is no guarantee that lock will be initialized before it is passed to mtx_lock(). Each of these behaviors is undefined.\n#include <stdatomic.h>\n#include <stddef.h>\n#include <threads.h>\n  mtx_t lock;\n/* Atomic so multiple threads can modify safely */\natomic_int completed = ATOMIC_VAR_INIT(0);\nenum { max_threads = 5 };\n int do_work(void *arg) {\n  int *i = (int *)arg;\n   if (*i == 0) { /* Creation thread */\n    if (thrd_success != mtx_init(&lock, mtx_plain)) {\n      /* Handle error */\n    }\n    atomic_store(&completed, 1);\n  } else if (*i < max_threads - 1) { /* Worker thread */\n    if (thrd_success != mtx_lock(&lock)) {\n      /* Handle error */\n    }\n    /* Access data protected by the lock */\n    atomic_fetch_add(&completed, 1);\n    if (thrd_success != mtx_unlock(&lock)) {\n      /* Handle error */\n    }\n  } else { /* Destruction thread */\n    mtx_destroy(&lock);\n  }\n  return 0;\n}\n  int main(void) {\n  thrd_t threads[max_threads];\n     for (size_t i = 0; i < max_threads; i++) {\n    if (thrd_success != thrd_create(&threads[i], do_work, &i)) {\n      /* Handle error */\n    }\n  }\n  for (size_t i = 0; i < max_threads; i++) {\n    if (thrd_success != thrd_join(threads[i], 0)) {\n      /* Handle error */\n    }\n  }\n  return 0;\n}\nCompliant Solution\nThis compliant solution eliminates the race conditions by initializing the mutex in main() before creating the threads and by destroying the mutex in main() after joining the threads:\n#include <stdatomic.h>\n#include <stddef.h>\n#include <threads.h>\n  mtx_t lock;\n/* Atomic so multiple threads can increment safely */\natomic_int completed = ATOMIC_VAR_INIT(0);\nenum { max_threads = 5 };\n int do_work(void *dummy) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n  /* Access data protected by the lock */\n  atomic_fetch_add(&completed, 1);\n  if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n   return 0;\n}\n int main(void) {\n  thrd_t threads[max_threads];\n     if (thrd_success != mtx_init(&lock, mtx_plain)) {\n    /* Handle error */\n  }\n  for (size_t i = 0; i < max_threads; i++) {\n    if (thrd_success != thrd_create(&threads[i], do_work, NULL)) {\n      /* Handle error */\n    }\n  }\n  for (size_t i = 0; i < max_threads; i++) {\n    if (thrd_success != thrd_join(threads[i], 0)) {\n      /* Handle error */\n    }\n  }\n   mtx_destroy(&lock);\n  return 0;\n}\nRisk Assessment\nDestroying a mutex while it is locked may result in invalid control flow and data corruption.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON31-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nCodeSonar\n9.1p0\nCONCURRENCY.LOCALARG\nLocal Variable Passed to Thread\nCppcheck Premium\n24.11.0\npremium-cert-con31-c\nHelix QAC\n2025.2\nDF4961, DF4962\nParasoft C/C++test\n2024.2\nCERT_C-CON31-a\nCERT_C-CON31-b\nCERT_C-CON31-c\nDo not destroy another thread's mutex\nDo not use resources that have been freed\nDo not free resources using invalid pointers\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON31-C Checks for destruction of locked mutex (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCWE 2.11 CWE-667, Improper Locking 2017-07-10: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-667 and CON31-C/POS48-C\nIntersection( CON31-C, POS48-C) = \u00d8\nCWE-667 = Union, CON31-C, POS48-C, list) where list =\n\nLocking & Unlocking issues besides unlocking another thread\u2019s C mutex or pthread mutex.\n\nBibliography\n[ISO/IEC 9899:2024] 7.28.4.1, \"The mtx_destroy Function\"",
        "language": "C"
    },
    {
        "rule_id": "CON32-C",
        "rule_title": "Prevent data races when accessing bit-fields from multiple threads",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON32-C.+Prevent+data+races+when+accessing+bit-fields+from+multiple+threads",
        "content": "When accessing a bit-field, a thread may inadvertently access a separate bit-field in adjacent memory. This is because compilers are required to store multiple adjacent bit-fields in one storage unit whenever they fit. Consequently, data races may exist not just on a bit-field accessed by multiple threads but also on other bit-fields sharing the same byte or word.  A similar problem is discussed in CON43-C. Do not allow data races in multithreaded code, but the issue described by this rule can be harder to diagnose because it may not be obvious that the same memory location is being modified by multiple threads.\nOne approach for preventing data races in concurrent programming is to use a mutex. When properly observed by all threads, a mutex can provide safe and secure access to a shared object. However, mutexes provide no guarantees with regard to other objects that might be accessed when the mutex is not controlled by the accessing thread. Unfortunately, there is no portable way to determine which adjacent bit-fields may be stored along with the desired bit-field.\nAnother approach is to insert a non-bit-field member between any two bit-fields to ensure that each bit-field is the only one accessed within its storage unit. This technique effectively guarantees that no two bit-fields are accessed simultaneously.\nNoncompliant Code Example (Bit-field)\nAdjacent bit-fields may be stored in a single memory location. Consequently, modifying adjacent bit-fields in different threads is undefined behavior 5, as shown in this noncompliant code example:\nstruct multi_threaded_flags {\n  unsigned int flag1 : 2;\n  unsigned int flag2 : 2;\n};\n struct multi_threaded_flags flags;\n int thread1(void *arg) {\n  flags.flag1 = 1;\n  return 0;\n}\n int thread2(void *arg) {\n  flags.flag2 = 2;\n  return 0;\n}\nThe C Standard, 3.17, paragraph 3 [ISO/IEC 9899:2024], states\nNote 2 to entry: A bit-field and an adjacent non-bit-field member are in separate memory locations. The same applies to two bit-fields, if one is declared inside a nested structure declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field member declaration. It is not safe to concurrently update two non-atomic bit-fields in the same structure if all members declared between them are also (nonzero-length) bit-fields, no matter what the sizes of those intervening bit-fields happen to be.\nFor example, the following instruction sequence is possible:\nThread 1: register 0 = flags\nThread 1: register 0 &= ~mask(flag1)\nThread 2: register 0 = flags\nThread 2: register 0 &= ~mask(flag2)\nThread 1: register 0 |= 1 << shift(flag1)\nThread 1: flags = register 0\nThread 2: register 0 |= 2 << shift(flag2)\nThread 2: flags = register 0\nCompliant Solution (Bit-field, C11, Mutex)\nThis compliant solution protects all accesses of the flags with a mutex, thereby preventing any data races:\n#include <threads.h>\n  struct multi_threaded_flags {\n  unsigned int flag1 : 2;\n  unsigned int flag2 : 2;\n};\n struct mtf_mutex {\n  struct multi_threaded_flags s;\n  mtx_t mutex;\n};\n struct mtf_mutex flags;\n int thread1(void *arg) {\n  if (thrd_success != mtx_lock(&flags.mutex)) {\n    /* Handle error */\n  }\n  flags.s.flag1 = 1;\n  if (thrd_success != mtx_unlock(&flags.mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\n  int thread2(void *arg) {\n  if (thrd_success != mtx_lock(&flags.mutex)) {\n    /* Handle error */\n  }\n  flags.s.flag2 = 2;\n  if (thrd_success != mtx_unlock(&flags.mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\nCompliant Solution (C11)\nIn this compliant solution, two threads simultaneously modify two distinct non-bit-field members of a structure. Because the members occupy different bytes in memory, no concurrency protection is required.\nstruct multi_threaded_flags {\n  unsigned char flag1;\n  unsigned char flag2;\n};\n  struct multi_threaded_flags flags;\n  int thread1(void *arg) {\n  flags.flag1 = 1;\n  return 0;\n}\n int thread2(void *arg) {\n  flags.flag2 = 2;\n  return 0;\n}\nUnlike C99, C11 and C23 explicitly define a memory location and provides the following note in subclause 3.17 paragraph 2 [ISO/IEC 9899:2024]:\nNote 1 to entry: Two threads of execution can update and access separate memory locations without interfering with each other.\nIt is almost certain that flag1 and flag2 are stored in the same word. Using a compiler that conforms to C99 or earlier, if both assignments occur on a thread-scheduling interleaving that ends with both stores occurring after one another, it is possible that only one of the flags will be set as intended. The other flag will contain its previous value because both members are represented by the same word, which is the smallest unit the processor can work on. Before the changes were made to the C Standard for C11, there were no guarantees that these flags could be modified concurrently.\nRisk Assessment\nAlthough the race window is narrow, an assignment or an expression can evaluate improperly because of misinterpreted data resulting in a corrupted running state or unintended information disclosure.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON32-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nread_data_race\nwrite_data_race\nSupported by sound analysis (data race alarm)\nAxivion Bauhaus Suite\n7.2.0\nCertC-CON32\nCodeSonar\n9.1p0\nCONCURRENCY.DATARACE\nCONCURRENCY.MAA\nData race\nMultiple Accesses of Atomic\nCoverity\n2017.07\nMISSING_LOCK\nPartially implemented\nCppcheck Premium\n24.11.0\npremium-cert-con32-c\nHelix QAC\n2025.2\nC1774, C1775\nParasoft C/C++test\n2024.2\nCERT_C-CON32-a\nUse locks to prevent race conditions when modifying bit fields\nPC-lint Plus\n1.4\n457\nPartially supported: access is detected at the object level (not at the field level)\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON32-C\nChecks for data race (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2024] 3.17, \"Memory Location\"",
        "language": "C"
    },
    {
        "rule_id": "CON33-C",
        "rule_title": "Avoid race conditions when using library functions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON33-C.+Avoid+race+conditions+when+using+library+functions",
        "content": "Some C standard library functions are not guaranteed to be reentrant with respect to threads. Functions such as strtok() and asctime() return a pointer to the result stored in function-allocated memory on a per-process basis. Other functions such as rand() store state information in function-allocated memory on a per-process basis. Multiple threads invoking the same function can cause concurrency problems, which often result in abnormal behavior and can cause more serious vulnerabilities, such as abnormal termination, denial-of-service attack, and data integrity violations.\nAccording to the C Standard, the library functions listed in the following table may contain data races when invoked by multiple threads.\nFunctions\nRemediation\nrand(), srand() MSC30-C. Do not use the rand() function for generating pseudorandom numbers\ngetenv() ENV34-C. Do not store pointers returned by certain functions\nstrtok() strtok_r() in POSIX\nstrerror() strerror_r() in POSIX\nasctime(), ctime(),\nlocaltime(), gmtime() strftime()\nsetlocale() Protect multithreaded access to locale-specific functions with a mutex\nATOMIC_VAR_INIT, atomic_init() Do not attempt to initialize an atomic variable from multiple threads\ntmpnam() tmpnam_r() in POSIX\nmbrtoc16(), c16rtomb(),\nmbrtoc32(), c32rtomb() Do not call with a null mbstate_t * argument \nSection 2.9.1 of the Portable Operating System Interface (POSIX\u00ae), Base Specifications, Issue 7 [IEEE Std 1003.1:2013] extends the list of functions that are not required to be thread-safe.\nNoncompliant Code Example\nIn this noncompliant code example, the function f() is called from within a multithreaded application but encounters an error while calling a system function. The strerror() function returns a human-readable error string given an error number.\nThe C Standard, 7.26.6.3 paragraph 3 [ISO/IEC 9899:2024], specifically states that strerror() is not required to avoid data races.\nThe strerror function is not required to avoid data races with other calls to the strerror function.\nAn implementation could write the error string into a static array and return a pointer to it, and that array might be accessible and modifiable by other threads.\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n  void f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n   if (0 != fgetpos(fp, &pos)) {\n    char *errmsg = strerror(errno);\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}\nThis code first sets errno to 0 to comply with ERR30-C. Take care when reading errno. \nCompliant Solution (POSIX, strerror_r())\nThis compliant solution uses the POSIX strerror_r() function, which has the same functionality as strerror() but guarantees thread safety:\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n enum { BUFFERSIZE = 64 };\n  void f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n   if (0 != fgetpos(fp, &pos)) {\n    char errmsg[BUFFERSIZE];\n    if (strerror_r(errno, errmsg, BUFFERSIZE) != 0) {\n      /* Handle error */\n    }\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}\nLinux provides two versions of strerror_r(), known as the XSI-compliant version and the GNU-specific version. This compliant solution assumes the XSI-compliant version, which is the default when an application is compiled as required by POSIX (that is, by defining _POSIX_C_SOURCE or _XOPEN_SOURCE appropriately). The strerror_r() manual page lists versions that are available on a particular system.\nRisk Assessment\nRace conditions caused by multiple threads invoking the same library function can lead to abnormal termination of the application, data integrity violations, or a denial-of-service attack.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON33-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nCodeSonar\n9.1p0\nBADFUNC.RANDOM.RAND\nBADFUNC.TEMP.TMPNAM\nBADFUNC.TTYNAME\nUse of rand (includes check for uses of srand())\nUse of tmpnam (includes check for uses of tmpnam_r())\nUse of ttyname\nCompass/ROSE\n\n\nA module written in Compass/ROSE can detect violations of this rule\nCppcheck Premium\n24.11.0\npremium-cert-con33-c\nHelix QAC\n2025.2\nC5037\nC++5021\nDF4976, DF4977\n\nKlocwork\n2025.2\nCERT.CONC.LIB_FUNC_USE\n\nLDRA tool suite\n 9.7.1\n44 S Partially Implemented\nParasoft C/C++test\n2024.2\nCERT_C-CON33-a\nAvoid using thread-unsafe functions\nPC-lint Plus\n1.4\n586\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON33-C Checks for data race through standard library function call (rule fully covered)\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard ERR30-C. Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C CON00-CPP. Avoid assuming functions are thread safe unless otherwise specified Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-330 2017-06-28: CERT: Partial overlap\nCWE 2.11 CWE-377 2017-06-28: CERT: Partial overlap\nCWE 2.11 CWE-676 2017-05-18: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-330 and CON33-C\nIndependent( MSC30-C, MSC32-C, CON33-C)\nIntersection( CWE-330, CON33-C) =\n\nUse of rand() or srand() from multiple threads, introducing a race condition.\n\nCWE-330 \u2013 CON33-C =\n\nUse of rand() or srand() without introducing race conditions\n\n\nUse of other dangerous functions\n\nCON33-C \u2013 CWE-330 =\n\nUse of other global functions (besides rand() and srand()) introducing race conditions\n\nCWE-377 and CON33-C\nIntersection( CWE-377, CON33-C) =\n\nUse of tmpnam() from multiple threads, introducing a race condition.\n\nCWE-377 \u2013 CON33-C =\n\nInsecure usage of tmpnam() without introducing race conditions\n\n\nInsecure usage of other functions for creating temporary files (see CERT recommendation FIO21-C for details)\n\nCON33-C \u2013 CWE-377 =\n\nUse of other global functions (besides tmpnam()) introducing race conditions\n\nCWE-676 and CON33-C\n\nIndependent( ENV33-C, CON33-C, STR31-C, EXP33-C, MSC30-C, ERR34-C)\n\n\nCON33-C lists standard C library functions that manipulate global data (e.g., locale()), that can be dangerous to use in a multithreaded context.\n\n\nCWE-676 = Union( CON33-C, list) where list =\n\n\nInvocation of the following functions without introducing a race condition:\n\n\nrand(), srand(, getenv(), getenv_s(), strtok(), strerror(), asctime(), ctime(), localtime(), gmtime(), setlocale(), ATOMIC_VAR_INIT, atomic_init(), tmpnam(), mbrtoc16(), c16rtomb(), mbrtoc32(), c32rtomb()\n\n\nInvocation of other dangerous functions\n\n\n\nBibliography\n[IEEE Std 1003.1:2013] Section 2.9.1, \"Thread Safety\"\n[ISO/IEC 9899:2024]\nSubclause 7.26.6.3, \"The strerror Function\" \n[Open Group 1997b] Section 10.12, \"Thread-Safe POSIX.1 and C-Language Functions\"",
        "language": "C"
    },
    {
        "rule_id": "CON34-C",
        "rule_title": "Declare objects shared between threads with appropriate storage durations",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON34-C.+Declare+objects+shared+between+threads+with+appropriate+storage+durations",
        "content": "Accessing the automatic or thread-local variables of one thread from another thread is implementation-defined behavior and can cause invalid memory accesses because the execution of threads can be interwoven within the constraints of the synchronization model. As a result, the referenced stack frame or thread-local variable may no longer be valid when another thread tries to access it. Shared static variables can be protected by thread synchronization mechanisms.\nHowever, automatic (local) variables cannot be shared in the same manner because the referenced stack frame's thread would need to stop executing, or some other mechanism must be employed to ensure that the referenced stack frame is still valid. Do not access automatic or thread-local objects from a thread other than the one with which the object is associated. See DCL30-C. Declare objects with appropriate storage durations for information on how to declare objects with appropriate storage durations when data is not being shared between threads.\n\nNoncompliant Code Example (Automatic Storage Duration)\nThis noncompliant code example passes the address of a variable to a child thread, which prints it out. The variable has automatic storage duration. Depending on the execution order, the child thread might reference the variable after the variable's lifetime in the parent thread. This would cause the child thread to access an invalid memory location.\n#include <threads.h>\n#include <stdio.h>\n int child_thread(void *val) {\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return 0;\n}\n void create_thread(thrd_t *tid) {\n  int val = 1;\n  if (thrd_success != thrd_create(tid, child_thread, &val)) {\n    /* Handle error */\n  }\n}\n int main(void) {\n  thrd_t tid;\n  create_thread(&tid);\n     if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}\nNoncompliant Code Example (Automatic Storage Duration)\nOne practice is to ensure that all objects with automatic storage duration shared between threads are declared such that their lifetime extends past the lifetime of the threads. This can be accomplished using a thread synchronization mechanism, such as thrd_join(). In this code example, val is declared in main(), where thrd_join() is called. Because the parent thread waits until the child thread completes before continuing its execution, the shared objects have a lifetime at least as great as the thread. \n#include <threads.h>\n#include <stdio.h>\n int child_thread(void *val) {\n  int *result = (int *)val;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return 0;\n}\n  void create_thread(thrd_t *tid, int *val) {\n  if (thrd_success != thrd_create(tid, child_thread, val)) {\n    /* Handle error */\n  }\n}\n  int main(void) {\n  int val = 1;\n  thrd_t tid;\n  create_thread(&tid, &val);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}\n However, the C Standard, 6.2.4 paragraphs 4 and 5 [ISO/IEC 9899:2024], states:\nThe result of attempting to indirectly access an object with thread storage duration from a thread other than the one with which the object is associated is implementation-defined. . . .\nThe result of attempting to indirectly access an object with automatic storage duration from a thread other than the one with which the object is associated is implementation-defined.\nTherefore this example relies on implementation-defined behavior and is nonportable.\nCompliant Solution (Static Storage Duration)\nThis compliant solution stores the value in an object having static storage duration. The lifetime of this object is the entire execution of the program; consequently, it can be safely accessed by any thread.\n#include <threads.h>\n#include <stdio.h>\n int child_thread(void *v) {\n  int *result = (int *)v;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return 0;\n}\n  void create_thread(thrd_t *tid) {\n  static int val = 1;\n  if (thrd_success != thrd_create(tid, child_thread, &val)) {\n    /* Handle error */\n  }\n}\n  int main(void) {\n  thrd_t tid;\n  create_thread(&tid);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}\nCompliant Solution (Allocated Storage Duration)\nThis compliant solution stores the value passed to the child thread in a dynamically allocated object. Because this object will persist until explicitly freed, the child thread can safely access its value.\n#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n int child_thread(void *val) {\n  int *result = (int *)val;\n  printf(\"Result: %d\\n\", *result); /* Correctly prints 1 */\n  return 0;\n}\n  void create_thread(thrd_t *tid, int *value) {\n  *value = 1;\n  if (thrd_success != thrd_create(tid, child_thread,\n                                  value)) {\n    /* Handle error */\n  }\n}\n  int main(void) {\n  thrd_t tid;\n  int *value = (int *)malloc(sizeof(int));\n  if (!value) {\n    /* Handle error */\n  }\n  create_thread(&tid, value);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  free(value);\n  return 0;\n}\nNoncompliant Code Example (Thread-Specific Storage)\nIn this noncompliant code example, the value is stored in thread-specific storage of the parent thread. However, because thread-specific data is available only to the thread that stores it, the child_thread() function will set result to a null value.\n#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n  static tss_t key;\n  int child_thread(void *v) {\n  void *result = tss_get(*(tss_t *)v);\n  printf(\"Result: %d\\n\", *(int *)result);\n  return 0;\n}\n  int create_thread(void *thrd) {\n  int *val = (int *)malloc(sizeof(int));\n  if (val == NULL) {\n    /* Handle error */\n  }\n  *val = 1;\n  if (thrd_success != tss_set(key, val)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create((thrd_t *)thrd,\n                                  child_thread, &key)) {\n    /* Handle error */\n  }\n  return 0;\n}\n int main(void) {\n  thrd_t parent_tid, child_tid;\n   if (thrd_success != tss_create(&key, free)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&parent_tid, create_thread,\n                                  &child_tid)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(parent_tid, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(child_tid, NULL)) {\n    /* Handle error */\n  }\n  tss_delete(key);\n  return 0;\n} \nCompliant Solution (Thread-Specific Storage)\nThis compliant solution illustrates how thread-specific storage can be combined with a call to a thread synchronization mechanism, such as thrd_join(). Because the parent thread waits until the child thread completes before continuing its execution, the child thread is guaranteed to access a valid live object.\n#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n static tss_t key;\n int child_thread(void *v) {\n  int *result = v;\n  printf(\"Result: %d\\n\", *result); /* Correctly prints 1 */\n  return 0;\n}\n int create_thread(void *thrd) {\n  int *val = (int *)malloc(sizeof(int));\n  if (val == NULL) {\n    /* Handle error */\n  }\n  *val = 1;\n  if (thrd_success != tss_set(key, val)) {\n    /* Handle error */\n  }\n  /* ... */\n  void *v = tss_get(key);\n  if (thrd_success != thrd_create((thrd_t *)thrd,\n                                   child_thread, v)) {\n    /* Handle error */\n  }\n  return 0;\n}\n int main(void) {\n  thrd_t parent_tid, child_tid;\n   if (thrd_success != tss_create(&key, free)) {\n  /* Handle error */\n  }\n  if (thrd_success != thrd_create(&parent_tid, create_thread,\n                                  &child_tid)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(parent_tid, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(child_tid, NULL)) {\n    /* Handle error */\n  }\n  tss_delete(key);\nreturn 0;\n} \nCompliant Solution (Thread-Local Storage, Windows, Visual Studio)\nSimilar to the preceding compliant solution, this compliant solution uses thread-local storage combined with thread synchronization to ensure the child thread is accessing a valid live object. It uses the Visual Studio\u2013specific __declspec(thread) language extension to provide the thread-local storage and the WaitForSingleObject() API to provide the synchronization.\n#include <Windows.h>\n#include <stdio.h>\n DWORD WINAPI child_thread(LPVOID v) {\n  int *result = (int *)v;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return NULL;\n}\n int create_thread(HANDLE *tid) {\n  /* Declare val as a thread-local value */\n  __declspec(thread) int val = 1;\n  *tid = create_thread(NULL, 0, child_thread, &val, 0, NULL);\n  return *tid == NULL;\n}\n int main(void) {\n  HANDLE tid;\n    if (create_thread(&tid)) {\n    /* Handle error */\n  }\n    if (WAIT_OBJECT_0 != WaitForSingleObject(tid, INFINITE)) {\n    /* Handle error */\n  }\n  CloseHandle(tid);\n    return 0;\n}\nNoncompliant Code Example (OpenMP, parallel)\nIt is important to note that local data can be used securely with threads when using other thread interfaces, so the programmer need not always copy data into nonlocal memory when sharing data with threads. For example, the shared keyword in The OpenMP\u00ae API Specification for Parallel Programming [OpenMP] can be used in combination with OpenMP's threading interface to share local memory without having to worry about whether local automatic variables remain valid.\nIn this noncompliant code example, a variable j is declared outside a parallel #pragma and not listed as a private variable. In OpenMP, variables outside a parallel #pragma are shared unless designated as private.\n#include <omp.h>\n#include <stdio.h>\n  int main(void) {\n  int j = 0;\n  #pragma omp parallel\n  {\n    int t = omp_get_thread_num();\n    printf(\"Running thread - %d\\n\", t);\n    for (int i = 0; i < 5050; i++) {\n    j++; /* j not private; could be a race condition */\n    }\n    printf(\"Just ran thread - %d\\n\", t);\n    printf(\"loop count %d\\n\", j);\n  }\nreturn 0;\n}\nCompliant Solution (OpenMP, parallel, private)\nIn this compliant solution, the variable j is declared outside of the parallel #pragma but is explicitly labeled as private:\n#include <omp.h>\n#include <stdio.h>\n int main(void) {\n  int j = 0;\n  #pragma omp parallel private(j)\n  {\n    int t = omp_get_thread_num();\n    printf(\"Running thread - %d\\n\", t);\n    for (int i = 0; i < 5050; i++) {\n    j++;\n    }\n    printf(\"Just ran thread - %d\\n\", t);\n    printf(\"loop count %d\\n\", j);\n  }\nreturn 0;\n}\nRisk Assessment\nThreads that reference the stack of other threads can potentially overwrite important information on the stack, such as function pointers and return addresses. The compiler may not generate warnings if the programmer allows one thread to access another thread's local variables, so a programmer may not catch a potential error at compile time. The remediation cost for this error is high because analysis tools have difficulty diagnosing problems with concurrency and race conditions. \nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON34-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, resulting undefined behavior is reported by the runtime error analysis\nCodeSonar\n9.1p0\nCONCURRENCY.LOCALARG\nCONCURRENCY.C_THREAD.ISD\nLocal Variable Passed to Thread\nInappropriate Storage Duration\nCppcheck Premium\n24.11.0\npremium-cert-con34-c\nHelix QAC\n2025.2\nDF4926, DF4927, DF4928\nParasoft C/C++test\n2024.2\nCERT_C-CON34-a\nDeclare objects shared between POSIX threads with appropriate storage durations\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON34-C Checks for automatic or thread local variable escaping from a C11 thread (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard DCL30-C. Declare objects with appropriate storage durations Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 6.2.4, \"Storage Durations of Objects\"\n[OpenMP] The OpenMP\u00ae API Specification for Parallel Programming",
        "language": "C"
    },
    {
        "rule_id": "CON35-C",
        "rule_title": "Avoid deadlock by locking in a predefined order",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON35-C.+Avoid+deadlock+by+locking+in+a+predefined+order",
        "content": "Mutexes are used to prevent multiple threads from causing a data race by accessing shared resources at the same time. Sometimes, when locking mutexes, multiple threads hold each other's lock, and the program consequently deadlocks. Four conditions are required for deadlock to occur:\nMutual exclusion\nHold and wait\nNo preemption\nCircular wait\nDeadlock needs all four conditions, so preventing deadlock requires preventing any one of the four conditions. One simple solution is to lock the mutexes in a predefined order, which prevents circular wait.\nNoncompliant Code Example\nThe behavior of this noncompliant code example depends on the runtime environment and the platform's scheduler. The program is susceptible to deadlock if thread thr1 attempts to lock ba2's mutex at the same time thread thr2 attempts to lock ba1's mutex in the deposit() function.\n#include <stdlib.h>\n#include <threads.h>\n  typedef struct {\n  int balance;\n  mtx_t balance_mutex;\n} bank_account;\n typedef struct {\n  bank_account *from;\n  bank_account *to;\n  int amount;\n} transaction;\n void create_bank_account(bank_account **ba,\n                         int initial_amount) {\n  bank_account *nba = (bank_account *)malloc(\n    sizeof(bank_account)\n  );\n  if (nba == NULL) {\n    /* Handle error */\n  }\n   nba->balance = initial_amount;\n  if (thrd_success\n      != mtx_init(&nba->balance_mutex, mtx_plain)) {\n    /* Handle error */\n  }\n   *ba = nba;\n}\n int deposit(void *ptr) {\n  transaction *args = (transaction *)ptr;\n   if (thrd_success != mtx_lock(&args->from->balance_mutex)) {\n    /* Handle error */\n  }\n   /* Not enough balance to transfer */\n  if (args->from->balance < args->amount) {\n    if (thrd_success\n        != mtx_unlock(&args->from->balance_mutex)) {\n      /* Handle error */\n    }\n    return -1; /* Indicate error */\n  }\n  if (thrd_success != mtx_lock(&args->to->balance_mutex)) {\n    /* Handle error */\n  }\n   args->from->balance -= args->amount;\n  args->to->balance += args->amount;\n   if (thrd_success\n      != mtx_unlock(&args->from->balance_mutex)) {\n    /* Handle error */\n  }\n   if (thrd_success\n      != mtx_unlock(&args->to->balance_mutex)) {\n    /* Handle error */\n  }\n   free(ptr);\n  return 0;\n}\n int main(void) {\n  thrd_t thr1, thr2;\n  transaction *arg1;\n  transaction *arg2;\n  bank_account *ba1;\n  bank_account *ba2;\n   create_bank_account(&ba1, 1000);\n  create_bank_account(&ba2, 1000);\n   arg1 = (transaction *)malloc(sizeof(transaction));\n  if (arg1 == NULL) {\n    /* Handle error */\n  }\n  arg2 = (transaction *)malloc(sizeof(transaction));\n  if (arg2 == NULL) {\n    /* Handle error */\n  }\n  arg1->from = ba1;\n  arg1->to = ba2;\n  arg1->amount = 100;\n   arg2->from = ba2;\n  arg2->to = ba1;\n  arg2->amount = 100;\n   /* Perform the deposits */\n  if (thrd_success\n     != thrd_create(&thr1, deposit, (void *)arg1)) {\n    /* Handle error */\n  }\n  if (thrd_success\n      != thrd_create(&thr2, deposit, (void *)arg2)) {\n    /* Handle error */\n  }\n  return 0;\n} \nCompliant Solution\nThis compliant solution eliminates the circular wait condition by establishing a predefined order for locking in the deposit() function. Each thread will lock on the basis of the bank_account ID, which is set when the bank_account struct is initialized.\n#include <stdlib.h>\n#include <threads.h>\n  typedef struct {\n  int balance;\n  mtx_t balance_mutex;\n    /* Should not change after initialization */\n  unsigned int id;\n} bank_account;\n typedef struct {\n  bank_account *from;\n  bank_account *to;\n  int amount;\n} transaction;\n unsigned int global_id = 1;\n void create_bank_account(bank_account **ba,\n                         int initial_amount) {\n  bank_account *nba = (bank_account *)malloc(\n    sizeof(bank_account)\n  );\n  if (nba == NULL) {\n    /* Handle error */\n  }\n   nba->balance = initial_amount;\n  if (thrd_success\n      != mtx_init(&nba->balance_mutex, mtx_plain)) {\n    /* Handle error */\n  }\n   nba->id = global_id++;\n  *ba = nba;\n}\n int deposit(void *ptr) {\n  transaction *args = (transaction *)ptr;\n  int result = -1;\n  mtx_t *first;\n  mtx_t *second;\n   if (args->from->id == args->to->id) {\n    return -1; /* Indicate error */\n  }\n   /* Ensure proper ordering for locking */\n  if (args->from->id < args->to->id) {\n    first = &args->from->balance_mutex;\n    second = &args->to->balance_mutex;\n  } else {\n    first = &args->to->balance_mutex;\n    second = &args->from->balance_mutex;\n  }\n  if (thrd_success != mtx_lock(first)) {\n    /* Handle error */\n  }\n  if (thrd_success != mtx_lock(second)) {\n    /* Handle error */\n  }\n   /* Not enough balance to transfer */\n  if (args->from->balance >= args->amount) {\n    args->from->balance -= args->amount;\n    args->to->balance += args->amount;\n    result = 0;\n  }\n   if (thrd_success != mtx_unlock(second)) {\n    /* Handle error */\n  }\n  if (thrd_success != mtx_unlock(first)) {\n    /* Handle error */\n  }\n  free(ptr);\n  return result;\n} \nRisk Assessment\nDeadlock prevents multiple threads from progressing, halting program execution. A denial-of-service attack is possible if the attacker can create the conditions for deadlock.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON35-C\nLow\nProbable\nNo\nNo\nP2\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ndeadlock Supported by sound analysis (deadlock alarm)\nCodeSonar\n9.1p0\nCONCURRENCY.LOCK.ORDER Conflicting lock order\nCoverity\n2017.07\nORDER_REVERSAL Fully implemented\nCppcheck Premium\n24.11.0\npremium-cert-con35-c\nHelix QAC\n2025.2\nC1772, C1773\nKlocwork\n2025.2\nCONC.DL\nCONC.NO_UNLOCK\n\nParasoft C/C++test\n2024.2\nCERT_C-CON35-a\nDo not acquire locks in different order\nPC-lint Plus\n1.4\n2462\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON35-C\nChecks for deadlock (rule partially covered)\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT Oracle Secure Coding Standard for Java LCK07-J. Avoid deadlock by requesting and releasing locks in the same order Prior to 2018-01-12: CERT: Unspecified Relationship",
        "language": "C"
    },
    {
        "rule_id": "CON36-C",
        "rule_title": "Wrap functions that can spuriously wake up in a loop",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON36-C.+Wrap+functions+that+can+spuriously+wake+up+in+a+loop",
        "content": "The cnd_wait() and cnd_timedwait() functions temporarily cede possession of a mutex so that other threads that may be requesting the mutex can proceed. These functions must always be called from code that is protected by locking a mutex. The waiting thread resumes execution only after it has been notified, generally as the result of the invocation of the cnd_signal() or cnd_broadcast() function invoked by another thread. The cnd_wait() function must be invoked from a loop that checks whether a condition predicate holds. A condition predicate is an expression constructed from the variables of a function that must be true for a thread to be allowed to continue execution. The thread pauses execution, via cnd_wait(), cnd_timedwait(), or some other mechanism, and is resumed later, presumably when the condition predicate is true and the thread is notified.\n#include <threads.h>\n#include <stdbool.h>\n  extern bool until_finish(void);\nextern mtx_t lock;\nextern cnd_t condition;\n  void func(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n   while (until_finish()) {  /* Predicate does not hold */\n    if (thrd_success != cnd_wait(&condition, &lock)) {\n      /* Handle error */\n    }\n  }\n    /* Resume when condition holds */\n   if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}\nThe notification mechanism notifies the waiting thread and allows it to check its condition predicate. The invocation of cnd_broadcast() in another thread cannot precisely determine which waiting thread will be resumed. Condition predicate statements allow notified threads to determine whether they should resume upon receiving the notification. \nNoncompliant Code Example\nThis noncompliant code example monitors a linked list and assigns one thread to consume list elements when the list is nonempty. \nThis thread pauses execution using cnd_wait() and resumes when notified, presumably when the list has elements to be consumed. It is possible for the thread to be notified even if the list is still empty, perhaps because the notifying thread used cnd_broadcast(), which notifies all threads. Notification using cnd_broadcast() is frequently preferred over using cnd_signal(). (See CON38-C. Preserve thread safety and liveness when using condition variables for more information.)\nA condition predicate is typically the negation of the condition expression in the loop. In this noncompliant code example, the condition predicate for removing an element from a linked list is (list->next != NULL), whereas the condition expression for the while loop condition is (list->next == NULL).\nThis noncompliant code example nests the cnd_wait() function inside an if block and consequently fails to check the condition predicate after the notification is received. If the notification was spurious or malicious, the thread would wake up prematurely.\n#include <stddef.h>\n#include <threads.h>\n  struct node_t {\n  void *node;\n  struct node_t *next;\n};\n  struct node_t list;\nstatic mtx_t lock;\nstatic cnd_t condition;\n  void consume_list_element(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n    if (list.next == NULL) {\n    if (thrd_success != cnd_wait(&condition, &lock)) {\n      /* Handle error */\n    }\n  }\n   /* Proceed when condition holds */\n   if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}\nCompliant Solution\nThis compliant solution calls the cnd_wait() function from within a while loop to check the condition both before and after the call to cnd_wait():\n#include <stddef.h>\n#include <threads.h>\n  struct node_t {\n  void *node;\n  struct node_t *next;\n};\n  struct node_t list;\nstatic mtx_t lock;\nstatic cnd_t condition;\n  void consume_list_element(void) {\n  if (thrd_success != mtx_lock(&lock)) {\n    /* Handle error */\n  }\n    while (list.next == NULL) {\n    if (thrd_success != cnd_wait(&condition, &lock)) {\n      /* Handle error */\n    }\n  }\n   /* Proceed when condition holds */\n   if (thrd_success != mtx_unlock(&lock)) {\n    /* Handle error */\n  }\n}\nRisk Assessment\nFailure to enclose calls to the cnd_wait() or cnd_timedwait() functions inside a while loop can lead to indefinite blocking and denial of service (DoS).\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON36-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nLANG.STRUCT.ICOL\nCONCURRENCY.BADFUNC.CNDWAIT\nInappropriate Call Outside Loop\nUse of Condition Variable Wait\nCppcheck Premium\n24.11.0\npremium-cert-con36-c\nHelix QAC\n2025.2\nC2027\nKlocwork\n2025.2\nCERT.CONC.WAKE_IN_LOOP_C\n\nParasoft C/C++test\n2024.2\nCERT_C-CON36-a\nWrap functions that can spuriously wake up in a loop\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON36-C Checks for situations where functions that can spuriously wake up are not wrapped in loop (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website. \nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT Oracle Secure Coding Standard for Java THI03-J. Always invoke wait() and await() methods inside a loop Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[Lea 2000]\n1.3.2, \"Liveness\"\n3.2.2, \"Monitor Mechanics\"",
        "language": "C"
    },
    {
        "rule_id": "CON38-C",
        "rule_title": "Preserve thread safety and liveness when using condition variables",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON38-C.+Preserve+thread+safety+and+liveness+when+using+condition+variables",
        "content": "Both thread safety and liveness are concerns when using condition variables. The thread-safety property requires that all objects maintain consistent states in a multithreaded environment [Lea 2000]. The liveness property requires that every operation or function invocation execute to completion without interruption; for example, there is no deadlock.\nCondition variables must be used inside a while loop. (See CON36-C. Wrap functions that can spuriously wake up in a loop for more information.) To guarantee liveness, programs must test the while loop condition before invoking the cnd_wait() function. This early test checks whether another thread has already satisfied the condition predicate and has sent a notification. Invoking the cnd_wait() function after the notification has been sent results in indefinite blocking.\nTo guarantee thread safety, programs must test the while loop condition after returning from the cnd_wait() function. When a given thread invokes the cnd_wait() function, it will attempt to block until its condition variable is signaled by a call to cnd_broadcast() or to cnd_signal().\nThe cnd_signal() function unblocks one of the threads that are blocked on the specified condition variable at the time of the call. If multiple threads are waiting on the same condition variable, the scheduler can select any of those threads to be awakened (assuming that all threads have the same priority level). The cnd_broadcast() function unblocks all of the threads that are blocked on the specified condition variable at the time of the call. The order in which threads execute following a call to cnd_broadcast() is unspecified. Consequently, an unrelated thread could start executing, discover that its condition predicate is satisfied, and resume execution even though it was supposed to remain dormant. For these reasons, threads must check the condition predicate after the cnd_wait() function returns. A while loop is the best choice for checking the condition predicate both before and after invoking cnd_wait().\nThe use of cnd_signal() is safe if each thread uses a unique condition variable. If multiple threads share a condition variable, the use of cnd_signal() is safe only if the following conditions are met:\nAll threads must perform the same set of operations after waking up, which means that any thread can be selected to wake up and resume for a single invocation of cnd_signal().\nOnly one thread is required to wake upon receiving the signal.\nThe cnd_broadcast() function can be used to unblock all of the threads that are blocked on the specified condition variable if the use of cnd_signal() is unsafe.\nNoncompliant Code Example (cnd_signal())\nThis noncompliant code example uses five threads that are intended to execute sequentially according to the step level assigned to each thread when it is created (serialized processing). The current_step variable holds the current step level and is incremented when the respective thread completes. Finally, another thread is signaled so that the next step can be executed. Each thread waits until its step level is ready, and the cnd_wait() function call is wrapped inside a while loop, in compliance with CON36-C. Wrap functions that can spuriously wake up in a loop.\n#include <stdio.h>\n#include <threads.h>\n enum { NTHREADS = 5 };\n mtx_t mutex;\ncnd_t cond;\n int run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n   if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n   printf(\"Thread %zu has the lock\\n\", my_step);\n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n     if (thrd_success != cnd_wait(&cond, &mutex)) {\n      /* Handle error */\n    }\n     printf(\"Thread %zu woke up\\n\", my_step);\n  }\n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n  current_step++;\n   /* Signal awaiting task */\n  if (thrd_success != cnd_signal(&cond)) {\n    /* Handle error */\n  }\n   printf(\"Thread %zu is exiting...\\n\", my_step);\n   if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\nint main(void) {\n  thrd_t threads[NTHREADS];\n  size_t step[NTHREADS];\n   if (thrd_success != mtx_init(&mutex, mtx_plain)) {\n    /* Handle error */\n  }\n   if (thrd_success != cnd_init(&cond)) {\n    /* Handle error */\n  }\n   /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    step[i] = i;\n     if (thrd_success != thrd_create(&threads[i], run_step,\n                                    &step[i])) {\n      /* Handle error */\n    }\n  }\n   /* Wait for all threads to complete */\n  for (size_t i = NTHREADS; i != 0; --i) {\n    if (thrd_success != thrd_join(threads[i-1], NULL)) {\n      /* Handle error */\n    }\n  }\n   mtx_destroy(&mutex);\n  cnd_destroy(&cond);\n  return 0;\n} \nIn this example, all threads share a condition variable. Each thread has its own distinct condition predicate because each thread requires current_step to have a different value before proceeding. When the condition variable is signaled, any of the waiting threads can wake up.\nThe following table illustrates a possible scenario in which the liveness property is violated. If, by chance, the notified thread is not the thread with the next step value, that thread will wait again. No additional notifications can occur, and eventually the pool of available threads will be exhausted.\nDeadlock: Out-of-Sequence Step Value\nTime\nThread #\n(my_step)\ncurrent_step\nAction\n0\n3\n0\nThread 3 executes first time: predicate is FALSE -> wait()\n1\n2\n0\nThread 2 executes first time: predicate is FALSE -> wait()\n2\n4\n0\nThread 4 executes first time: predicate is FALSE -> wait()\n3\n0\n0\nThread 0 executes first time: predicate is TRUE -> current_step++; cnd_signal()\n4\n1\n1\nThread 1 executes first time: predicate is TRUE -> current_step++; cnd_signal()\n5\n3\n2\nThread 3 wakes up (scheduler choice): predicate is FALSE -> wait()\n6\n\u2014\n\u2014\nThread exhaustion! No more threads to run, and a conditional variable signal is needed to wake up the others\nThis noncompliant code example violates the liveness property.\nCompliant Solution (cnd_broadcast())\nThis compliant solution uses the cnd_broadcast() function to signal all waiting threads instead of a single random thread. Only the run_step() thread code from the noncompliant code example is modified, as follows:\n#include <stdio.h>\n#include <threads.h>\n mtx_t mutex;\ncnd_t cond;\nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n   if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n   printf(\"Thread %zu has the lock\\n\", my_step);\n   while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n     if (thrd_success != cnd_wait(&cond, &mutex)) {\n      /* Handle error */\n    }\n   printf(\"Thread %zu woke up\\n\", my_step);\n  }\n   /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n   current_step++;\n   /* Signal ALL waiting tasks */\n  if (thrd_success != cnd_broadcast(&cond)) {\n    /* Handle error */\n  }\n   printf(\"Thread %zu is exiting...\\n\", my_step);\n   if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\nAwakening all threads guarantees the liveness property because each thread will execute its condition predicate test, and exactly one will succeed and continue execution.\nCompliant Solution (Using cnd_signal() with a Unique Condition Variable per Thread)\nAnother compliant solution is to use a unique condition variable for each thread (all associated with the same mutex). In this case, cnd_signal() wakes up only the thread that is waiting on it. This solution is more efficient than using cnd_broadcast() because only the desired thread is awakened.\nThe condition predicate of the signaled thread must be true; otherwise, a deadlock will occur.\n#include <stdio.h>\n#include <threads.h>\n enum { NTHREADS = 5 };\n mtx_t mutex;\ncnd_t cond[NTHREADS];\n int run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n   if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n   printf(\"Thread %zu has the lock\\n\", my_step);\n   while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n     if (thrd_success != cnd_wait(&cond[my_step], &mutex)) {\n      /* Handle error */\n    }\n     printf(\"Thread %zu woke up\\n\", my_step);\n  }\n   /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n   current_step++;\n   /* Signal next step thread */\n  if ((my_step + 1) < NTHREADS) {\n    if (thrd_success != cnd_signal(&cond[my_step + 1])) {\n      /* Handle error */\n    }\n  }\n   printf(\"Thread %zu is exiting...\\n\", my_step);\n   if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\n int main(void) {\n  thrd_t threads[NTHREADS];\n  size_t step[NTHREADS];\n   if (thrd_success != mtx_init(&mutex, mtx_plain)) {\n    /* Handle error */\n  }\n   for (size_t i = 0; i< NTHREADS; ++i) {\n    if (thrd_success != cnd_init(&cond[i])) {\n      /* Handle error */\n    }\n  }\n   /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    step[i] = i;\n    if (thrd_success != thrd_create(&threads[i], run_step,\n                                    &step[i])) {\n      /* Handle error */\n    }\n  }\n   /* Wait for all threads to complete */\n  for (size_t i = NTHREADS; i != 0; --i) {\n    if (thrd_success != thrd_join(threads[i-1], NULL)) {\n      /* Handle error */\n    }\n  }\n   mtx_destroy(&mutex);\n   for (size_t i = 0; i < NTHREADS; ++i) {\n    cnd_destroy(&cond[i]);\n  }\n  return 0;\n}\nCompliant Solution (Windows, Condition Variables)\nThis compliant solution uses  a CONDITION_VARIABLE object, available on Microsoft Windows (Vista and later):\n#include <Windows.h>\n#include <stdio.h>\n  CRITICAL_SECTION lock;\nCONDITION_VARIABLE cond;\n  DWORD WINAPI run_step(LPVOID t) {\n  static size_t current_step = 0;\n  size_t my_step = (size_t)t;\n   EnterCriticalSection(&lock); \n  printf(\"Thread %zu has the lock\\n\", my_step);\n   while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n      if (!SleepConditionVariableCS(&cond, &lock, INFINITE)) {\n      /* Handle error */\n    }\n     printf(\"Thread %zu woke up\\n\", my_step);\n  }\n   /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n   current_step++;\n    LeaveCriticalSection(&lock);\n    /* Signal ALL waiting tasks */\n  WakeAllConditionVariable(&cond);\n    printf(\"Thread %zu is exiting...\\n\", my_step);\n  return 0;\n}\n  enum { NTHREADS = 5 };\n  int main(void) {\n  HANDLE threads[NTHREADS];\n     InitializeCriticalSection(&lock);\n  InitializeConditionVariable(&cond);\n    /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    threads[i] = CreateThread(NULL, 0, run_step, (LPVOID)i, 0, NULL);\n  }\n    /* Wait for all threads to complete */\n  WaitForMultipleObjects(NTHREADS, threads, TRUE, INFINITE);\n    DeleteCriticalSection(&lock);\n    return 0;\n}\nRisk Assessment\nFailing to preserve the thread safety and liveness of a program when using condition variables can lead to indefinite blocking and denial of service (DoS).\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON38-C\nLow\nUnlikely\nNo\nYes\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nCONCURRENCY.BADFUNC.CNDSIGNAL\nUse of Condition Variable Signal\nCppcheck Premium\n24.11.0\npremium-cert-con38-c\nHelix QAC\n2025.2\nC1778, C1779\n\nKlocwork\n2025.2\nCERT.CONC.UNSAFE_COND_VAR_C\n\nParasoft C/C++test\n2024.2\nCERT_C-CON38-a\nUse the 'cnd_signal()' function with a unique condition variable\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON38-C Checks for multiple threads waiting on same condition variable (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT Oracle Secure Coding Standard for Java THI02-J. Notify all waiting threads rather than a single thread Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, pthread_cond_broadcast\nXSH, System Interfaces, pthread_cond_signal\n[Lea 2000]",
        "language": "C"
    },
    {
        "rule_id": "CON39-C",
        "rule_title": "Do not join or detach a thread that was previously joined or detached",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON39-C.+Do+not+join+or+detach+a+thread+that+was+previously+joined+or+detached",
        "content": "The C Standard, 7.28.5.6 paragraph 2 [ISO/IEC 9899:2024], states that a thread shall not be joined once it was previously joined or detached.\nThe termination of the other thread synchronizes with the completion of the thrd_join function. The thread identified by thr shall not have been previously detached or joined with another thread.\nSimilarly, subclause 7.28.5.3 paragraph 2 [ISO/IEC 9899:2024], states that a thread shall not be detached once it was previously joined or detached. \nThe thrd_detach function tells the operating system to dispose of any resources allocated to the thread identified by thr when that thread terminates. The thread identified by thr shall not have been previously detached or joined with another thread.\nViolating either of these subclauses results in undefined behavior 211.\nNoncompliant Code Example\nThis noncompliant code example detaches a thread that is later joined.\n#include <stddef.h>\n#include <threads.h>\n  int thread_func(void *arg) {\n  /* Do work */\n  thrd_detach(thrd_current());\n  return 0;\n}\n int main(void) {\n  thrd_t t;\n   if (thrd_success != thrd_create(&t, thread_func, NULL)) {\n    /* Handle error */\n    return 0;\n  }\n   if (thrd_success != thrd_join(t, 0)) {\n    /* Handle error */\n    return 0;\n  }\n  return 0;\n}\nCompliant Solution\n This compliant solution does not detach the thread. Its resources are released upon successfully joining with the main thread:\n#include <stddef.h>\n#include <threads.h>\n   int thread_func(void *arg) {\n  /* Do work */\n  return 0;\n}\n int main(void) {\n  thrd_t t;\n   if (thrd_success != thrd_create(&t, thread_func, NULL)) {\n    /* Handle error */\n    return 0;\n  }\n   if (thrd_success != thrd_join(t, 0)) {\n    /* Handle error */\n    return 0;\n  }\n  return 0;\n} \nRisk Assessment\nJoining or detaching a previously joined or detached thread is undefined behavior 211.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON39-C\nLow\nLikely\nNo\nNo\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nCodeSonar\n9.1p0\nCONCURRENCY.TNJ\nThread is not Joinable\nCppcheck Premium\n24.11.0\npremium-cert-con39-c\nHelix QAC\n2025.2\nC1776\nParasoft C/C++test\n2024.2\nCERT_C-CON39-a\nDo not join or detach a thread that was previously joined or detached\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON39-C Checks for join or detach of a joined or detached thread (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2024]\nSubclause 7.28.5.3, \"The thrd_detach Function\"\nSubclause 7.28.5.6, \"The thrd_join Function\"",
        "language": "C"
    },
    {
        "rule_id": "CON40-C",
        "rule_title": "Do not refer to an atomic variable twice in an expression",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON40-C.+Do+not+refer+to+an+atomic+variable+twice+in+an+expression",
        "content": "A consistent locking policy guarantees that multiple threads cannot simultaneously access or modify shared data. Atomic variables eliminate the need for locks by guaranteeing thread safety when certain operations are performed on them. The thread-safe operations on atomic variables are specified in the C Standard, subclauses 7.17.7 and 7.17.8 [ISO/IEC 9899:2024]. While atomic operations can be combined, combined operations do not provide the thread safety provided by individual atomic operations.\nEvery time an atomic variable appears on the left side of an assignment operator, including a compound assignment operator such as *=, an atomic write is performed on the variable. The use of the increment (++) or decrement (--) operators on an atomic variable constitutes an atomic read-and-write operation and is consequently thread-safe. Any reference of an atomic variable anywhere else in an expression indicates a distinct atomic read on the variable.\nIf the same atomic variable appears twice in an expression, then two atomic reads, or an atomic read and an atomic write, are required. Such a pair of atomic operations is not thread-safe, as another thread can modify the atomic variable between the two operations. Consequently, an atomic variable must not be referenced twice in the same expression.\nNoncompliant Code Example (atomic_bool)\nThis noncompliant code example declares a shared atomic_bool flag variable and provides a toggle_flag() method that negates the current value of flag:\n#include <stdatomic.h>\n#include <stdbool.h>\n   static atomic_bool flag = ATOMIC_VAR_INIT(false);\n   void init_flag(void) {\n  atomic_init(&flag, false);\n}\n   void toggle_flag(void) {\n  bool temp_flag = atomic_load(&flag);\n  temp_flag = !temp_flag;\n  atomic_store(&flag, temp_flag);\n}\n     bool get_flag(void) {\n  return atomic_load(&flag);\n}\nExecution of this code may result in unexpected behavior because the value of flag is read, negated, and written back. This occurs even though the read and write are both atomic.\nConsider, for example, two threads that call toggle_flag(). The expected effect of toggling flag twice is that it is restored to its original value. However, the scenario in the following table leaves flag in the incorrect state.\ntoggle_flag() without Compare-and-Exchange\nTime\nflag\nThread\nAction\n1\ntrue\nt1\nReads the current value of flag, which is true, into a cache\n2\ntrue\nt2\nReads the current value of flag, which is still true, into a different cache\n3\ntrue\nt1\nToggles the temporary variable in the cache to false\n4\ntrue\nt2\nToggles the temporary variable in the different cache to false\n5\nfalse\nt1\nWrites the cache variable's value to flag\n6\nfalse\nt2\nWrites the different cache variable's value to flag\nAs a result, the effect of the call by t2 is not reflected in flag; the program behaves as if toggle_flag() was called only once, not twice.\nCompliant Solution (atomic_compare_exchange_weak())\nThis compliant solution uses a compare-and-exchange to guarantee that the correct value is stored in flag. All updates are visible to other threads. The call to atomic_compare_exchange_weak() is in a loop in conformance with CON41-C. Wrap functions that can fail spuriously in a loop.\n#include <stdatomic.h>\n#include <stdbool.h>\n  static atomic_bool flag = ATOMIC_VAR_INIT(false);\n  void init_flag(void) {\n  atomic_init(&flag, false);\n}\n  void toggle_flag(void) {\n  bool old_flag = atomic_load(&flag);\n  bool new_flag;\n  do {\n    new_flag = !old_flag;\n  } while (!atomic_compare_exchange_weak(&flag, &old_flag, new_flag));\n}\n    bool get_flag(void) {\n  return atomic_load(&flag);\n}\nAn alternative solution is to use the atomic_flag data type for managing Boolean values atomically. However, atomic_flag does not support a toggle operation.\nCompliant Solution (Compound Assignment)\nThis compliant solution uses the ^=  assignment operation to toggle flag. This operation is guaranteed to be atomic, according to the C Standard, 6.5.17.5, paragraph 3 [ISO/IEC 9899:2024]. This operation performs a bitwise-exclusive-or between its arguments, but for Boolean arguments, this is equivalent to negation.\n#include <stdatomic.h>\n#include <stdbool.h>\n   static atomic_bool flag = ATOMIC_VAR_INIT(false);\n   void toggle_flag(void) {\n  flag ^= 1;\n}\n     bool get_flag(void) {\n  return flag;\n}\nAn alternative solution is to use a mutex to protect the atomic operation, but this solution loses the performance benefits of atomic variables.\nNoncompliant Code Example\nThis noncompliant code example takes an atomic global variable n and computes n + (n - 1) + (n - 2) + ... + 1, using the formula n * (n + 1) / 2:\n#include <stdatomic.h>\n atomic_int n = ATOMIC_VAR_INIT(0);\n   int compute_sum(void) {\n  return n * (n + 1) / 2;\n}\nThe value of n may change between the two atomic reads of n in the expression, yielding an incorrect result.\nCompliant Solution\nThis compliant solution passes the atomic variable as a function argument, forcing the variable to be copied and guaranteeing a correct result. Note that the function's formal parameter need not be atomic, and the atomic variable can still be passed as an actual argument.\n#include <stdatomic.h>\n  int compute_sum(int n) {\n  return n * (n + 1) / 2;\n}\nRisk Assessment\nWhen operations on atomic variables are assumed to be atomic, but are not atomic, surprising data races can occur, leading to corrupted data and invalid control flow.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON40-C\nMedium\nProbable\nYes\nNo\nP8\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nmultiple-atomic-accesses Partially checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-CON40\nCodeSonar\n9.1p0\nCONCURRENCY.MAA\nMultiple Accesses of Atomic\nCoverity\n2017.07\nEVALUATION_ORDER (partial)\nMISRA 2012 Rule 13.2\nVOLATILE_ATOICITY (possible)\nImplemented\nCppcheck Premium\n24.11.0\npremium-cert-con40-c\nHelix QAC\n2025.2\nC1114, C1115, C1116\nC++3171, C++4150\n\nKlocwork\n2025.2\nCERT.CONC.ATOMIC_TWICE_EXPR\n\nParasoft C/C++test\n2024.2\nCERT_C-CON40-a\nDo not refer to an atomic variable twice in an expression\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON40-C\nChecks for:\nAtomic variable accessed twice in an expression\nAtomic load and store sequence not atomic\nRule fully covered.\nRuleChecker\n24.04\nmultiple-atomic-accesses Partially checked\nSecurity Reviewer - Static Reviewer\n6.02\nC122\nC123 Fully Implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCWE 2.11 CWE-366, Race Condition within a Thread 2017-07-07: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-366 and CON40-C\nCON40-C = Subset( CON43-C) Intersection( CON32-C, CON40-C) = \u00d8\nCWE-366 = Union( CON40-C, list) where list =\n\nC data races that do not involve an atomic variable used twice within an expression\n\n\nBibliography\n[ISO/IEC 9899:2024]\n6.5.17.3, \"Compound Assignment\"\n7.17, \"Atomics\"",
        "language": "C"
    },
    {
        "rule_id": "CON41-C",
        "rule_title": "Wrap functions that can fail spuriously in a loop",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON41-C.+Wrap+functions+that+can+fail+spuriously+in+a+loop",
        "content": "Functions that can fail spuriously should be wrapped in a loop.  The atomic_compare_exchange_weak() and atomic_compare_exchange_weak_explicit() functions both attempt to set an atomic variable to a new value but only if it currently possesses a known old value. Unlike the related functions atomic_compare_exchange_strong() and atomic_compare_exchange_strong_explicit(), these functions are permitted to fail spuriously. This makes these functions faster on some platforms\u2014for example, on architectures that implement compare-and-exchange using load-linked/store-conditional instructions, such as Alpha, ARM, MIPS, and PowerPC. The C Standard, 7.17.7.4, paragraph 5 [ISO/IEC 9899:2024], describes this behavior:\nA weak compare-and-exchange operation may fail spuriously. That is, even when the contents of memory referred to by expected and object are equal, it may return zero and store back to expected the same memory contents that were originally there.\nNoncompliant Code Example\nIn this noncompliant code example, reorganize_data_structure() is to be used as an argument to thrd_create().  After reorganizing, the function attempts to replace the head pointer so that it points to the new version.  If no other thread has changed the head pointer since it was originally loaded, reorganize_data_structure() is intended to exit the thread with a result of true, indicating success.  Otherwise, the new reorganization attempt is discarded and the thread is exited with a result of false.  However, atomic_compare_exchange_weak() may fail even when the head pointer has not changed. Therefore, reorganize_data_structure() may perform the work and then discard it unnecessarily.\n#include <stdatomic.h>\n#include <stdbool.h>\n struct data {\n  struct data *next;\n  /* ... */\n};\n extern void cleanup_data_structure(struct data *head);\n int reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n   /* ... Reorganize the data structure ... */\n   success = atomic_compare_exchange_weak(ptr_to_head,\n                                         &old_head, new_head);\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n}\nCompliant Solution (atomic_compare_exchange_weak())\nTo recover from spurious failures, a loop must be used.  However, atomic_compare_exchange_weak() might fail because the head pointer changed, or the failure may be spurious. In either case, the thread must perform the work repeatedly until the compare-and-exchange succeeds, as shown in this compliant solution:\n#include <stdatomic.h>\n#include <stdbool.h>\n#include <stddef.h>\n struct data {\n  struct data *next;\n  /* ... */\n};\n extern void cleanup_data_structure(struct data *head);\n int reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head = NULL;\n  struct data *saved_old_head;\n  bool success;\n   do {\n    if (new_head != NULL) {\n      cleanup_data_structure(new_head);\n    }\n    saved_old_head = old_head;\n   /* ... Reorganize the data structure ... */\n   } while (!(success = atomic_compare_exchange_weak(\n               ptr_to_head, &old_head, new_head\n             )) && old_head == saved_old_head);\n  return success; /* Exit the thread */\n}\nThis loop could also be part of a larger control flow; for example, the thread from the noncompliant code example could be retried if it returns false.\nCompliant Solution (atomic_compare_exchange_strong())\nWhen a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable, as in this compliant solution:\n#include <stdatomic.h>\n#include <stdbool.h>\n struct data {\n  struct data *next;\n  /* ... */\n};\n extern void cleanup_data_structure(struct data *head);\n int reorganize_data_structure(void *thread_arg) {\n  struct data *_Atomic *ptr_to_head = thread_arg;\n  struct data *old_head = atomic_load(ptr_to_head);\n  struct data *new_head;\n  bool success;\n   /* ... Reorganize the data structure ... */\n   success = atomic_compare_exchange_strong(\n    ptr_to_head, &old_head, new_head\n  );\n  if (!success) {\n    cleanup_data_structure(new_head);\n  }\n  return success; /* Exit the thread */\n}\n\nRisk Assessment\nFailing to wrap the atomic_compare_exchange_weak() and atomic_compare_exchange_weak_explicit() functions in a loop can result in incorrect values and control flow.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON41-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nLANG.STRUCT.ICOL\nInappropriate Call Outside Loop\nCoverity\n2017.07\nBAD_CHECK_OF_WAIT_COND Implemented\nCppcheck Premium\n24.11.0\npremium-cert-con41-c\nHelix QAC\n2025.2\nC2026\nC++5023\n\nKlocwork\n2025.2\nCERT.CONC.ATOMIC_COMP_FAIL_IN_LOOP\n\nParasoft C/C++test\n2024.2\nCERT_C-CON41-a\nWrap functions that can fail spuriously in a loop\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON41-C Checks for situations where functions that can spuriously fail are not wrapped in loop (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT Oracle Secure Coding Standard for Java THI03-J. Always invoke wait() and await() methods inside a loop Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[ISO/IEC 9899:2024] 7.17.7.4, \"The atomic_compare_exchange Generic Functions\"\n[Lea 2000]\n1.3.2, \"Liveness\"\n3.2.2, \"Monitor Mechanics\"",
        "language": "C"
    },
    {
        "rule_id": "CON43-C",
        "rule_title": "Do not allow data races in multithreaded code",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON43-C.+Do+not+allow+data+races+in+multithreaded+code",
        "content": "When multiple threads can read or modify the same data, use synchronization techniques to avoid software flaws that can lead to security vulnerabilities. Data races can often result in abnormal termination or denial of service, but it is possible for them to result in more serious vulnerabilities. The C Standard, section 5.1.2.5, paragraph 35 [ISO/IEC 9899:2024], says:\nThe execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.\nNoncompliant Code Example\nAssume this simplified code is part of a multithreaded bank system. Threads call credit() and debit() as money is deposited into and withdrawn from the single account. Because the addition and subtraction operations are not atomic, it is possible that two operations can occur concurrently, but only the result of one would be saved\u2014despite declaring the account_balance volatile. For example, an attacker can credit the account with a sum of money and make a large number of small debits concurrently. Some of the debits might not affect the account balance because of the race condition, so the attacker is effectively creating money.\nstatic volatile int account_balance;\n\nvoid debit(int amount) {\n  account_balance -= amount;\n}\n\nvoid credit(int amount) {\n  account_balance += amount;\n}\nCompliant Solution (Mutex)\nThis compliant solution uses a mutex to make credits and debits atomic operations. All credits and debits will now affect the account balance, so an attacker cannot exploit the race condition to steal money from the bank. The mutex is created with the mtx_init() function. The presence of the mutex makes declaring account_balance volatile unnecessary.\n#include <threads.h>\n\nstatic int account_balance;\nstatic mtx_t account_lock;\n \nint debit(int amount) {\n  if (mtx_lock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  account_balance -= amount;\n  if (mtx_unlock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  return 0;   /* Indicate success */\n}\n\nint credit(int amount) {\n  if (mtx_lock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  account_balance += amount;\n  if (mtx_unlock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  return 0;   /* Indicate success */\n}\n \nint main(void) {\n  if(mtx_init(&account_lock, mtx_plain) == thrd_error) {\n    /* Handle error */\n  }\n  /* ... */\n}\nCompliant Solution (Atomic)\nThis compliant solution uses an atomic variable to synchronize credit and debit operations. All credits and debits will now affect the account balance, so an attacker cannot exploit the race condition to steal money from the bank. The atomic integer does not need to be initialized because default (zero) initialization of an atomic object with static or thread-local storage is guaranteed to produce a valid state. The += and -= operators behave atomically when used with an atomic variable.\n#include <stdatomic.h>\n\natomic_int account_balance;\n\nvoid debit(int amount) {\n  account_balance -= amount;\n}\n\nvoid credit(int amount) {\n  account_balance += amount;\n}\nNoncompliant Code Example (Double-Fetch)\nThis noncompliant code example illustrates Xen Security Advisory CVE-2015-8550 / XSA-155 In this example, the following code is vulnerable to a data race where the integer referenced by ps could be modified by a second thread that ran between the two reads of the variable.\n#include <stdio.h>\n \nvoid doStuff(int *ps) {\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\nEven though there is only one read of the *ps variable in the source code, the compiler is permitted to produce object code that performs multiple reads of the memory location. This is permitted by the \"as-if\" principle, as explained by section 5.1 of the [C99 Rationale 2003]:\nThe /as if/ principle is invoked repeatedly in this Rationale. The C89 Committee found that describing various aspects of the C language, library, and environment in terms of concrete models best serves discussion and presentation. Every attempt has been made to craft these models so that implementations are constrained only insofar as they must bring about the same result, /as if/ they had implemented the presentation model; often enough the clearest model would make for the worst implementation.\nImplementation Details (GCC)\nThis code produces two reads of the *ps value using GCC 4.8.4 on x86, as well as GCC 5.3.0 on x86-64 (Compiler-Introduced Double-Fetch Vulnerabilities \u2013 Understanding XSA-155).\nNoncompliant Code Example (Volatile)\nThe data race can be disabled by declaring the data to be volatile, because the volatile keyword forces the compiler to not produce two reads of the data. However, this violates CON02-C. Do not use volatile as a synchronization primitive.\n#include <stdio.h>\n \nvoid doStuff(volatile int *ps) {\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\nCompliant Solution (C11, Atomic)\nDeclaring the data to be atomic also forces the compiler to produce only one read of the data.\n#include <stdio.h>\n#include <stdatomic.h>\n \nvoid doStuff(atomic_int *ps) {\n  switch (atomic_load(ps)) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\nCompliant Solution (C11, Fences)\nThe bug was actually resolved by erecting fences around the switch statement.\n#include <stdio.h>\n#include <stdatomic.h>\n \nvoid doStuff(int *ps) {\n  atomic_thread_fence(memory_order_acquire);\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n  atomic_thread_fence(memory_order_release);\n}\nRisk Assessment\nRace conditions caused by multiple threads concurrently accessing and modifying the same data can lead to abnormal termination and denial-of-service attacks or data integrity violations.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON43-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool Version Checker Description\nAstr\u00e9e\n24.04\nread_data_race\nwrite_data_race\nSupported by sound analysis (data race alarm)\nCodeSonar\n9.1p0\nCONCURRENCY.DATARACE\nCONCURRENCY.MAA\nData race\nMultiple Accesses of Atomic\nCoverity\n2017.07\nMISSING_LOCK (partial) Implemented\nHelix QAC\n2025.2\nC1765, C1766, C1770, C1771\nC++1765, C++1766, C++1770, C++1771\n\nParasoft C/C++test\n2024.2\nCERT_C-CON43-a\nDo not use global variable with different locks set\nPC-lint Plus\n1.4\n457\nPartially supported: access is detected at the object level (not at the field level)\nPolyspace Bug Finder\nR2025b\nCERT C: Rule CON43-C\nChecks for data race (rule fully covered)\nPVS-Studio\n7.38\nV1088\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCWE 2.11 CWE-366, Race condition within a thread 2017-07-07: CERT: Exact\nBibliography\n[ISO/IEC 9899:2024] 5.1.2.5, \"Multi-threaded Executions and Data Races\"\n[C99 Rationale 2003]\n[Dowd 2006] Chapter 13, \"Synchronization and State\"\n[Plum 2012]\n[Seacord 2013] Chapter 8, \"File I/O\"",
        "language": "C"
    },
    {
        "rule_id": "CON04-C",
        "rule_title": "Join or detach threads even if their exit status is unimportant",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/CON04-C.+Join+or+detach+threads+even+if+their+exit+status+is+unimportant",
        "content": "The thrd_detach() function is used to tell the underlying system that resources allocated to a particular thread can be reclaimed once it terminates. This function should be used when a thread's exit status is not required by other threads (and no other thread needs to use thrd_join() to wait for it to complete).\nWhenever a thread terminates without detaching, the thread's stack is deallocated, but some other resources, including the thread ID and exit status, are left until it is destroyed by either thrd_join() or thrd_detach(). These resources can be vital for systems with limited resources and can lead to various \"resource unavailable\" errors, depending on which critical resource gets used up first. For example, if the system has a limit (either per-process or system wide) on the number of thread IDs it can keep track of, failure to release the thread ID of a terminated thread may lead to thrd_create() being unable to create another thread.\nNoncompliant Code Example\nThis noncompliant code example shows a pool of threads that are not exited correctly:\n#include <stdio.h>\n#include <threads.h>\n  const size_t thread_no = 5;\nconst char mess[] = \"This is a test\";\n int message_print(void *ptr){\n  const char *msg = (const char *) ptr;\n  printf(\"THREAD: This is the Message %s\\n\", msg);\n  return 0;\n}\n int main(void){\n  /* Create a pool of threads */\n  thrd_t thr[thread_no];\n  for (size_t i = 0; i < thread_no; ++i) {\n    if (thrd_create(&(thr[i]), message_print,\n                    (void *)mess) != thrd_success) {\n      fprintf(stderr, \"Creation of thread %zu failed\\n\", i);\n      /* Handle error */\n    }\n  }\n  printf(\"MAIN: Thread Message: %s\\n\", mess);\n  return 0;\n}\nCompliant Solution\nIn this compliant solution, the message_print() function is replaced by a similar function that correctly detaches the threads so that the associated resources can be reclaimed on exit:\n#include <stdio.h>\n#include <threads.h>\n  const size_t thread_no = 5;\nconst char mess[] = \"This is a test\";\n int message_print(void *ptr){\n  const char *msg = (const char *)ptr;\n  printf(\"THREAD: This is the Message %s\\n\", msg);\n    /* Detach the thread, check the return code for errors */\n  if (thrd_detach(thrd_current()) != thrd_success) {\n    /* Handle error */\n  }\n  return 0;\n}\n int main(void) {\n  /* Create a pool of threads */\n  thrd_t thr[thread_no];\n  for(size_t i = 0; i < thread_no; ++i) {\n    if (thrd_create(&(thr[i]), message_print,\n                    (void *)mess) != thrd_success) {\n      fprintf(stderr, \"Creation of thread %zu failed\\n\", i);\n      /* Handle error */\n    }\n  }\n  printf(\"MAIN: Thread Message: %s\\n\", mess);\n  return 0;\n}\nRisk Assessment\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nCON04-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, pthread_detach",
        "language": "C"
    },
    {
        "rule_id": "POS04-C",
        "rule_title": "Avoid using PTHREAD_MUTEX_NORMAL type mutex locks",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS04-C.+Avoid+using+PTHREAD_MUTEX_NORMAL+type+mutex+locks",
        "content": "Pthread mutual exclusion (mutex) locks are used to avoid simultaneous usage of common resources. Several types of mutex locks are defined by pthreads: NORMAL, ERRORCHECK, RECURSIVE, and DEFAULT.\nPOSIX describes PTHREAD_MUTEX_NORMAL locks as having the following undefined behavior [Open Group 2004]:\nThis type of mutex does not provide deadlock detection. A thread attempting to relock this mutex without first unlocking it shall deadlock. An error is not returned to the caller. Attempting to unlock a mutex locked by a different thread results in undefined behavior. Attempting to unlock an unlocked mutex results in undefined behavior.\nThe DEFAULT mutex pthread is also generally mapped to PTHREAD_MUTEX_NORMAL but is known to vary from platform to platform [SOL 2010]. Consequently, NORMAL locks should not be used, and ERRORCHECK or RECURSIVE locks should be defined explicitly when mutex locks are used.\nNoncompliant Code Example\nThis noncompliant code example shows a simple mutex being created using PTHREAD_MUTEX_NORMAL. Note that the caller does not expect a return code when NORMAL mutex locks are used.\npthread_mutexattr_t attr;\npthread_mutex_t mutex;\nsize_t const shared_var = 0;\n\nint main(void) {\n  int result;\n\n  if ((result = pthread_mutexattr_init(&attr)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_NORMAL)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutex_init(&mutex, &attr)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  /* Critical Region*/\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  return 0;\n}\nCompliant Solution\nThis compliant solution shows an ERRORCHECK mutex lock being created so that return codes will be available during locking and unlocking:\npthread_mutexattr_t attr;\npthread_mutex_t mutex;\nsize_t const shared_var = 0;\n\nint main(void) {\n  int result;\n\n  if ((result = pthread_mutexattr_init(&attr)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutex_init(&mutex, &attr)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  /* Critical Region*/\n\n  if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n\n  return 0;\n}\nRisk Assessment\nUsing NORMAL mutex locks can lead to deadlocks or abnormal program termination.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS04-C\nLow\nUnlikely\nYes\nYes\nP3\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nPC-lint Plus\n1.4\n586\nFully supported\nBibliography\n[Open Group 2004]\n[SOL 2010]",
        "language": "C"
    },
    {
        "rule_id": "POS44-C",
        "rule_title": "Do not use signals to terminate threads",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS44-C.+Do+not+use+signals+to+terminate+threads",
        "content": "Do not send an uncaught signal to kill a thread because the signal kills the entire process, not just the individual thread. This rule is a specific instance of SIG02-C. Avoid using signals to implement normal functionality.\nIn POSIX systems, using the signal() function in a multithreaded program falls under exception CON37C-C-EX0 of rule CON37-C. Do not call signal() in a multithreaded program.\nNoncompliant Code Example\nThis code uses the pthread_kill() function to send a SIGTERM signal to the created thread. The thread receives the signal, and the entire process is terminated.\nvoid func(void *foo) {\n  /* Execution of thread */\n}\n int main(void) {\n  int result;\n  pthread_t thread;\n   if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_kill(thread, SIGTERM)) != 0) {\n    /* Handle Error */\n  }\n   /* This point is not reached because the process terminates in pthread_kill() */\n   return 0;\n}\nCompliant Solution\nThis compliant code uses instead the pthread_cancel() function to terminate the thread. The thread continues to run until it reaches a cancellation point. See The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition [Open Group 2004] for lists of functions that are required and allowed to be cancellation points. If the cancellation type is set to asynchronous, the thread is terminated immediately. However, POSIX requires only the pthread_cancel(), pthread_setcancelstate(), and pthread_setcanceltype() functions to be async-cancel safe. An application that calls other POSIX functions with asynchronous cancellation enabled is nonconforming. Consequently, we recommend disallowing asynchronous cancellation, as explained by POS47-C. Do not use threads that can be canceled asynchronously.\nvoid func(void *foo) {\n  /* Execution of thread */\n}\n int main(void) {\n  int result;\n  pthread_t thread;\n   if ((result = pthread_create(&thread, NULL, func, 0)) != 0) {\n    /* Handle Error */\n  }\n  if ((result = pthread_cancel(thread)) != 0) {\n    /* Handle Error */\n  }\n   /* Continue executing */\n   return 0;\n}\nRisk Assessment\nSending the signal to a process causes it to be abnormally terminated.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS44-C\nLow\nProbable\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nCONCURRENCY.BADFUNC.PTHREAD_KILL\nUse of pthread_kill\nHelix QAC\n2025.2\nC5034\nKlocwork\n2025.2\nMISRA.INCL.SIGNAL.2012\n\n\nParasoft C/C++test\n2024.2\nCERT_C-POS44-a\nThe 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads\nPC-lint Plus\n1.4\n586\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS44-C Checks for use of signal to kill thread (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[OpenBSD] signal() Man Page\n[MKS] pthread_cancel() Man Page\n[Open Group 2004]  Threads Overview",
        "language": "C"
    },
    {
        "rule_id": "POS47-C",
        "rule_title": "Do not use threads that can be canceled asynchronously",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS47-C.+Do+not+use+threads+that+can+be+canceled+asynchronously",
        "content": "In threading, pthreads can optionally be set to cancel immediately or defer until a specific cancellation point. Canceling asynchronously (immediately) is dangerous, however, because most threads are in fact not safe to cancel immediately.\nThe IEEE standards page states that\nonly functions that are cancel-safe may be called from a thread that is asynchronously cancelable.\nCanceling asynchronously would follow the same route as passing a signal into the thread to kill it, posing problems similar to those in CON37-C. Do not call signal() in a multithreaded program, which is strongly related to SIG02-C. Avoid using signals to implement normal functionality. POS44-C and SIG02-C expand on the dangers of canceling a thread suddenly, which can create a data race condition.\nNoncompliant Code Example\nIn this noncompliant code example, the worker thread is doing something as simple as swapping a and b repeatedly.\nThis code uses one lock. The global_lock mutex ensures that the worker thread and main thread do not collide in accessing the a and b variables.\nThe worker thread repeatedly exchanges the values of a and b until it is canceled by the main thread. The main thread then prints out the current values of a and b. Ideally, one should be 5, and the other should be 10.\nvolatile int a = 5;\nvolatile int b = 10;\n /* Lock to enable threads to access a and b safely */\npthread_mutex_t global_lock = PTHREAD_MUTEX_INITIALIZER;\n void* worker_thread(void* dummy) {\n  int i;\n  int c;\n  int result;\n   if ((result = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,&i)) != 0) {\n    /* handle error */\n  }\n   while (1) {\n    if ((result = pthread_mutex_lock(&global_lock)) != 0) {\n      /* handle error */\n    }\n    c = b;\n    b = a;\n    a = c;\n    if ((result = pthread_mutex_unlock(&global_lock)) != 0) {\n      /* handle error */\n    }\n  }\n  return NULL;\n}\n  int main(void) {\n  int result;\n  pthread_t worker;\n   if ((result = pthread_create( &worker, NULL, worker_thread, NULL)) != 0) {\n    /* handle error */\n  }\n   /* .. Do stuff...meanwhile worker thread runs for some time */\n   /* since we don't know when the character is read in, the program could continue at any time */\n  if ((result = pthread_cancel(worker)) != 0) {\n    /* handle error */\n  }\n  /* pthread_join waits for the thread to finish up before continuing */\n  if ((result = pthread_join(worker, 0)) != 0) {\n    /* handle error */\n  }\n   if ((result = pthread_mutex_lock(&global_lock)) != 0) {\n    /* handle error */\n  }\n  printf(\"a: %i | b: %i\", a, b);\n  if ((result = pthread_mutex_unlock(&global_lock)) != 0) {\n    /* handle error */\n  }\n   return 0;\n}\nHowever, this program is subject to a race condition because an asynchronous cancel can happen at any time. If the worker thread is canceled while the global_lock mutex is held, it is never actually released. In this case, the main thread will wait forever trying to acquire the global_lock, and the program will deadlock.\nIt is also possible that the main thread cancels the worker thread before it has invoked pthread_setcanceltype(). If this happens, the cancellation will be delayed until the worker thread calls pthread_setcanceltype().\nNoncompliant Code Example\nIn this example, the worker thread arranges to release the global_lock mutex if it gets interrupted:\nvoid release_global_lock(void* dummy) {\n  int result;\n  if ((result = pthread_mutex_unlock(&global_lock)) != 0) {\n    /* handle error */\n  }\n}\n void* worker_thread(void* dummy) {\n  int i;\n  int c;\n  int result;\n   if ((result = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,&i)) != 0) {\n    /* handle error */\n  }\n   while (1) {\n    if ((result = pthread_mutex_lock(&global_lock)) != 0) {\n      /* handle error */\n    }\n    pthread_cleanup_push( release_global_lock, NULL);\n    c = b;\n    b = a;\n    a = c;\n    pthread_cleanup_pop(1);\n  }\n  return NULL;\n}\nThe global variables are still subject to a race condition because an asynchronous cancel can happen at any time. For instance, the worker thread could be canceled just before the last line (a = c) and thereby lose the old value of b. Consequently, the main thread might print that a and b have the same value.\nThe program is still subject to the race condition where the main thread cancels the worker thread before it has invoked pthread_setcanceltype(). If this happens, the cancelation will be delayed until the worker thread calls pthread_setcanceltype().\nFurthermore, though less likely, the program can still deadlock if the worker thread gets canceled after the global_lock is acquired but before pthread_cleanup_push() is invoked. In this case, the worker thread is canceled while holding global_lock, and the program will deadlock.\nCompliant Solution\nFrom IEEE standards page:\nThe cancelability state and type of any newly created threads, including the thread in which main() was first invoked, shall be PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DEFERRED respectively.\nBecause the default condition for POSIX, according to the IEEE standards, is PTHREAD_CANCEL_DEFERRED, it is not necessary to invoke pthread_setcanceltype() in the compliant solution:\nvoid* worker_thread(void* dummy) {\n  int c;\n  int result;\n   while (1) {\n    if ((result = pthread_mutex_lock(&global_lock)) != 0) {\n      /* handle error */\n    }\n    c = b;\n    b = a;\n    a = c;\n    if ((result = pthread_mutex_unlock(&global_lock)) != 0) {\n      /* handle error */\n    }\n     /* now we're safe to cancel, creating cancel point */\n    pthread_testcancel();\n  }\n  return NULL;\n}\nBecause this code limits cancellation of the worker thread to the end of the while loop, the worker thread can preserve the data invariant that a != b. Consequently, the program might print that a is 5 and b is 10 or that a is 10 and b is 5, but they will always be revealed to have different values when the worker thread is canceled.\nThe other race conditions that plague the noncompliant code examples are not possible here. Because the worker thread does not modify its cancel type, it cannot be canceled before being improperly initialized. And because it cannot be canceled while the global_lock mutex is held, there is no possibility of deadlock, and the worker thread does not need to register any cleanup handlers.\nRisk Assessment\nIncorrectly using threads that asynchronously cancel may result in silent corruption, resource leaks, and, in the worst case, unpredictable interactions.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS47-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nbad-macro-use\nbad-macro-expansion\nSupported\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS47\nHelix QAC\n2025.2\nC5035\nKlocwork\n2025.2\nCERT.POS.THREAD.ASYNC_CANCEL\nParasoft C/C++test\n2024.2\nCERT_C-POS47-a\nThe function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument\nPC-lint Plus\n1.4\n586\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS47-C Checks for asynchronously cancellable thread (rule fully covered)\nRuleChecker\n24.04\nbad-macro-use\nbad-macro-expansion\nSupported\nBibliography\n\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT Oracle Coding Standard for Java: THI05-J. Do not use Thread.stop() to terminate threads\nIn Java, similar reasoning resulted in the deprecation of Thread.stop().\nBibliography\n[MKS] pthread_cancel() Man Page\n[Open Group 2004 Threads Overview",
        "language": "C"
    },
    {
        "rule_id": "POS48-C",
        "rule_title": "Do not unlock or destroy another POSIX thread's mutex",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS48-C.+Do+not+unlock+or+destroy+another+POSIX+thread%27s+mutex",
        "content": "Mutexes are used to protect shared data structures being accessed concurrently. The thread that locks the mutex owns it, and the owning thread should be the only thread to unlock the mutex. If the mutex is destroyed while still in use, critical sections and shared data are no longer protected. This rule is a specific instance of  CON31-C. Do not unlock or destroy another thread's mutex using POSIX threads.\nNoncompliant Code Example\nIn this noncompliant code example, a race condition exists between a cleanup and a worker thread. The cleanup thread destroys the lock, which it believes is no longer in use. If there is a heavy load on the system, the worker thread that held the lock can take longer than expected. If the lock is destroyed before the worker thread has completed modifying the shared data, the program may exhibit unexpected behavior.\npthread_mutex_t theLock;\nint data;\n int cleanupAndFinish(void) {\n  int result;\n  if ((result = pthread_mutex_destroy(&theLock)) != 0) {\n    /* Handle error */\n  }\n  data++;\n  return data;\n}\n void worker(int value) {\n  if ((result = pthread_mutex_lock(&theLock)) != 0) {\n    /* Handle error */\n  }\n  data += value;\n  if ((result = pthread_mutex_unlock(&theLock)) != 0) {\n    /* Handle error */\n  }\n}\nCompliant Solution\nThis compliant solution requires that there is no chance a mutex will be needed after it has been destroyed. As always, it is important to check for error conditions when locking the mutex.\nmutex_t theLock;\nint data;\n int cleanupAndFinish(void) {\n  int result;\n   /* A user-written function that is application-dependent */\n  wait_for_all_threads_to_finish();\n  if ((result = pthread_mutex_destroy(&theLock)) != 0) {\n    /* Handle error */\n  }\n  data++;\n  return data;\n}\n void worker(int value) {\n  int result;\n  if ((result = pthread_mutex_lock(&theLock)) != 0) {\n    /* Handle error */\n  }\n  data += value;\n  if ((result = pthread_mutex_unlock(&theLock)) != 0) {\n    /* Handle error */\n  }\n}\nRisk Assessment\nThe risks of ignoring mutex ownership are similar to the risk of not using mutexes at all, which can result in a violation of data integrity.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS48-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nCONCURRENCY.DU\nDouble Unlock\nHelix QAC\n2025.2\nDF4971, DF4972, DF4981, DF4982\n\nParasoft C/C++test\n2024.2\nCERT_C-POS48-a\nCERT_C-POS48-b\nDo not destroy another thread's mutex\nDo not release a lock that has not been acquired\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS48-C Checks for destruction of locked mutex (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCWE 2.11 CWE-667, Insufficient locking 2017-07-10: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-667 and CON31-C/POS48-C\nIntersection( CON31-C, POS48-C) = \u00d8\nCWE-667 = Union, CON31-C, POS48-C, list) where list =\n\nLocking & Unlocking issues besides unlocking another thread\u2019s C mutex or pthread mutex.\n\nBibliography\n[Open Group 2004] pthread_mutex_lock()/pthread_mutex_unlock()\npthread_mutex_destroy()",
        "language": "C"
    },
    {
        "rule_id": "POS49-C",
        "rule_title": "When data must be accessed by multiple threads, provide a mutex and guarantee no adjacent data is also accessed",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS49-C.+When+data+must+be+accessed+by+multiple+threads%2C+provide+a+mutex+and+guarantee+no+adjacent+data+is+also+accessed",
        "content": "When multiple threads must access or make modifications to a common variable, they may also inadvertently access other variables adjacent in memory. This is an artifact of variables being stored compactly, with one byte possibly holding multiple variables, and is a common optimization on word-addressed machines. Bit-fields are especially prone to this behavior because compliers are allowed to store multiple bit-fields in one addressable byte or word. This implies that race conditions may exist not just on a variable accessed by multiple threads but also on other variables sharing the same byte or word address. This recommendation is a specific instance of CON32-C. Prevent data races when accessing bit-fields from multiple threads using POSIX threads.\nA common tool for preventing race conditions in concurrent programming is the mutex. When properly observed by all threads, a mutex can provide safe and secure access to a common variable; however, it guarantees nothing with regard to other variables that might be accessed when a common variable is accessed.\nUnfortunately, there is no portable way to determine which adjacent variables may be stored along with a certain variable.\nA better approach is to embed a concurrently accessed variable inside a union, along with a long variable, or at least some padding to ensure that the concurrent variable is the only element to be accessed at that address. This technique would effectively guarantee that no other variables are accessed or modified when the concurrent variable is accessed or modified.\nNoncompliant Code Example (Bit-field)\nIn this noncompliant code example, two executing threads simultaneously access two separate members of a global struct:\nstruct multi_threaded_flags {\n  unsigned int flag1 : 2;\n  unsigned int flag2 : 2;\n};\n struct multi_threaded_flags flags;\n void thread1(void) {\n  flags.flag1 = 1;\n}\n void thread2(void) {\n  flags.flag2 = 2;\n}\nAlthough this code appears to be harmless, it is likely that flag1 and flag2 are stored in the same byte. If both assignments occur on a thread-scheduling interleaving that ends with both stores occurring after one another, it is possible that only one of the flags will be set as intended, and the other flag will equal its previous value, because both bit-fields are represented by the same byte, which is the smallest unit the processor can work on.\nFor example, the following sequence of events can occur:\nThread 1: register 0 = flags\nThread 1: register 0 &= ~mask(flag1)\nThread 2: register 0 = flags\nThread 2: register 0 &= ~mask(flag2)\nThread 1: register 0 |= 1 << shift(flag1)\nThread 1: flags = register 0\nThread 2: register 0 |= 2 << shift(flag2)\nThread 2: flags = register 0\nEven though each thread is modifying a separate bit-field, they are both modifying the same location in memory. This is the same problem discussed in CON43-C. Do not allow data races in multithreaded code but is harder to diagnose because it is not immediately obvious that the same memory location is being modified.\nCompliant Solution (Bit-field)\nThis compliant solution protects all accesses of the flags with a mutex, thereby preventing any thread-scheduling interleaving from occurring. In addition, the flags are declared volatile to ensure that the compiler will not attempt to move operations on them outside the mutex. Finally, the flags are embedded in a union alongside a long, and a static assertion guarantees that the flags do not occupy more space than the long. This technique prevents any data not checked by the mutex from being accessed or modified with the bit-fields.\nstruct multi_threaded_flags {\n  volatile unsigned int flag1 : 2;\n  volatile unsigned int flag2 : 2;\n};\n union mtf_protect {\n  struct multi_threaded_flags s;\n  long padding;\n};\n static_assert(sizeof(long) >= sizeof(struct multi_threaded_flags));\n struct mtf_mutex {\n  union mtf_protect u;\n  pthread_mutex_t mutex;\n};\n struct mtf_mutex flags;\n void thread1(void) {\n  int result;\n  if ((result = pthread_mutex_lock(&flags.mutex)) != 0) {\n    /* Handle error */\n  }\n  flags.u.s.flag1 = 1;\n  if ((result = pthread_mutex_unlock(&flags.mutex)) != 0) {\n    /* Handle error */\n  }\n}\n void thread2(void) {\n  int result;\n  if ((result = pthread_mutex_lock(&flags.mutex)) != 0) {\n    /* Handle error */\n  }\n  flags.u.s.flag2 = 2;\n  if ((result = pthread_mutex_unlock(&flags.mutex)) != 0) {\n    /* Handle error */\n  }\n}\nStatic assertions are discussed in detail in DCL03-C. Use a static assertion to test the value of a constant expression.\nRisk Assessment\nAlthough the race window is narrow, having an assignment or an expression evaluate improperly because of misinterpreted data can result in a corrupted running state or unintended information disclosure.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS49-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS49\nCodeSonar\n9.1p0\nCONCURRENCY.DATARACE\nCONCURRENCY.MAA\nData race\nMultiple Accesses of Atomic\nCoverity\n2017.07\nVarious concurrency checkers\nPartially implemented; needs further investigation\nHelix QAC\n2025.2\nC1774, C1775\nParasoft C/C++test\n2024.2\nCERT_C-POS49-a\nUse locks to prevent race conditions when modifying bit fields\nPC-lint Plus\n1.4\n457\nPartially supported: access is detected at the object level (not at the field level)\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS49-C\nChecks for data race (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2024] Subclause 6.7.3.2, \"Structure and Union Specifiers\"",
        "language": "C"
    },
    {
        "rule_id": "POS50-C",
        "rule_title": "Declare objects shared between POSIX threads with appropriate storage durations",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS50-C.+Declare+objects+shared+between+POSIX+threads+with+appropriate+storage+durations",
        "content": "Accessing the stack or thread-local variables of a thread from another thread can cause invalid memory accesses because the execution of threads can be interwoven within the constraints of the synchronization model. As a result, the referenced stack frame or thread-local variable may not be valid when the other thread tries to access it. Regular shared variables should be protected by thread synchronization mechanisms. However, local variables should not be shared in the same fashion because the referenced stack frame's thread would have to stop executing, or some other way must be found to ensure that the referenced stack frame is still valid. See CON32-C. Prevent data races when accessing bit-fields from multiple threads for information on how to securely share nonautomatic and non-thread-local variables. See DCL30-C. Declare objects with appropriate storage durations for information on how to declare objects with appropriate storage durations when data is not being shared between threads. Note that this is a specific instance of CON34-C. Declare objects shared between threads with appropriate storage durations for POSIX threads.\nIt is important to note that local data can be used securely with threads when using other non-POSIX thread interfaces, so the programmer should not always copy data into nonlocal memory when sharing data with threads. For example, the shared keyword in OpenMP can be used in combination with OpenMP's threading interface to share local memory without having to worry about whether local automatic variables remain valid. Furthermore, copying the shared data into dynamic memory may completely negate the performance benefits of multithreading.\nNoncompliant Code Example (Automatic Storage)\nThe createThread() function allocates an integer on the stack and passes a void pointer, spawning off a new thread, childThread(). The order of thread execution is interleaved, so val can reference an object outside of its lifetime, causing the child thread to access an invalid memory location.\nvoid *childThread(void *val) {\n  /*\n   * Depending on the order of thread execution, the object\n   * referred to by val may be out of its lifetime, resulting\n   * in a potentially incorrect result being printed out.\n   */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n void createThread(pthread_t *tid) {\n  /* Store 1 in val on the stack. */\n  int val = 1;\n  int result;\n  if ((result = pthread_create(tid, NULL, childThread, &val)) != 0) {\n    /* Handle error */\n  }\n}\n int main(void) {\n  pthread_t tid;\n  int result;\n  createThread(&tid);\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\nImplementation Details\nThe automatic storage noncompliant code example incorrectly prints 0 when compiled with GCC 4.1.2 with the -lpthread flag on Linux.\nNoncompliant Code Example (Thread-Local Storage)\nThis noncompliant code example is incorrect because createThread() can finish running before childThread(), so childThread() may not access a valid object:\n__thread int val;\n void *childThread(void *val) {\n  int *res = (int *)val;\n   printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n void *createThread(void *childTid) {\n  pthread_t *tid = (pthread_t *)childTid;\n  int result;\n  val = 1;\n  if ((result = pthread_create(tid, NULL, childThread, &val)) != 0) {\n    /* Handle error */\n  }\n  return NULL;\n}\n void *empty(void *arg) {\n  /* Function that does nothing */\n  val = 0;\n  return NULL;\n}\n int main(void) {\n  pthread_t parentTid, childTid, emptyTid;\n  int result;\n   /*\n   * createThread() may complete before childThread(), and\n   * the thread-local variable, val, belonging to createThread(),\n   * may no longer be valid when childThread() runs.\n   */\n  if ((result = pthread_create(&parentTid, NULL, createThread, &childTid)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_join(parentTid, NULL)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_create(&emptyTid, NULL, empty, NULL)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_join(emptyTid, NULL)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_join(childTid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\nImplementation Details\nThis thread-local storage noncompliant code example incorrectly prints 0 when compiled with GCC 4.1.2 with the -lpthread flag on Linux.\nCompliant Solution (Allocated Storage)\nInstead of passing the pointer to the stack of the parent thread, one solution is to allocate space on the heap, copying the data to dynamic memory. Because the lifetime of an object stored in dynamic memory lasts until it is freed, the child thread ensures that memory accesses are valid.\nvoid *childThread(void *val) {\n  /* Correctly prints 1 */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  free(res);\n  return NULL;\n}\n void createThread(pthread *tid) {\n  int result;\n  /* Copy data into dynamic memory */\n  int *val = malloc(sizeof(int));\n   if (!val) {\n    /* Handle error */\n  }\n  *val = 1;\n  if ((result = pthread_create(&id, NULL, childThread, val)) != 0) {\n    /* Handle error */\n  }\n}\n int main(void) {\n  pthread_t tid;\n  int result;\n  createThread(&tid);\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\nCompliant Solution (Static Storage)\nAnother solution is to store the data as a global static variable. Unlike local automatic variables, which are stored on the stack, static variables are stored in the data section of memory. Static variables last for the execution of the entire program, so a thread can safely access global static variables.\n/* Declare val as a global static variable */\nint val;\n void *childThread(void *val) {\n  /* Correctly prints 1 */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n void createThread(pthread_t *tid) {\n  val = 1;\n  int result;\n  if ((result = pthread_create(tid, NULL, childThread, &val)) != 0) {\n    /* Handle error */\n  }\n}\n int main(void) {\n  pthread_t tid;\n  createThread(&tid);\n  int result;\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\nCompliant Solution (Automatic Storage)\nAnother solution is to ensure that local variables shared between threads are declared in the same or previous stack frame as a call to a thread synchronization mechanism, such as pthread_join(). For example, in this compliant solution, val is declared in main(), where pthread_join() is called. Because the parent thread will wait until the child thread completes before continuing its execution, the child thread is guaranteed to access an object that is still within its lifetime.\nvoid *childThread(void *val) {\n  /* Correctly prints 1 */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n void createThread(pthread_t *tid, int *val) {\n  int result = pthread_create(tid, NULL, childThread, val);\n  if (result != 0) {\n    /* Handle error */\n  }\n}\n int main(void) {\n  /* Declare val in the same function as pthread_join */\n  int val = 1;\n  int result;\n  pthread_t tid;\n  createThread(&tid, &val);\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\nCompliant Solution (Thread-Local Storage)\nAnother solution is to declare val a thread-local variable combined with a call to a thread synchronization mechanism, such as pthread_join(). Because the parent thread will wait until the child thread completes before continuing its execution, the child thread is guaranteed to access an object that is still within its lifetime.\n/* Declare val as a thread-local value */\n__thread int val;\n void *childThread(void *val) {\n  /* Correctly prints 1 */\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return NULL;\n}\n void createThread(pthread_t *tid) {\n  val = 1;\n  int result = pthread_create(tid, NULL, childThread, &val);\n  if (result != 0) {\n    /* Handle error */\n  }\n}\n int main(void) {\n  pthread_t tid;\n  int result;\n  createThread(&tid);\n  if ((result = pthread_join(tid, NULL)) != 0) {\n    /* Handle error */\n  }\n  return 0;\n}\nRisk Assessment\nThreads that reference the stack of other threads can potentially overwrite important information on the stack, such as function pointers and return addresses. However, it would be difficult for an attacker to exploit this code from this error alone. The compiler will not generate warnings if the programmer decides to give another thread access to one thread's local variables, so a programmer may not catch a potential error at compile time. The remediation cost for this error is high because analysis tools have difficulty diagnosing problems with concurrency and race conditions.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS50-C\nMedium\nProbable\nNo\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nHelix QAC\n2025.2\nDF4926, DF4927, DF4928\nParasoft C/C++test\n2024.2\nCERT_C-POS50-a\nDeclare objects shared between POSIX threads with appropriate storage durations\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS50-C Checks for automatic or thread local variable escaping from a POSIX thread (rule fully covered)\n\nBibliography\n[Bryant 2003] Chapter 13, \"Concurrent Programming\"\n[OpenMP]",
        "language": "C"
    },
    {
        "rule_id": "POS51-C",
        "rule_title": "Avoid deadlock with POSIX threads by locking in predefined order",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS51-C.+Avoid+deadlock+with+POSIX+threads+by+locking+in+predefined+order",
        "content": "Mutexes are often used to prevent multiple threads from accessing critical resources at the same time. Sometimes, when locking mutexes, multiple threads hold each other's lock, and the program consequently deadlocks. There are four requirements for deadlock:\nMutual exclusion\nHold and wait\nNo preemption\nCircular wait\nDeadlock requires all four conditions, so to prevent deadlock, prevent any one of the four conditions. This guideline recommends locking the mutexes in a predefined order to prevent circular wait. This rule is a specific instance of CON35-C. Avoid deadlock by locking in predefined order using POSIX threads.\nNoncompliant Code Example\nThis noncompliant code example has behavior that depends on the runtime environment and the platform's scheduler. However, with proper timing, the main() function will deadlock when running thr1 and thr2, where thr1 tries to lock ba2's mutex, while thr2 tries to lock on ba1's mutex in the deposit() function, and the program will not progress.\ntypedef struct {\n  int balance;\n  pthread_mutex_t balance_mutex;\n} bank_account;\n typedef struct {\n  bank_account *from;\n  bank_account *to;\n  int amount;\n} deposit_thr_args;\n void create_bank_account(bank_account **ba, int initial_amount) {\n  int result;\n  bank_account *nba = malloc(sizeof(bank_account));\n  if (nba == NULL) {\n    /* Handle error */\n  }\n   nba->balance = initial_amount;\n  result = pthread_mutex_init(&nba->balance_mutex, NULL);\n  if (result) {\n    /* Handle error */\n  }\n   *ba = nba;\n}\n  void *deposit(void *ptr) {\n  int result;\n  deposit_thr_args *args = (deposit_thr_args *)ptr;\n   if ((result = pthread_mutex_lock(&(args->from->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n   /* Not enough balance to transfer */\n  if (args->from->balance < args->amount) {\n    if ((result = pthread_mutex_unlock(&(args->from->balance_mutex))) != 0) {\n      /* Handle error  */\n    }\n    return NULL;\n  }\n   if ((result = pthread_mutex_lock(&(args->to->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n   args->from->balance -= args->amount;\n  args->to->balance += args->amount;\n   if ((result = pthread_mutex_unlock(&(args->from->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_mutex_unlock(&(args->to->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n   free(ptr);\n  return NULL;\n}\n int main(void) {\n   pthread_t thr1, thr2;\n  int result;\n   bank_account *ba1;\n  bank_account *ba2;\n  create_bank_account(&ba1, 1000);\n  create_bank_account(&ba2, 1000);\n   deposit_thr_args *arg1 = malloc(sizeof(deposit_thr_args));\n  if (arg1 == NULL) {\n    /* Handle error */\n  }\n  deposit_thr_args *arg2 = malloc(sizeof(deposit_thr_args));\n  if (arg2 == NULL) {\n    /* Handle error */\n  }\n   arg1->from = ba1;\n  arg1->to = ba2;\n  arg1->amount = 100;\n   arg2->from = ba2;\n  arg2->to = ba1;\n  arg2->amount = 100;\n   /* Perform the deposits */\n  if ((result = pthread_create(&thr1, NULL, deposit, (void *)arg1)) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_create(&thr2, NULL, deposit, (void *)arg2)) != 0) {\n    /* Handle error */\n  }\n   pthread_exit(NULL);\n  return 0;\n}\nCompliant Solution\nThe solution to the deadlock problem is to use a predefined order for the locks in the deposit() function. In this compliant solution, each thread will lock on the basis of the bank_account ID, defined in the struct initialization. This solution prevents the circular wait problem:\ntypedef struct {\n  int balance;\n  pthread_mutex_t balance_mutex;\n  unsigned int id; /* Should never be changed after initialized */\n} bank_account;\n unsigned int global_id = 1;\n void create_bank_account(bank_account **ba, int initial_amount) {\n  int result;\n  bank_account *nba = malloc(sizeof(bank_account));\n  if (nba == NULL) {\n    /* Handle error */\n  }\n   nba->balance = initial_amount;\n  result = pthread_mutex_init(&nba->balance_mutex, NULL);\n  if (result != 0) {\n    /* Handle error */\n  }\n   nba->id = global_id++;\n  *ba = nba;\n}\n void *deposit(void *ptr) {\n  deposit_thr_args *args = (deposit_thr_args *)ptr;\n  int result;\n   if (args->from->id == args->to->id)\n        return;\n   /* Ensure proper ordering for locking */\n  if (args->from->id < args->to->id) {\n    if ((result = pthread_mutex_lock(&(args->from->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n    if ((result = pthread_mutex_lock(&(args->to->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n  } else {\n    if ((result = pthread_mutex_lock(&(args->to->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n    if ((result = pthread_mutex_lock(&(args->from->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n  }\n   /* Not enough balance to transfer */\n  if (args->from->balance < args->amount) {\n    if ((result = pthread_mutex_unlock(&(args->from->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n    if ((result = pthread_mutex_unlock(&(args->to->balance_mutex))) != 0) {\n      /* Handle error */\n    }\n    return;\n  }\n   args->from->balance -= args->amount;\n  args->to->balance += args->amount;\n   if ((result = pthread_mutex_unlock(&(args->from->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n  if ((result = pthread_mutex_unlock(&(args->to->balance_mutex))) != 0) {\n    /* Handle error */\n  }\n   free(ptr);\n  return;\n}\nRisk Assessment\nDeadlock prevents multiple threads from progressing, thus halting the executing program. A denial-of-service attack is possible because the attacker can force deadlock situations. Deadlock is likely to occur in multithreaded programs that manage multiple shared resources.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS51-C\nLow\nProbable\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported: Astr\u00e9e reports all potential deadlocks.\nCodeSonar\n9.1p0\nCONCURRENCY.LOCK.ORDER Conflicting lock order\nHelix QAC\n2025.2\nC1772, C1773\nKlocwork\n2025.2\nCONC.DL\nCONC.NO_UNLOCK\n\nParasoft C/C++test\n2024.2\nCERT_C-POS51-a\nDo not acquire locks in different order\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS51-C\nChecks for deadlock (rule fully covered)\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C LCK07-J. Avoid deadlock by requesting and releasing locks in the same order Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-764 and POS51-C/POS35-C\nIndependent( CWE-764, POS51-C, POS35-C)\nCWE-764 is about semaphores, or objects capable of being locked multiple times. Deadlock arises from multiple locks being acquired in a cyclic order, and generally does not arise from semaphores or recursive mutexes.\nBibliography\n[Barney 2010] pthread_mutex tutorial\n[Bryant 2003] Chapter 13, \"Concurrent Programming\"",
        "language": "C"
    },
    {
        "rule_id": "POS53-C",
        "rule_title": "Do not use more than one mutex for concurrent waiting operations on a condition variable",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS53-C.+Do+not+use+more+than+one+mutex+for+concurrent+waiting+operations+on+a+condition+variable",
        "content": "pthread_cond_wait() and pthread_cond_timedwait() take a condition variable and locked mutex as arguments. These functions unlock the mutex until the condition variable is signaled and then relock the mutex before returning. While a thread is waiting on a particular condition variable and mutex, other threads may only wait on the same condition variable if they also pass the same mutex as an argument. This requirement is noted in the Open Group Base Specifications, Issue 6:\nAs long as at least one thread is blocked on the condition variable. During this time, the effect of an attempt by any thread to wait on that condition variable using a different mutex is undefined.\nIt also specifies that pthread_cond_wait() may\u20ac\u009d fail if:\n[EINVAL]\nThe value specified by cond or mutex is invalid.\n[EPERM]\nThe mutex was not owned by the current thread at the time of the call.\nNoncompliant Code Example\nIn this noncompliant code example, mutex1 protects count1 and mutex2 protects count2. A race condition exists between the waiter1 and waiter2 threads because they use the same condition variable with different mutexes. If both threads attempt to call pthread_cond_wait() at the same time, one thread will succeed and the other thread will invoke undefined behavior.\n#include <stdio.h>\n#include <string.h>\n#include <pthread.h>\n#include <assert.h>\n#include <unistd.h>\n#include <errno.h>\n pthread_mutex_t mutex1;\npthread_mutex_t mutex2;\npthread_mutexattr_t attr;\npthread_cond_t cv;\n void *waiter1();\nvoid *waiter2();\nvoid *signaler();\n int count1 = 0, count2 = 0;\n#define COUNT_LIMIT 5\n int main() {\n  int ret;\n  pthread_t thread1, thread2, thread3;\n   if ((ret = pthread_mutexattr_init( &attr)) != 0) {\n    /* Handle error */\n  }\n   if ((ret = pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_ERRORCHECK)) != 0) {\n    /* Handle error */\n  }\n   if ((ret = pthread_mutex_init( &mutex1, &attr)) != 0) {\n    /* Handle error */\n  }\n   if ((ret = pthread_mutex_init( &mutex2, &attr)) != 0) {\n    /* Handle error */\n  }\n   if ((ret = pthread_cond_init( &cv, NULL)) != 0) {\n    /* handle error */\n  }\n   if ((ret = pthread_create( &thread1, NULL, &waiter1, NULL))) {\n    /* Handle error */\n  }\n   if ((ret = pthread_create( &thread2, NULL, &waiter2, NULL))) {\n    /* handle error */\n  }\n   if ((ret = pthread_create( &thread3, NULL, &signaler, NULL))) {\n    /* Handle error */\n  }\n   if ((ret = pthread_join( thread1, NULL)) != 0) {\n    /* Handle error */\n  }\n   if ((ret = pthread_join( thread2, NULL)) != 0) {\n    /* Handle error */\n  }\n   if ((ret = pthread_join( thread3, NULL)) != 0) {\n    /* Handle error */\n  }\n   return 0;\n}\n  void *waiter1() {\n  int ret;\n  while (count1 < COUNT_LIMIT) {\n    if ((ret = pthread_mutex_lock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n     if ((ret = pthread_cond_wait(&cv, &mutex1)) != 0) {\n      /* Handle error */\n    }\n     printf(\"count1 = %d\\n\", ++count1);\n     if ((ret = pthread_mutex_unlock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n  }\n   return NULL;\n}\n void *waiter2() {\n  int ret;\n  while (count2 < COUNT_LIMIT) {\n    if ((ret = pthread_mutex_lock(&mutex2)) != 0) {\n      /* Handle error */\n    }\n     if ((ret = pthread_cond_wait(&cv, &mutex2)) != 0) {\n      /* Handle error */\n    }\n     printf(\"count2 = %d\\n\", ++count2);\n     if ((ret = pthread_mutex_unlock(&mutex2)) != 0) {\n      /* Handle error */\n    }\n  }\n   return NULL;\n}\n void *signaler() {\n  int ret;\n  while ((count1 < COUNT_LIMIT) || (count2 < COUNT_LIMIT)) {\n    sleep(1);\n    printf(\"signaling\\n\");\n    if ((ret = pthread_cond_signal(&cv)) != 0) {\n      /* Handle error */\n    }\n  }\n   return NULL;\n}\nImplementation Details: Linux\nWhen the system is built on the following platform,\nRed Hat Enterprise Linux Client release 5.5 (Tikanga)\nkernel 2.6.18\ngcc 4.3.5 with the --D_GNU_SOURCE flag\nthe preceding code works as expected. waiter1 and waiter2 increment the variable once they are signaled, and the correct mutex is acquired after pthread_cond_wait returns in each thread.\nThe man page for pthread_cond_wait on this configuration says that it may\u20ac\u009d fail with a return value of EINVAL if \"\u0080\u009cdifferent mutexes were supplied for concurrent pthread_cond_timedwait() or pthread_cond_wait() operations on the same condition variable.\" However, this does not happen.\nImplementation Details: OS X\nWhen the system is built on the following platform,\nOS X 10.6.4 (Snow Leopard)\ngcc 4.2.1\npthread_cond_wait() returns EINVAL if it is called when another thread is waiting on the condition variable with a different mutex. This approach is arguably better because it forces the coder to fix the problem instead of allowing reliance on undefined behavior.\nThe man page for pthread_cond_wait()}] simply says that {{EINVAL will be returned if \"\u0080\u009cthe value specified by cond or the value specified by mutex is invalid,\"\u0080\u009d but it doesn'\u0080\u0099t say what invalid means.\nCompliant Solution\nThis problem can be solved either by always using the same mutex whenever a particular condition variable is used or by using separate condition variables, depending on how the code is expected to work. This compliant solution uses the \u20ac\u0153same-mutex\u20ac\u009d solution:\n#include <stdio.h>\n#include <pthread.h>\n  pthread_mutex_t mutex1; /* Initialized as PTHREAD_MUTEX_ERRORCHECK */\npthread_cond_t cv;\nint count1 = 0, count2 = 0;\n#define COUNT_LIMIT 5\n void *waiter1() {\n  int ret;\n  while (count1 < COUNT_LIMIT) {\n    if ((ret = pthread_mutex_lock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n     if ((ret = pthread_cond_wait(&cv, &mutex1)) != 0) {\n      /* Handle error */\n    }\n     printf(\"count1 = %d\\n\", ++count1);\n     if ((ret = pthread_mutex_unlock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n  }\n   return NULL;\n}\n void *waiter2() {\n  int ret;\n  while (count2 < COUNT_LIMIT) {\n    if ((ret = pthread_mutex_lock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n     if ((ret = pthread_cond_wait(&cv, &mutex1)) != 0) {\n      /* Handle error */\n    }\n     printf(\"count2 = %d\\n\", ++count2);\n     if ((ret = pthread_mutex_unlock(&mutex1)) != 0) {\n      /* Handle error */\n    }\n  }\n   return NULL;\n}\nRisk Assessment\nWaiting on the same condition variable with two different mutexes could cause a thread to be signaled and resume execution with the wrong mutex locked. It could lead to unexpected program behavior if the same shared data were simultaneously accessed by two threads.\nThe severity is medium because improperly accessing shared data could lead to data integrity violation. Likelihood is probable because in such an implementation, an error code would not be returned, and remediation cost is high because detection and correction of this problem are both manual.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS53-C\nMedium\nProbable\nYes\nNo\nP8\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nHelix QAC\n2025.2\nC1769\nC++1769\n\nParasoft C/C++test\n2024.2\nCERT_C-POS53-a\nDo not use more than one mutex for concurrent waiting operations on a condition variable\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS53-C Checks for multiple mutexes used with same conditional variable (rule fully covered)\n\nBibliography\n[Open Group 2004] pthread_cond_timedwait()/pthread_cond_wait()",
        "language": "C"
    },
    {
        "rule_id": "WIN01-C",
        "rule_title": "Do not forcibly terminate execution",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/WIN01-C.+Do+not+forcibly+terminate+execution",
        "content": "When a thread terminates under normal conditions, thread-specific resources such as the initial stack space and thread-specific HANDLE objects are released automatically by the system and notifications are sent to other parts of the application, such as DLL_THREAD_DETACH messages being sent to DLLs.  However, if a thread is forcibly terminated by calling TerminateThread(), the cleanup and notifications do not have the chance to run.  MSDN states\nTerminateThread is a dangerous function that should only be used in the most extreme cases. You should call TerminateThread only if you know exactly what the target thread is doing, and you control all of the code that the target thread could possibly be running at the time of the termination. For example, TerminateThread can result in the following problems:\nIf the target thread owns a critical section, the critical section will not be released.\nIf the target thread is allocating memory from the heap, the heap lock will not be released.\nIf the target thread is executing certain kernel32 calls when it is terminated, the kernel32 state for the thread's process could be inconsistent.\nIf the target thread is manipulating the global state of a shared DLL, the state of the DLL could be destroyed, affecting other users of the DLL.\n On some platforms (such as Microsoft Windows XP and Microsoft Windows Server 2003), the thread's initial stack is not freed, causing a resource leak.\nProcesses behave similar to threads, and so share the same concerns.  Do not use the TerminateThread() or TerminateProcess() APIs.  Instead, you should prefer to exit threads and processes by returning from the entrypoint, by calling ExitThread(), or by calling ExitProcess().\nNoncompliant Code Example\nIn the following example, TerminateThread() is used to forcibly terminate another thread, which can leak resources and leave the application in an indeterminate state.\n#include <Windows.h>\n  DWORD ThreadID;  /* Filled in by call to CreateThread */\n  /* Thread 1 */\nDWORD WINAPI ThreadProc(LPVOID param) {\n  /* Performing work */\n}\n  /* Thread 2 */\nHANDLE hThread = OpenThread(THREAD_TERMINATE, FALSE, ThreadID);\nif (hThread) {\n  TerminateThread(hThread, 0xFF);\n  CloseHandle(hThread);\n}\n Compliant Solution\nThe compliant solution avoids calling TerminateThread() by requesting the thread terminate itself by exiting its entrypoint.  It does so in a lock-free, thread-safe manner by using the InterlockedCompareExchange() and InterlockedExchange() Win32 APIs.\n#include <Windows.h>\n  DWORD ThreadID;  /* Filled in by call to CreateThread */\nLONG ShouldThreadExit = 0;\n /* Thread 1 */\nDWORD WINAPI ThreadProc(LPVOID param) {\n  while (1) {\n    /* Performing work */\n    if (1 == InterlockedCompareExchange(&ShouldThreadExit, 0, 1))\n      return 0xFF;\n  }\n}\n  /* Thread 2 */\nInterlockedExchange(&ShouldThreadExit, 1);\nRisk Assessment\nIncorrectly using threads that asynchronously cancel may result in silent corruption, resource leaks, and, in the worst case, unpredictable interactions.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nWIN01-C\nHigh\nLikely\nYes\nNo\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nbad-function\nPartially checked\nCodeSonar\n9.1p0\n(customization)\nUsers can add a custom check for all uses of  TerminateThread() and TerminateProcess().\nPC-lint Plus\n1.4\n586\nFully supported\nRuleChecker\n24.04\nbad-function\nPartially checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nTODO (notably, should be one about using ExitThread() from C++ code.\nBibliography",
        "language": "C"
    },
    {
        "rule_id": "MSC30-C",
        "rule_title": "Do not use the rand() function for generating pseudorandom numbers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC30-C.+Do+not+use+the+rand%28%29+function+for+generating+pseudorandom+numbers",
        "content": "Pseudorandom number generators use mathematical algorithms to produce a sequence of numbers with good statistical properties, but the numbers produced are not genuinely random.\nThe C Standard rand() function makes no guarantees as to the quality of the random sequence produced. The numbers generated by some implementations of rand() have a comparatively short cycle and the numbers can be predictable. Applications that have strong pseudorandom number requirements must use a generator that is known to be sufficient for their needs.\nNoncompliant Code Example\nThe following noncompliant code generates an ID with a numeric part produced by calling the rand() function. The IDs produced are predictable and have limited randomness.\n#include <stdio.h>\n#include <stdlib.h>\n  enum { len = 12 };\n  void func(void) {\n  /*\n   * id will hold the ID, starting with the characters\n   *  \"ID\" followed by a random integer.\n   */\n  char id[len]; \n  int r;\n  int num;\n  /* ... */\n  r = rand();  /* Generate a random integer */\n  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */\n  /* ... */\n}\nCompliant Solution (POSIX)\nThis compliant solution replaces the rand() function with the POSIX random() function:\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n enum { len = 12 }; \n void func(void) {\n  /*\n   * id will hold the ID, starting with the characters\n   *  \"ID\" followed by a random integer.\n   */\n  char id[len]; \n  int r;\n  int num;\n  /* ... */\n  struct timespec ts;\n  if (timespec_get(&ts, TIME_UTC) == 0) {\n    /* Handle error */\n  }\n  srandom(ts.tv_nsec ^ ts.tv_sec);  /* Seed the PRNG */\n  /* ... */\n  r = random();  /* Generate a random integer */\n  num = snprintf(id, len, \"ID%-d\", r);  /* Generate the ID */\n  /* ... */\n}\nThe POSIX random() function is a better pseudorandom number generator. Although on some platforms the low dozen bits generated by rand() go through a cyclic pattern, all the bits generated by random() are usable. The rand48 family of functions provides another alternative for pseudorandom numbers.\nAlthough not specified by POSIX, arc4random() is another possibility for systems that support it. The arc4random(3) manual page [OpenBSD] states\n... provides higher quality of data than those described in rand(3), random(3), and drand48(3).\nTo achieve the best random numbers possible, an implementation-specific function must be used. When unpredictability is crucial and speed is not an issue, as in the creation of strong cryptographic keys, use a true entropy source, such as /dev/random, or a hardware device capable of generating random numbers. The /dev/random device can block for a long time if there are not enough events going on to generate sufficient entropy.\nCompliant Solution (Windows)\nOn Windows platforms, the BCryptGenRandom() function can be used to generate cryptographically strong random numbers. The Microsoft Developer Network BCryptGenRandom() reference [MSDN] states:\nThe default random number provider implements an algorithm for generating random numbers that complies with the NIST SP800-90 standard, specifically the CTR_DRBG portion of that standard.\n#include <Windows.h>\n#include <bcrypt.h>\n#include <stdio.h>\n #pragma comment(lib, \"Bcrypt\")\n void func(void) {\n  BCRYPT_ALG_HANDLE Prov;\n  int Buffer;\n  if (!BCRYPT_SUCCESS(\n          BCryptOpenAlgorithmProvider(&Prov, BCRYPT_RNG_ALGORITHM,\n                                      NULL, 0))) {\n    /* handle error */\n  }\n  if (!BCRYPT_SUCCESS(BCryptGenRandom(Prov, (PUCHAR) (&Buffer),\n                                      sizeof(Buffer), 0))) {\n    /* handle error */\n  }\n  printf(\"Random number: %d\\n\", Buffer);\n  BCryptCloseAlgorithmProvider(Prov, 0);\n}\nRisk Assessment\nThe use of the rand() function can result in predictable random numbers.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC30-C\nMedium\nUnlikely\nYes\nNo\nP4\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nstdlib-use-rand Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-MSC30\nClang\n4.0 (prerelease)\ncert-msc30-c Checked by clang-tidy\nCodeSonar\n9.1p0\nBADFUNC.RANDOM.RAND Use of rand\nCompass/ROSE\n\n\n\nCoverity\n2017.07\nDONTCALL\nImplemented - weak support\nCppcheck Premium\n24.11.0\npremium-cert-msc30-c\nECLAIR\n1.2\nCC2.MSC30\nFully implemented\nHelix QAC\n2025.2\nC5022\nC++5029\n\nKlocwork\n2025.2\nCERT.MSC.STD_RAND_CALL\n\nLDRA tool suite\n9.7.1\n44 S Enhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-MSC30-a\nDo not use the rand() function for generating pseudorandom numbers\nPC-lint Plus\n1.4\n586\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MSC30-C Checks for vulnerable pseudo-random number generator (rule fully covered)\n\nRuleChecker\n24.04\nstdlib-use-rand Fully checked\nSecurity Reviewer - Static Reviewer\n6.02\nRTOS_07 Fully implemented\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C MSC50-CPP. Do not use std::rand() for generating pseudorandom numbers Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT Oracle Secure Coding Standard for Java MSC02-J. Generate strong random numbers Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-327, Use of a Broken or Risky Cryptographic Algorithm 2017-05-16: CERT: Rule subset of CWE\nCWE 2.11 CWE-330, Use of Insufficiently Random Values 2017-06-28: CERT: Rule subset of CWE\nCWE 2.11 CWE-338, Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG) 2017-06-28: CERT: Rule subset of CWE\nCWE 2.11 CWE-676 2017-05-18: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-327 and MSC30-C\n\nCWE-327 forbids \u201cbroken or risky cryptographic algorithms\u201d but does not specify what constitutes such an algo.\n\n\nPer CERT judgement, rand() qualifies, so:\n\n\nCWE-327 = Union( MSC30-C, list) where list =\n\n\nInvocation of broken/risky crypto algorithms besides rand()\n\nCWE-338 and MSC30-C\nCWE-338 = Union( MSC30-C, list) where list =\n\nUse of a weak PRNG besides standard C rand().\n\nCWE-330 and MSC30-C\nIndependent( MSC30-C, MSC32-C, CON33-C)\nCWE-330 = Union( MSC30-C, MSC32-C, CON33-C, list) where list = other improper use or creation of random values. (EG the would qualify)\nMSC30-C, MSC32-C and CON33-C are independent, they have no intersections. They each specify distinct errors regarding PRNGs.\nCWE-676 and MSC30-C\n\nIndependent( ENV33-C, CON33-C, STR31-C, EXP33-C, MSC30-C, ERR34-C)\n\n\nMSC30-C implies that rand() is dangerous.\n\n\nCWE-676 = Union( MSC30-C, list) where list =\n\n\nInvocation of other dangerous functions, besides rand().\n\nBibliography\n[MSDN]\n\"BCryptGenRandom() Function\"\n[OpenBSD] arc4random()",
        "language": "C"
    },
    {
        "rule_id": "MSC32-C",
        "rule_title": "Properly seed pseudorandom number generators",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC32-C.+Properly+seed+pseudorandom+number+generators",
        "content": "A pseudorandom number generator (PRNG) is a deterministic algorithm capable of generating sequences of numbers that approximate the properties of random numbers. Each sequence is completely determined by the initial state of the PRNG and the algorithm for changing the state. Most PRNGs make it possible to set the initial state, also called the seed state. Setting the initial state is called seeding the PRNG.\nCalling a PRNG in the same initial state, either without seeding it explicitly or by seeding it with the same value, results in generating the same sequence of random numbers in different runs of the program. Consider a PRNG function that is seeded with some initial seed value and is consecutively called to produce a sequence of random numbers, S. If the PRNG is subsequently seeded with the same initial seed value, then it will generate the same sequence S.\nAs a result, after the first run of an improperly seeded PRNG, an attacker can predict the sequence of random numbers that will be generated in the future runs. Improperly seeding or failing to seed the PRNG can lead to vulnerabilities, especially in security protocols.\nThe solution is to ensure that the PRNG is always properly seeded. A properly seeded PRNG will generate a different sequence of random numbers each time it is run.\nNot all random number generators can be seeded. True random number generators that rely on hardware to produce completely unpredictable results do not need to be and cannot be seeded. Some high-quality PRNGs, such as the /dev/random device on some UNIX systems, also cannot be seeded. This rule applies only to algorithmic pseudorandom number generators that can be seeded.\nNoncompliant Code Example (POSIX)\nThis noncompliant code example generates a sequence of 10 pseudorandom numbers using the random() function. When random() is not seeded, it behaves like rand(), producing the same sequence of random numbers each time any program that uses it is run.\n#include <stdio.h>\n#include <stdlib.h>\n  void func(void) {\n  for (unsigned int i = 0; i < 10; ++i) {\n    /* Always generates the same sequence */\n    printf(\"%ld, \", random());\n  }\n}\nThe output is as follows:\n1st run: 1804289383, 846930886, 1681692777, 1714636915, 1957747793, 424238335, 719885386, 1649760492, 596516649,\n         1189641421,\n2nd run: 1804289383, 846930886, 1681692777, 1714636915, 1957747793, 424238335, 719885386, 1649760492, 596516649,\n         1189641421,\n...\nnth run: 1804289383, 846930886, 1681692777, 1714636915, 1957747793, 424238335, 719885386, 1649760492, 596516649,\n         1189641421,\nCompliant Solution (POSIX)\nCall srandom() before invoking random() to seed the random sequence generated by random(). This compliant solution produces different random number sequences each time the function is called, depending on the resolution of the system clock:\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n  void func(void) {\n  struct timespec ts;\n  if (timespec_get(&ts, TIME_UTC) == 0) {\n    /* Handle error */\n  } else {\n    srandom(ts.tv_nsec ^ ts.tv_sec);\n    for (unsigned int i = 0; i < 10; ++i) {\n      /* Generates different sequences at different runs */\n      printf(\"%ld, \", random());\n    }\n  }\n}\nThe output is as follows:\n1st run: 198682410, 2076262355, 910374899, 428635843, 2084827500, 1558698420, 4459146, 733695321, 2044378618, 1649046624,\n2nd run: 1127071427, 252907983, 1358798372, 2101446505, 1514711759, 229790273, 954268511, 1116446419, 368192457,\n         1297948050,\n3rd run: 2052868434, 1645663878, 731874735, 1624006793, 938447420, 1046134947, 1901136083, 418123888, 836428296,\n         2017467418,\nThis may not be sufficiently random for concurrent execution, which may lead to correlated generated series in different threads. Depending on the application and the desired level of security, a programmer may choose alternative ways to seed PRNGs. In general, hardware is more capable than software of generating real random numbers (for example, by sampling the thermal noise of a diode).\nCompliant Solution (Windows)\nThe BCryptGenRandom() function does not run the risk of not being properly seeded because its arguments serve as seeders:\n#include <stdio.h>\n#include <Windows.h>\n#include <Bcrypt.h>\n#include <Ntstatus.h>\n#include <Wincrypt.h>\n void func(void) {\n  BCRYPT_ALG_HANDLE hAlgorithm = NULL;\n  long rand_buf;\n  PUCHAR pbBuffer = (PUCHAR) &rand_buf;\n  ULONG cbBuffer = sizeof(rand_buf);\n  ULONG dwFlags = BCRYPT_USE_SYSTEM_PREFERRED_RNG;\n  NTSTATUS status;\n  for (unsigned int i = 0; i < 10; ++i) {\n    status = BCryptGenRandom(hAlgorithm, pbBuffer, cbBuffer, dwFlags);\n    if (status == STATUS_SUCCESS) {\n      printf(\"%ld, \", rand_buf);\n    } else {\n      /* Handle Error */\n    }\n  }\n}\nThe output is as follows:\n1st run: -683378946, 1957231690, 1933176011, -1745403355, -883473417, 882992405, 169629816, 1824800038, 899851668, 1702784647,\n2nd run: -58750553, -1921870721, -1973269161, 1512649964, -673518452, 234003619, -1622633366, 1312389688, -2125631172, 2067680022,\n3rd run: -189899579, 1220698973, 752205360, -1826365616, 79310867, 1430950090, -283206168, -941773185, 129633665, 543448789,\nRisk Assessment\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC32-C\nMedium\nLikely\nYes\nYes\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nAxivion Bauhaus Suite\n7.2.0\nCertC-MSC32\nCodeSonar\n9.1p0\nHARDCODED.SEED\nMISC.CRYPTO.TIMESEED\nHardcoded Seed in PRNG\nPredictable Seed in PRNG\nCppcheck Premium\n24.11.0\npremium-cert-msc32-c\nHelix QAC\n2025.2\nC5031\nC++5036\n\nKlocwork\n2025.2\nCERT.MSC.SEED_RANDOM\n\nPC-lint Plus\n1.4\n2460, 2461, 2760\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MSC32-C\n\nChecks for:\nDeterministic random output from constant seed\nPredictable random output from predictable seed\nRule fully covered.\nParasoft C/C++test\n2024.2\nCERT_C-MSC32-d\nProperly seed pseudorandom number generators\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard MSC30-C. Do not use the rand() function for generating pseudorandom numbers Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C MSC51-CPP. Ensure your random number generator is properly seeded Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-327, Use of a Broken or Risky Cryptographic Algorithm 2017-05-16: CERT: Rule subset of CWE\nCWE 2.11 CWE-330, Use of Insufficiently Random Values 2017-06-28: CERT: Rule subset of CWE\nCWE 2.11 CWE-331, Insufficient Entropy 2017-06-28: CERT: Exact\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-327 and MSC32-C\n\nIntersection( MSC30-C, MSC32-C) = \u00d8\n\n\nMSC32-C says to properly seed pseudorandom number generators. For example, if you call rand(), make sure to seed it properly by calling srand() first. So far, we haven\u2019t found any calls to rand().\n\n\nFailure to seed a PRNG causes it to produce reproducible (hence insecure) series of random numbers.\n\n\nCWE-327 = Union( MSC32-C, list) where list =\n\n\nInvocation of broken/risky crypto algorithms that are not properly seeded\n\n\n\nCWE-330 and MSC32-C\nIndependent( MSC30-C, MSC32-C, CON33-C)\nCWE-330 = Union( MSC30-C, MSC32-C, CON33-C, list) where list = other improper use or creation of random values. (EG the would qualify)\nMSC30-C, MSC32-C and CON33-C are independent, they have no intersections. They each specify distinct errors regarding PRNGs.\nBibliography\n[MSDN]\n\"BCryptGenRandom() Function\"",
        "language": "C"
    },
    {
        "rule_id": "MSC33-C",
        "rule_title": "Do not pass invalid data to the asctime() function",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC33-C.+Do+not+pass+invalid+data+to+the+asctime%28%29+function",
        "content": "The C Standard, 7.29.3.1 [ISO/IEC 9899:2024], provides the following sample implementation of the asctime() function:\nchar *asctime(const struct tm *timeptr) {\n  static const char wday_name[7][3] = {\n    \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"\n  };\n  static const char mon_name[12][3] = {\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n    \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n  };\n  static char result[26];\n  sprintf(\n    result,\n    \"%.3s %.3s%3d %.2d:%.2d:%.2d %d\\n\",\n    wday_name[timeptr->tm_wday],\n    mon_name[timeptr->tm_mon],\n    timeptr->tm_mday, timeptr->tm_hour,\n    timeptr->tm_min, timeptr->tm_sec,\n    1900 + timeptr->tm_year\n  );\n  return result;\n}\nThis function is supposed to output a character string of 26 characters at most, including the terminating null character. If we count the length indicated by the format directives, we arrive at 25. Taking into account the terminating null character, the array size of the string appears sufficient.\nHowever, this implementation assumes that the values of the struct tm data are within normal ranges and does nothing to enforce the range limit. If any of the values print more characters than expected, the sprintf() function may overflow the result array. For example, if tm_year has the value 12345, then 27 characters (including the terminating null character) are printed, resulting in a buffer overflow.\nThe POSIX\u00ae Base Specifications [IEEE Std 1003.1:2013] says the following about the asctime() and asctime_r() functions:\nThese functions are included only for compatibility with older implementations. They have undefined behavior if the resulting string would be too long, so the use of these functions should be discouraged. On implementations that do not detect output string length overflow, it is possible to overflow the output buffers in such a way as to cause applications to fail, or possible system security violations. Also, these functions do not support localized date and time formats. To avoid these problems, applications should use strftime() to generate strings from broken-down times.\nThe asctime() function appears in the list of obsolescent functions in MSC24-C. Do not use deprecated or obsolescent functions.\nNoncompliant Code Example\nThis noncompliant code example invokes the asctime() function with potentially unsanitized data:\n#include <time.h>\n  void func(struct tm *time_tm) {\n  char *time = asctime(time_tm);\n  /* ... */\n}\nCompliant Solution (strftime())\nThe strftime() function allows the programmer to specify a more rigorous format and also to specify the maximum size of the resulting time string:\n#include <time.h>\n enum { maxsize = 26 };\n  void func(struct tm *time) {\n  char s[maxsize];\n  /* Current time representation for locale */\n  const char *format = \"%c\";\n   size_t size = strftime(s, maxsize, format, time);\n}\nThis call has the same effects as asctime() but also ensures that no more than maxsize characters are printed, preventing buffer overflow.\nRisk Assessment\nOn implementations that do not detect output-string-length overflow, it is possible to overflow the output buffers.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC33-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nAxivion Bauhaus Suite\n7.2.0\nCertC-MSC33\nCodeSonar\n9.1p0\nBADFUNC.TIME_H\nUse of <time.h> Time/Date Function\nCppcheck Premium\n24.11.0\npremium-cert-msc33-c\nHelix QAC\n2025.2\nC5032\nC++5030\n\nKlocwork\n2025.2\nCERT.MSC.ASCTIME\n\nLDRA tool suite\n9.7.1\n44 S Enhanced Enforcement\nParasoft C/C++test\n2024.2\nCERT_C-MSC33-a\nThe 'asctime()' and 'asctime_r()' functions should not be used\nPC-lint Plus\n1.4\n586\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MSC33-C Checks for use of obsolete standard function (rule partially covered)\n\nRuleChecker\n24.04\n\nSupported, but no explicit checker\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard MSC24-C. Do not use deprecated or obsolescent functions Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\n[IEEE Std 1003.1:2013] XSH, System Interfaces, asctime\n[ISO/IEC 9899:2024] 7.29.3.1, \"The asctime Function\"",
        "language": "C"
    },
    {
        "rule_id": "MSC37-C",
        "rule_title": "Ensure that control never reaches the end of a non-void function",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC37-C.+Ensure+that+control+never+reaches+the+end+of+a+non-void+function",
        "content": "If control reaches the closing curly brace (}) of a non-void function without evaluating a return statement, using the return value of the function call is undefined behavior. (See undefined behavior 86.)\nNoncompliant Code Example\nIn this noncompliant code example, control reaches the end of the checkpass() function when the two strings passed to strcmp() are not equal, resulting in undefined behavior. Many compilers will generate code for the checkpass() function, returning various values along the execution path where no return statement is defined.\n#include <string.h>\n#include <stdio.h>\n  int checkpass(const char *password) {\n  if (strcmp(password, \"pass\") == 0) {\n    return 1;\n  }\n}\n void func(const char *userinput) {\n  if (checkpass(userinput)) {\n    printf(\"Success\\n\");\n  }\n}\nThis error is frequently diagnosed by compilers. (See MSC00-C. Compile cleanly at high warning levels.)\nCompliant Solution\nThis compliant solution ensures that the checkpass() function always returns a value:\n#include <string.h>\n#include <stdio.h>\n  int checkpass(const char *password) {\n  if (strcmp(password, \"pass\") == 0) {\n    return 1;\n  }\n  return 0;\n}\n void func(const char *userinput) {\n  if (checkpass(userinput)) {\n    printf(\"Success!\\n\");\n  }\n}\nNoncompliant Code Example\nIn this noncompliant code example, control reaches the end of the getlen() function when input does not contain the integer delim. Because the potentially undefined return value of getlen() is later used as an index into an array, a buffer overflow may occur.\n#include <stddef.h>\n  size_t getlen(const int *input, size_t maxlen, int delim) {\n  for (size_t i = 0; i < maxlen; ++i) {\n    if (input[i] == delim) {\n      return i;\n    }\n  }\n}\n  void func(int userdata) {\n  size_t i;\n  int data[] = { 1, 1, 1 };\n  i = getlen(data, sizeof(data), 0);\n  data[i] = userdata;\n}\nImplementation Details (GCC)\nViolating this rule can have unexpected consequences, as in the following example:\n#include <stdio.h>\n size_t getlen(const int *input, size_t maxlen, int delim) {\n  for (size_t i = 0; i < maxlen; ++i) {\n    if (input[i] == delim) {\n      return i;\n    }\n  }\n}\n int main(int argc, char **argv) {\n  size_t i;\n  int data[] = { 1, 1, 1 };\n   i = getlen(data, sizeof(data), 0);\n  printf(\"Returned: %zu\\n\", i);\n  data[i] = 0;\n   return 0;\n}\nWhen this program is compiled with -Wall on most versions of the GCC compiler, the following warning is generated:\nexample.c: In function 'getlen':\nexample.c:12: warning: control reaches end of non-void function\nNone of the inputs to the function equal the delimiter, so when run with GCC 5.3 on Linux, control reaches the end of the getlen() function, which is undefined behavior and in this test returns 3, causing an out-of-bounds write to the data array.\nCompliant Solution\nThis compliant solution changes the interface of getlen() to store the result in a user-provided pointer and returns a status indicator to report success or failure. The best method for handling this type of error is specific to the application and the type of error. (See ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy for more on error handling.)\n#include <stddef.h>\n  int getlen(const int *input, size_t maxlen, int delim,\n           size_t *result) {\n  if (result == NULL) {\n    return -1;\n  }\n  for (size_t i = 0; i < maxlen; ++i) {\n    if (input[i] == delim) {\n      *result = i;\n      return 0;\n    }\n  }\n  return -1;\n}\n void func(int userdata) {\n  size_t i;\n  int data[] = {1, 1, 1};\n  if (getlen(data, sizeof(data), 0, &i) != 0) {\n    /* Handle error */\n  } else {\n    data[i] = userdata;\n  }\n}\nExceptions\nMSC37-C-EX1: According to the C Standard, 5.1.2.3.4, paragraph 1 [ISO/IEC 9899:2024], \"Reaching the } that terminates the main function returns a value of 0.\" As a result, it is permissible for control to reach the end of the main() function without executing a return statement.\nMSC37-C-EX2: It is permissible for a control path to not return a value if that code path is never taken and a function marked _Noreturn is called as part of that code path. For example:\n#include <stdio.h>\n#include <stdlib.h>\n  _Noreturn void unreachable(const char *msg) {\n  printf(\"Unreachable code reached: %s\\n\", msg);\n  exit(1);\n}\n enum E {\n  One,\n  Two,\n  Three\n};\n  int f(enum E e) {\n  switch (e) {\n  case One: return 1;\n  case Two: return 2;\n  case Three: return 3;\n  }\n  unreachable(\"Can never get here\");\n}\nRisk Assessment\nUsing the return value from a non-void function where control reaches the end of the function without evaluating a return statement can lead to buffer overflow vulnerabilities as well as other unexpected program behaviors.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC37-C\nHigh\nUnlikely\nYes\nNo\nP6\nL2\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nreturn-implicit Fully checked\nAxivion Bauhaus Suite\n7.2.0\nCertC-MSC37\nCodeSonar\n9.1p0\nLANG.STRUCT.MRS Missing return statement\nCoverity\n2017.07\nMISSING_RETURN\nImplemented\nCppcheck\n 2.15\nmissingReturn\nCppcheck Premium\n24.11.0\nmissingReturn\nHelix QAC\n2025.2\nC++4022\nDF2888\n\nKlocwork\n2025.2\nFUNCRET.GEN\nFUNCRET.IMPLICIT\nLDRA tool suite\n9.7.1\n2 D, 36 S, 66 S Fully implemented\nParasoft C/C++test\n2024.2\nCERT_C-MSC37-a\nAll exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression\nPC-lint Plus\n1.4\n533\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MSC37-C Checks for missing return statement (rule fully covered)\n\nRuleChecker\n24.04\nreturn-implicit Fully checked\nSecurity Reviewer - Static Reviewer\n6.02\nRTOS_09 Fully implemented\nSonarQube C/C++ Plugin\n3.11\nS935\nTrustInSoft Analyzer\n1.38\nBody of function falls-through Exhaustively verified.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard MSC01-C. Strive for logical completeness Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-758 2017-07-07: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-758 and MSC37-C\nIndependent( INT34-C, INT36-C, MEM30-C, MSC37-C, FLP32-C, EXP33-C, EXP30-C, ERR34-C, ARR32-C)\nCWE-758 = Union( MSC37-C, list) where list =\nUndefined behavior that results from anything other than failing to return a value from a function that expects one\nBibliography\n[ISO/IEC 9899:2024] 5.1.2.3.4, \"Program Termination\"",
        "language": "C"
    },
    {
        "rule_id": "MSC38-C",
        "rule_title": "Do not treat a predefined identifier as an object if it might only be implemented as a macro",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC38-C.+Do+not+treat+a+predefined+identifier+as+an+object+if+it+might+only+be+implemented+as+a+macro",
        "content": "The C Standard, 7.1.4 paragraph 1, [ISO/IEC 9899:2024] states\nAny function declared in a header may be additionally implemented as a function-like macro defined in the header, so if a library function is declared explicitly when its header is included, one of the techniques shown later in the next subclause can be used to ensure the declaration is not affected by such a macro. Any macro definition of a function can be suppressed locally by enclosing the name of the function in parentheses, because the name is then not followed by the left parenthesis that indicates expansion of a macro function name. For the same syntactic reason, it is permitted to take the address of a library function even if it is also defined as a macro. 220) The use of #undef to remove any macro definition will also ensure that an actual function is referred to.\n220)This means that an implementation is required to provide an actual function for each library function, even if it also provides a macro for that function.\n However, the C Standard enumerates specific exceptions in which the behavior of accessing an object or function expanded to be a standard library macro definition is undefined. The macros are assert, errno, math_errhandling, setjmp, va_arg, va_copy, va_end, and va_start. These cases are described by undefined behaviors 138, 139, 140, 141, and 143. Programmers must not suppress these macros to access the underlying object or function.\nNoncompliant Code Example (assert)\nIn this noncompliant code example, the standard assert() macro is suppressed in an attempt to pass it as a function pointer to the  execute_handler() function. Attempting to suppress the assert() macro is undefined behavior.\n#include <assert.h>\n  typedef void (*handler_type)(int);\n  void execute_handler(handler_type handler, int value) {\n  handler(value);\n}\n  void func(int e) {\n  execute_handler(&(assert), e < 0);\n} \nCompliant Solution (assert)\nIn this compliant solution, the assert() macro is wrapped in a helper function, removing the undefined behavior:\n#include <assert.h>\n  typedef void (*handler_type)(int);\n  void execute_handler(handler_type handler, int value) {\n  handler(value);\n}\n  static void assert_handler(int value) {\n  assert(value);\n}\n  void func(int e) {\n  execute_handler(&assert_handler, e < 0);\n}\nNoncompliant Code Example (Redefining errno)\nLegacy code is apt to include an incorrect declaration, such as the following in this noncompliant code example:\nextern int errno;\nCompliant Solution (Declaring errno)\nThis compliant solution demonstrates the correct way to declare errno by including the header <errno.h>:\n#include <errno.h>\nC-conforming implementations are required to declare errno in <errno.h>, although some historic implementations failed to do so.\nRisk Assessment\nAccessing objects or functions underlying the specific macros enumerated in this rule is undefined behavior.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC38-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported, but no explicit checker\nCodeSonar\n9.1p0\nBADMACRO.STDARG_H\nUse of <stdarg.h> Feature\nCppcheck Premium\n24.11.0\npremium-cert-msc38-c\nHelix QAC\n2025.2\nC3437, C3475\nC++3127, C++5039\n\nParasoft C/C++test\n2024.2\nCERT_C-MSC38-a\n A function-like macro shall not be invoked without all of its arguments\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MSC38-C Checks for predefined macro used as an object (rule fully covered)\nRuleChecker\n24.04\n\nSupported, but no explicit checker\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C DCL37-C. Do not declare or define a reserved identifier Prior to 2018-01-12: CERT: Unspecified Relationship\nBibliography\nISO/IEC 9899:2024 7.1.4, \"Use of Library Functions\"",
        "language": "C"
    },
    {
        "rule_id": "MSC39-C",
        "rule_title": "Do not call va_arg() on a va_list that has an indeterminate value",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC39-C.+Do+not+call+va_arg%28%29+on+a+va_list+that+has+an+indeterminate+value",
        "content": "Variadic functions access their variable arguments by using va_start() to initialize an object of type va_list, iteratively invoking the va_arg() macro, and finally calling va_end(). The va_list may be passed as an argument to another function, but calling va_arg() within that function causes the va_list to have an indeterminate value in the calling function. As a result, attempting to read variable arguments without reinitializing the va_list can have unexpected behavior. According to the C Standard, 7.16, paragraph 3 [ISO/IEC 9899:2024],\nIf access to the varying arguments is desired, the called function shall declare an object (generally referred to as ap in this subclause) having type va_list. The object ap may be passed as an argument to another function; if that function invokes the va_arg macro with parameter ap, the representation of ap in the calling function is indeterminate and shall be passed to the va_end macro prior to any further reference to ap.\n295) A pointer to a va_list can be created and passed to another function, in which case the original function can make further use of the original list after the other function returns.\nNoncompliant Code Example\nThis noncompliant code example attempts to check that none of its variable arguments are zero by passing a va_list to helper function contains_zero(). After the call to contains_zero(), the value of ap is indeterminate.\n#include <stdarg.h>\n#include <stdio.h>\n \nint contains_zero(size_t count, va_list ap) {\n  for (size_t i = 1; i < count; ++i) {\n    if (va_arg(ap, double) == 0.0) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint print_reciprocals(size_t count, ...) {\n  va_list ap;  \n  va_start(ap, count);\n\n  if (contains_zero(count, ap)) {\n    va_end(ap);\n    return 1;\n  }\n\n  for (size_t i = 0; i < count; ++i) {\n    printf(\"%f \", 1.0 / va_arg(ap, double));\n  }\n\n  va_end(ap);\n  return 0;\n}\nCompliant Solution\nThe compliant solution modifies contains_zero() to take a pointer to a va_list. It then uses the va_copy macro to make a copy of the list, traverses the copy, and cleans it up. Consequently, the print_reciprocals() function is free to traverse the original va_list.\n#include <stdarg.h>\n#include <stdio.h>\n \nint contains_zero(size_t count, va_list *ap) {\n  va_list ap1;\n  va_copy(ap1, *ap);\n  for (size_t i = 1; i < count; ++i) {\n    if (va_arg(ap1, double) == 0.0) {\n      return 1;\n    }\n  }\n  va_end(ap1);\n  return 0;\n}\n \nint print_reciprocals(size_t count, ...) {\n  int status;\n  va_list ap;\n  va_start(ap, count);\n \n  if (contains_zero(count, &ap)) {\n    printf(\"0 in arguments!\\n\");\n    status = 1;\n  } else {\n    for (size_t i = 0; i < count; i++) {\n      printf(\"%f \", 1.0 / va_arg(ap, double));\n    }\n    printf(\"\\n\");\n    status = 0;\n  }\n \n  va_end(ap);\n  return status;\n}\nRisk Assessment\nReading variable arguments using a va_list that has an indeterminate value can have unexpected results.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC39-C\nLow\nUnlikely\nYes\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADMACRO.STDARG_H\nUse of <stdarg.h> Feature\nCppcheck Premium\n24.11.0\npremium-cert-msc39-c\nHelix QAC\n2025.2\nC3497\nC++3146, C++3147, C++3148, C++3149, C++3167\n\nKlocwork\n2025.2\nVA.LIST.INDETERMINATE\nParasoft C/C++test\n2024.2\nCERT_C-MSC39-a\nUse macros for variable arguments correctly\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MSC39-C\nChecks for:\nInvalid va_list argument\nToo many va_arg calls for current argument list\nRule partially covered.\nSecurity Reviewer - Static Reviewer\n6.02\nRTOS_13 Fully implemented\nTrustInSoft Analyzer\n1.38\nvariadic Exhaustively verified.\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2024] Subclause 7.16, \"Variable Arguments <stdarg.h>\"",
        "language": "C"
    },
    {
        "rule_id": "MSC40-C",
        "rule_title": "Do not violate constraints",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC40-C.+Do+not+violate+constraints",
        "content": "According to the C Standard, 3.8 [ISO/IEC 9899:2011], a constraint is a \"restriction, either syntactic or semantic, by which the exposition of language elements is to be interpreted.\"  Despite the similarity of the terms, a runtime constraint is not a kind of constraint.\nViolating any shall statement within a constraint clause in the C Standard requires an implementation to issue a diagnostic message, the C Standard, 5.1.1.3 [ISO/IEC 9899:2011] states\nA conforming implementation shall produce at least one diagnostic message (identified in an implementation-defined manner) if a preprocessing translation unit or translation unit contains a violation of any syntax rule or constraint, even if the behavior is also explicitly specified as undefined or implementation-defined. Diagnostic messages need not be produced in other circumstances.\nThe C Standard further explains in a footnote\nThe intent is that an implementation should identify the nature of, and where possible localize, each violation. Of course, an implementation is free to produce any number of diagnostics as long as a valid program is still correctly translated. It may also successfully translate an invalid program.\nAny constraint violation is a violation of this rule because it can result in an invalid program.\nNoncompliant Code Example (Inline, Internal Linkage)\nThe C Standard, 6.7.4, paragraph 3 [ISO/IEC 9899:2011], states\nAn inline definition of a function with external linkage shall not contain a definition of a modifiable object with static or thread storage duration, and shall not contain a reference to an identifier with internal linkage.\nThe motivation behind this constraint lies in the semantics of inline definitions. Paragraph 7 of subclause 6.7.4 reads, in part:\nAn inline definition provides an alternative to an external definition, which a translator may use to implement any call to the function in the same translation unit. It is unspecified whether a call to the function uses the inline definition or the external definition.\nThat is, if a function has an external and inline definition, implementations are free to choose which definition to invoke (two distinct invocations of the function may call different definitions, one the external definition, the other the inline definition). Therefore, issues can arise when these definitions reference internally linked objects or mutable objects with static or thread storage duration.\nThis noncompliant code example refers to a static variable with file scope and internal linkage from within an external inline function:\nstatic int I = 12;\nextern inline void func(int a) {\n  int b = a * I;\n  /* ... */\n}\nCompliant Solution (Inline, Internal Linkage)\nThis compliant solution omits the static qualifier;  consequently,  the variable I has external linkage by default:\nint I = 12;\nextern inline void func(int a) {\n  int b = a * I;\n  /* ... */\n}\nNoncompliant Code Example (inline, Modifiable Static)\nThis noncompliant code example defines a modifiable static variable within an extern inline function.\nextern inline void func(void) {\n  static int I = 12;\n  /* Perform calculations which may modify I */\n}\nCompliant Solution (Inline, Modifiable Static)\nThis compliant solution removes the static keyword from the local variable definition. If the modifications to I must be retained between invocations of func(), it must be declared at file scope so that it will be defined with external linkage.\nextern inline void func(void) {\n  int I = 12;\n  /* Perform calculations which may modify I */\n}\nNoncompliant Code Example (Inline, Modifiable static)\nThis noncompliant code example includes two translation units: file1.c and file2.c. The first file, file1.c, defines a pseudorandom number generation function:\n/* file1.c */\n /* Externally linked definition of the function get_random() */\nextern unsigned int get_random(void) {\n  /* Initialize the seeds */\n  static unsigned int m_z = 0xdeadbeef;\n  static unsigned int m_w = 0xbaddecaf;\n   /* Compute the next pseudorandom value and update the seeds */\n  m_z = 36969 * (m_z & 65535) + (m_z >> 16);\n  m_w = 18000 * (m_w & 65535) + (m_w >> 16);\n  return (m_z << 16) + m_w;\n}\nThe left-shift operation in the last line may wrap, but this is permitted by exception INT30-C-EX3 to rule INT30-C. Ensure that unsigned integer operations do not wrap.\nThe second file, file2.c, defines an inline version of this function that references mutable static objects\u2014namely, objects that maintain the state of the pseudorandom number generator. Separate invocations of the get_random() function can call different definitions, each operating on separate static objects, resulting in a faulty pseudorandom number generator.\n/* file2.c */\n /* Inline definition of get_random function */\ninline unsigned int get_random(void) {\n  /*\n   * Initialize the seeds\n   * Constraint violation: static duration storage referenced\n   * in non-static inline definition\n   */\n  static unsigned int m_z = 0xdeadbeef;\n  static unsigned int m_w = 0xbaddecaf;\n   /* Compute the next pseudorandom value and update the seeds */\n  m_z = 36969 * (m_z & 65535) + (m_z >> 16);\n  m_w = 18000 * (m_w & 65535) + (m_w >> 16);\n  return (m_z << 16) + m_w;\n}\n int main(void) {\n  unsigned int rand_no;\n  for (int ii = 0; ii < 100; ii++) {\n    /*\n     * Get a pseudorandom number. Implementation defined whether the\n     * inline definition in this file or the external definition \n     * in file2.c is called.\n     */\n    rand_no = get_random();\n    /* Use rand_no... */\n  }\n   /* ... */\n   /*\n   * Get another pseudorandom number. Behavior is\n   * implementation defined.\n   */\n  rand_no = get_random();\n  /* Use rand_no... */\n  return 0;\n}\nCompliant Solution (Inline, Modifiable static)\nThis compliant solution adds the static modifier to the inline function definition in file2.c, giving it internal linkage. All references to get_random() in file.2.c will now reference the internally linked definition. The first file, which was not changed, is not shown here.\n/* file2.c */\n /* Static inline definition of get_random function */\nstatic inline unsigned int get_random(void) {\n  /*\n   * Initialize the seeds.\n   * No more constraint violation; the inline function is now\n   * internally linked.\n   */\n  static unsigned int m_z = 0xdeadbeef;\n  static unsigned int m_w = 0xbaddecaf;\n   /* Compute the next pseudorandom value and update the seeds  */\n  m_z = 36969 * (m_z & 65535) + (m_z >> 16);\n  m_w = 18000 * (m_w & 65535) + (m_w >> 16);\n  return (m_z << 16) + m_w;\n}\n int main(void) {\n  /* Generate pseudorandom numbers using get_random()... */\n  return 0;\n}\nRisk Assessment\nConstraint violations are a broad category of error that can result in unexpected control flow and corrupted data.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC40-C\nLow\nUnlikely\nNo\nNo\nP1\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\n Astr\u00e9e\n 24.04\nalignas-extended\nassignment-to-non-modifiable-lvalue\ncast-pointer-void-arithmetic-implicit\nelement-type-incomplete\nfunction-pointer-integer-cast-implicit\nfunction-return-type\ninappropriate-pointer-cast-implicit\nincompatible-function-pointer-conversion\nincompatible-object-pointer-conversion\ninitializer-excess\ninvalid-array-size\nnon-constant-static-assert\nparameter-match-type\npointer-integral-cast-implicit\npointer-qualifier-cast-const-implicit\npointer-qualifier-cast-volatile-implicit\nredeclaration\nreturn-empty\nreturn-non-empty\nstatic-assert\ntype-compatibility\ntype-compatibility-link\ntype-specifier\nundeclared-parameter\nunnamed-parameter\nPartially checked\nCppcheck Premium\n24.11.0\npremium-cert-msc40-c\nHelix QAC\n2025.2\nC0232, C0233, C0244, C0268, C0321, C0322, C0338, C0422, C0423, C0426, C0427, C0429, C0430, C0431, C0432, C0435, C0436, C0437, C0446, C0447, C0448, C0449, C0451, C0452, C0453, C0454, C0456, C0457, C0458, C0460, C0461, C0462, C0463, C0466, C0467, C0468, C0469, C0476, C0477, C0478, C0481, C0482, C0483, C0484, C0485, C0486, C0487, C0493, C0494, C0495, C0496, C0497, C0513, C0514, C0515, C0536, C0537, C0540, C0541, C0542, C0546, C0547, C0550, C0554, C0555, C0556, C0557, C0558, C0559, C0560, C0561, C0562, C0563, C0564, C0565, C0580, C0588, C0589, C0590, C0591, C0605, C0616, C0619, C0620, C0621, C0622, C0627, C0628, C0629, C0631, C0638, C0640, C0641, C0642, C0643, C0644, C0645, C0646, C0649, C0650, C0651, C0653, C0655, C0656, C0657, C0659, C0664, C0665, C0669, C0671, C0673, C0674, C0675, C0677, C0682, C0683, C0684, C0685, C0690, C0698, C0699, C0708, C0709, C0736, C0737, C0738, C0746, C0747, C0755, C0756, C0757, C0758, C0766, C0767, C0768, C0774, C0775, C0801, C0802, C0803, C0804, C0811, C0821, C0834, C0835, C0844, C0845, C0851, C0852, C0866, C0873, C0877, C0940, C0941, C0943, C0944, C1023, C1024, C1025, C1033, C1047, C1048, C1050, C1061, C1062, C3236, C3237, C3238, C3244\nC++4122\n\nKlocwork\n2025.2\nMISRA.FUNC.STATIC.REDECL\n LDRA tool suite\n 9.7.1\n 21 S, 145 S, 323 S, 345 S, 387 S, 404 S, 481 S, 580 S, 612 S, 615 S, 646 S\nParasoft C/C++test\n2024.2\nCERT_C-MSC40-a\nAn inline definition of a function with external linkage shall not contain definitions and uses of static objects\n Polyspace Bug Finder\n R2025b\nCERT C: Rule MSC40-C Checks for inline constraint not respected (rule partially covered)\nRuleChecker\n24.04\nalignas-extended\nassignment-to-non-modifiable-lvalue\ncast-pointer-void-arithmetic-implicit\nelement-type-incomplete\nfunction-pointer-integer-cast-implicit\nfunction-return-type\ninappropriate-pointer-cast-implicit\nincompatible-function-pointer-conversion\nincompatible-object-pointer-conversion\ninitializer-excess\ninvalid-array-size\nnon-constant-static-assert\nparameter-match-type\npointer-integral-cast-implicit\npointer-qualifier-cast-const-implicit\npointer-qualifier-cast-volatile-implicit\nredeclaration\nreturn-empty\nreturn-non-empty\nstatic-assert\ntype-compatibility\ntype-compatibility-link\ntype-specifier\nundeclared-parameter\nunnamed-parameter\nPartially checked\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nBibliography\n[ISO/IEC 9899:2011]\n4, \"Conformance\"\n5.1.1.3, \"Diagnostics\" \n6.7.4, \"Function Specifiers\"",
        "language": "C"
    },
    {
        "rule_id": "MSC41-C",
        "rule_title": "Never hard code sensitive information",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/MSC41-C.+Never+hard+code+sensitive+information",
        "content": "Hard coding sensitive information, such as passwords or encryption keys can expose the information to attackers. Anyone who has access to the executable or dynamic library files can examine them for strings or other critical data, revealing the sensitive information. Leaking data protected by International Traffic in Arms Regulations (ITAR) or the Health Insurance Portability and Accountability Act (HIPAA) can also have legal consequences. Consequently, programs must not hard code sensitive information.\nHard coding sensitive information also increases the need to manage and accommodate changes to the code. For example, changing a hard-coded password in a deployed program may require distribution of a patch [Chess 2007].\nNoncompliant Code Example (Hard-Coded Database Password)\nThis noncompliant code example must authenticate to a remote service with a code, using the authenticate() function declared below. It passes the authentication code to this function as a string literal.\n/* Returns nonzero if authenticated */\nint authenticate(const char* code);\n\nint main() {\n  if (!authenticate(\"correct code\")) {\n    printf(\"Authentication error\\n\");\n    return -1;\n  }\n\n  printf(\"Authentication successful\\n\");\n  // ...Work with system...\n  return 0;\n}\nThe authentication code exists in the program's binary executable and can be easily discovered.\nImplementation Details (Unix)\nMany Unix platforms provide a strings utility that prints out all of the ASCII strings in a binary file. Here is the output of running strings on this program, on an Ubuntu 16.04 platform:\n% strings a.out\n...\nAUATL\n[]A\\A]A^A_\ncorrect code\nAuthentication error\nAuthentication successful\n...\n%\nCompliant Solution (C23, memset_explicit())\nThis compliant solution requires the user to supply the authentication code, and securely erases it when done, using memset_explicit().\n/* Returns nonzero if authenticated */\nint authenticate(const char* code);\n\nint main() {\n#define CODE_LEN 50\n  char code[CODE_LEN];\n  printf(\"Please enter your authentication code:\\n\");\n  fgets(code, sizeof(code), stdin);\n  int flag = authenticate(code);\n  memset_explicit(code, 0, sizeof(code));\n  if (!flag) {\n    printf(\"Access denied\\n\");\n    return -1;\n  }\n  printf(\"Access granted\\n\");\n  // ...Work with system...\n  return 0;\n}\nAlternatively, the program could read the authentication code from a file, letting file system security protect the file and the code from untrusted users.\nRisk Assessment\nHard coding sensitive information exposes that information to attackers. The severity of this rule can vary depending on the kind of information that is disclosed. Frequently, the information disclosed is password or key information, which can lead to remote exploitation. Consequently, a high severity rating is given but may be adjusted downwards according to the nature of the sensitive data. \nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nMSC41-C\nHigh\nProbable\nNo\nNo\nP6\nL2\nAutomated Detection\nTool Version Checker Description\nAstr\u00e9e\n24.04\n\nSupported\nCodeSonar\n9.1p0\nHARDCODED.AUTH\nHARDCODED.DNS\nHARDCODED.KEY\nHARDCODED.SALT\nHARDCODED.SEED\nHardcoded Authentication\nHardcoded DNS Name\nHardcoded Crypto Key\nHardcoded Crypto Salt\nHardcoded Seed in PRNG\nHelix QAC\n2025.2\nDF3556, DF3557, DF3558\nC++3842\n\nKlocwork\n2025.2\nHCC\nHCC.PWD\nHCC.USER\nCXX.SV.PWD.PLAIN\nCXX.SV.PWD.PLAIN.LENGTH\nCXX.SV.PWD.PLAIN.ZERO\n\nParasoft C/C++test\n2024.2\nCERT_C-MSC41-a\nDo not hard code string literals\nPC-lint Plus\n1.4\n2460\nAssistance provided: reports when a literal is provided as an argument to a function parameter with the \u2018noliteral\u2019 argument Semantic; several Windows API functions are marked as such and the \u2018-sem\u2019 option can apply it to other functions as appropriate\nPolyspace Bug Finder\nR2025b\nCERT C: Rule MSC41-C Checks for hard coded sensitive data (rule partially covered)\nRuleChecker\n24.04\n\nSupported\nSecurity Reviewer - Static Reviewer\n6.02\nRTOS_14 Fully implemented\nRelated Guidelines\nSEI CERT Oracle Coding Standard for Java MSC03-J. Never hard code sensitive information\nISO/IEC TR 24772:2010\nHard-coded Password [XYP]\nMITRE CWE\nCWE-259, Use of Hard-Coded Password\nCWE-798, Use of Hard-Coded Credentials\nBibliography\n[Chess 2007]\nSection 11.2, \"Outbound Passwords: Keep Passwords out of Source Code\"\n[Fortify 2006]\n\"Unsafe Mobile Code: Database Access\"\n\nMSC40-C. Do not violate constraints Rule 48. Miscellaneous (MSC) Rule 50. POSIX (POS)",
        "language": "C"
    },
    {
        "rule_id": "POS34-C",
        "rule_title": "Do not call putenv() with a pointer to an automatic variable as the argument",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS34-C.+Do+not+call+putenv%28%29+with+a+pointer+to+an+automatic+variable+as+the+argument",
        "content": "The POSIX function putenv() is used to set environment variable values. The putenv() function does not create a copy of the string supplied to it as an argument; rather, it inserts a pointer to the string into the environment array. If a pointer to a buffer of automatic storage duration is supplied as an argument to putenv(), the memory allocated for that buffer may be overwritten when the containing function returns and stack memory is recycled. This behavior is noted in the Open Group Base Specifications, Issue 6 [Open Group 2004]:\nA potential error is to call putenv() with an automatic variable as the argument, then return from the calling function while string is still part of the environment.\nThe actual problem occurs when passing a pointer to an automatic variable to putenv(). An automatic pointer to a static buffer would work as intended.\nNoncompliant Code Example\nIn this noncompliant code example, a pointer to a buffer of automatic storage duration is used as an argument to putenv() [Dowd 2006]. The TEST environment variable may take on an unintended value if it is accessed after func() has returned and the stack frame containing env has been recycled.\nNote that this example also violates DCL30-C. Declare objects with appropriate storage durations.\nint func(const char *var) {\n  char env[1024];\n  int retval = snprintf(env, sizeof(env),\"TEST=%s\", var);\n  if (retval < 0 || (size_t)retval >= sizeof(env)) {\n    /* Handle error */\n  }\n   return putenv(env);\n}\nCompliant Solution (static)\nThis compliant solution uses a static array for the argument to putenv().\nint func(const char *var) {\n  static char env[1024];\n   int retval = snprintf(env, sizeof(env),\"TEST=%s\", var);\n  if (retval < 0 || (size_t)retval >= sizeof(env)) {\n    /* Handle error */\n  }\n   return putenv(env);\n}\nAccording to the [Open Group 2004] entry for putenv():\n...the string pointed to by string shall become part of the environment, so altering the string shall change the environment.\nThis means that the call to putenv() is only necessary the first time func() is called, since subsequent changes to the string update the environment. If func() were called more than once, an additional variable could be added to avoid calling it unnecessarily.\nCompliant Solution (Heap Memory)\nThis compliant solution dynamically allocates memory for the argument to putenv():\nint func(const char *var) {\n  const char *env_format = \"TEST=%s\";\n  const size_t len = strlen(var) + strlen(env_format);\n  char *env = (char *) malloc(len);\n  if (env == NULL) {\n    return -1;\n  }\n  int retval = snprintf(env, len, env_format, var);\n  if (retval < 0 || (size_t)retval >= len) {\n    /* Handle error */\n  }\n  if (putenv(env) != 0) {\n    free(env);\n    return -1;\n  }\n  return 0;\n}\nThe POSIX setenv() function is preferred over this function [Open Group 2004]. In particular, using putenv() will necessarily leak memory if called multiple times for the same environment variable, due to restrictions on when you can safely free the old value. According to the [Open Group 2004] entry for putenv():\nAlthough the space used by string is no longer used once a new string which defines name is passed to putenv(), if any thread in the application has used getenv() to retrieve a pointer to this variable, it should not be freed by calling free(). If the changed environment variable is one known by the system (such as the locale environment variables) the application should never free the buffer used by earlier calls to putenv() for the same variable.\nCompliant Solution (setenv())\nThe setenv() function allocates heap memory for environment variables, which eliminates the possibility of accessing volatile stack memory:\nint func(const char *var) {\n  return setenv(\"TEST\", var, 1);\n}\nUsing setenv() is easier and consequently less error prone than using putenv().\nRisk Assessment\nProviding a pointer to a buffer of automatic storage duration as an argument to putenv() may cause that buffer to take on an unintended value. Depending on how and when the buffer is used, it can cause unexpected program behavior or possibly allow an attacker to run arbitrary code.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS34-C\nHigh\nUnlikely\nYes\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported: Can be checked with appropriate analysis stubs.\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS34\nCodeSonar\n9.1p0\n(customization)\nBADFUNC.PUTENV\nUsers can add a custom check for all uses of putenv().\nUse of putenv\nCompass/ROSE\n\n\n\nHelix QAC\n2025.2\nC5024\nKlocwork\n2025.2\nCERT.PUTENV.AUTO_VARIABLE\n\nParasoft C/C++test\n2024.2\nCERT_C-POS34-a\nCERT_C-POS34-b\nUsage of system properties (environment variables) should be restricted\nDo not call putenv() with a pointer to an automatic variable as the argument\nPC-lint Plus\n1.4\n2601\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS34-C Checks for use of automatic variable as putenv-family function argument (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-252/CWE-253/CWE-391 and ERR33-C/POS34-C\nIndependent( ERR33-C, POS54-C, FLP32-C, ERR34-C)\nIntersection( CWE-252, CWE-253) = \u00d8\nCWE-391 = Union( CWE-252, CWE-253)\nCWE-391 = Union( ERR33-C, POS34-C, list) where list =\nIgnoring return values of functions outside the C or POSIX standard libraries\nBibliography\n[Dowd 2006] Chapter 10, \"UNIX Processes\"\n[ISO/IEC 9899:2024] Section 6.2.4, \"Storage Durations of Objects\"\nSection 7.24.3, \"Memory Management Functions\"\n[Open Group 2004] putenv()\nsetenv()",
        "language": "C"
    },
    {
        "rule_id": "POS35-C",
        "rule_title": "Avoid race conditions while checking for the existence of a symbolic link",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS35-C.+Avoid+race+conditions+while+checking+for+the+existence+of+a+symbolic+link",
        "content": "Many common operating systems, such as Windows and UNIX, support symbolic (soft) links. Symbolic links can be created in UNIX using the ln -s command or in Windows by using directory junctions in NTFS or the Linkd.exe (Win 2K resource kit) or \"junction\" freeware.\nIf not properly performed, checking for the existence of symbolic links can lead to race conditions.\nThis rule is a specific instance of rule FIO45-C. Avoid TOCTOU race conditions while accessing files.\nNoncompliant Code Example\nThe POSIX lstat() function collects information about a symbolic link rather than its target. This noncompliant code example uses the lstat() function to collect information about the file, checks the st_mode field to determine if the file is a symbolic link, and then opens the file if it is not a symbolic link:\nchar *filename = /* file name */;\nchar *userbuf = /* user data */;\nunsigned int userlen = /* length of userbuf string */;\n struct stat lstat_info;\nint fd;\n/* ... */\nif (lstat(filename, &lstat_info) == -1) {\n  /* Handle error */\n}\n if (!S_ISLNK(lstat_info.st_mode)) {\n   fd = open(filename, O_RDWR);\n   if (fd == -1) {\n       /* Handle error */\n   }\n}\nif (write(fd, userbuf, userlen) < userlen) {\n  /* Handle error */\n}\nThis code contains a time-of-check, time-of-use (TOCTOU) race condition between the call to lstat() and the subsequent call to open() because both functions operate on a file name that can be manipulated asynchronously to the execution of the program. (See FIO01-C. Be careful using functions that use file names for identification.)\nCompliant Solution (POSIX.1-2008 or newer)\nThis compliant solution eliminates the race condition by using O_NOFOLLOW to cause open() to fail if passed a symbolic link, avoiding the TOCTOU by not having a separate \"check\" and \"use\":\nchar *filename = /* file name */;\nchar *userbuf = /* user data */;\nunsigned int userlen = /* length of userbuf string */;\n int fd = open(filename, O_RDWR|O_NOFOLLOW);\nif (fd == -1) {\n  /* Handle error */\n}\nif (write(fd, userbuf, userlen) < userlen) {\n  /* Handle error */\n}\nCompliant Solution (POSIX.1-2001 or older)\nThis compliant solution eliminates the race condition by\nCalling lstat() on the file name.\nCalling open() to open the file.\nCalling fstat() on the file descriptor returned by open().\nComparing the file information returned by the calls to lstat() and fstat() to ensure that the files are the same.\nchar *filename = /* file name */;\nchar *userbuf = /* user data */;\nunsigned int userlen = /* length of userbuf string */;\n struct stat lstat_info;\nstruct stat fstat_info;\nint fd;\n/* ... */\nif (lstat(filename, &lstat_info) == -1) {\n  /* handle error */\n}\n fd = open(filename, O_RDWR);\nif (fd == -1) {\n  /* handle error */\n}\n if (fstat(fd, &fstat_info) == -1) {\n  /* handle error */\n}\n if (lstat_info.st_mode == fstat_info.st_mode &&\n    lstat_info.st_ino == fstat_info.st_ino  &&\n    lstat_info.st_dev == fstat_info.st_dev) {\n  if (write(fd, userbuf, userlen) < userlen) {\n    /* Handle Error */\n  }\n}\nThis code eliminates the TOCTOU condition because fstat() is applied to file descriptors, not file names, so the file passed to fstat() must be identical to the file that was opened. The lstat() function does not follow symbolic links, but open() does. Comparing modes using the st_mode field is sufficient to check for a symbolic link.\nComparing i-nodes, using the st_ino fields, and devices, using the st_dev fields, ensures that the file passed to lstat() is the same as the file passed to fstat(). (See FIO05-C. Identify files using multiple file attributes.)\nRisk Assessment\nTOCTOU race condition vulnerabilities can be exploited to gain elevated privileges.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS35-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nuser_defined Soundly supported\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS35\nCompass/ROSE\n\n\nCan detect some violations of this rule. In particular, it ensures that calls to open() that are preceded by a call to lstat() are also followed by a call to fstat().\nCoverity\n2017.07\nTOCTOU\nImplemented\nHelix QAC\n2025.2\nDF4886, DF4887, DF4888\n\nKlocwork\n2025.2\nSV.TOCTOU.FILE_ACCESS\nCERT.STR.ASSIGN.CONST_TO_NONCONST\n\nParasoft C/C++test\n2024.2\nCERT_C-POS35-b\nAvoid race conditions while checking for the existence of a symbolic link\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS35-C\nChecks for file access between time of check and use (TOCTOU) (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCWE 2.11 CWE-363, Race condition enabling link following 2017-07-07: CERT: Exact\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-764 and POS51-C/POS35-C\nIndependent( CWE-764, POS51-C, POS35-C)\nCWE-764 is about semaphores, or objects capable of being locked multiple times. Deadlock arises from multiple locks being acquired in a cyclic order, and generally does not arise from semaphores or recursive mutexes.\nBibliography\n[Dowd 2006] Chapter 9, \"UNIX 1: Privileges and Files\"\n[ISO/IEC 9899:2024] Section 7.23, \"Input/output <stdio.h>\"\n[Open Group 2004] lstat()\nfstat()\nopen()\n[Seacord 2013] Chapter 8, \"File I/O\"",
        "language": "C"
    },
    {
        "rule_id": "POS36-C",
        "rule_title": "Observe correct revocation order while relinquishing privileges",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges",
        "content": "In case of set-user-ID and set-group-ID programs, when the effective user ID and group ID are different from those of the real user, it is important to drop not only the user-level privileges but also the group privileges. While doing so, the order of revocation must be correct.\nPOSIX defines setgid() to have the following behavior [Open Group 2004]:\nIf the process has appropriate privileges, setgid() shall set the real group ID, effective group ID, and the saved set-group-ID of the calling process to gid.\nIf the process does not have appropriate privileges, but gid is equal to the real group ID or the saved set-group-ID, setgid() shall set the effective group ID to gid; the real group ID and saved set-group-ID shall remain unchanged.\nNoncompliant Code Example\nThis noncompliant code example drops privileges to those of the real user and similarly drops the group privileges. However, the order is incorrect because the setgid() function must be run with superuser privileges, but the call to setuid() leaves the effective user ID as nonzero. As a result, if a vulnerability is discovered in the program that allows for the execution of arbitrary code, an attacker can regain the original group privileges.\n/* Drop superuser privileges in incorrect order */\n if (setuid(getuid()) == -1) {\n  /* handle error condition */\n}\nif (setgid(getgid()) == -1) {\n  /* handle error condition */\n}\n /* It is still possible to regain group privileges due to\n * incorrect relinquishment order */\nCompliant Solution\nThis compliant solution relinquishes group privileges before taking away the user-level privileges so that both operations execute as intended.\n/*  Drop superuser privileges in correct order */\n if (setgid(getgid()) == -1) {\n  /* handle error condition */\n}\nif (setuid(getuid()) == -1) {\n  /* handle error condition */\n}\n /*\n * Not possible to regain group privileges due to correct relinquishment order\n */\nSupplementary Group IDs\nA process may have a number of supplementary group IDs in addition to its effective group ID, and the supplementary groups can allow privileged access to files. The getgroups() function returns an array that contains the supplementary group IDs and may also contain the effective group ID. The setgroups() function can set the supplementary group IDs and may also set the effective group ID on some systems. Using setgroups() usually requires privileges. Although POSIX defines the getgroups() function, it does not define setgroups().\nUnder normal circumstances, setuid() and related calls do not alter the supplementary group IDs. However, a setuid-root program can alter its supplementary group IDs and then relinquish root privileges, in which case it maintains the supplementary group IDs but lacks the privilege necessary to relinquish them. Consequently, it is recommended that a program relinquish supplementary group IDs immediately before relinquishing root privileges. The following code defines a set_sups() function that will set the supplementary group IDs to a specific array on systems that support the setgroups() function.\n/* Returns nonzero if the two group lists are equivalent (taking into\n   account that the lists may differ wrt the egid */\nint eql_sups(const int cursups_size, const gid_t* const cursups_list,\n         const int targetsups_size, const gid_t* const targetsups_list) {\n  int i;\n  int j;\n  const int n = targetsups_size;\n  const int diff = cursups_size - targetsups_size;\n  const gid_t egid = getegid();\n  if (diff > 1 || diff < 0 ) {\n    return 0;\n  }\n  for (i=0, j=0; i < n; i++, j++) {\n    if (cursups_list[j] != targetsups_list[i]) {\n      if (cursups_list[j] == egid) {\n    i--; /* skipping j */\n      } else {\n    return 0;\n      }\n    }\n  }\n  /* If reached here, we're sure i==targetsups_size. Now, either\n     j==cursups_size (skipped the egid or it wasn't there), or we didn't\n     get to the egid yet because it's the last entry in cursups */\n  return j == cursups_size ||\n    (j+1 == cursups_size && cursups_list[j] == egid);\n}\n  /* Sets the suplimentary group list, returns 0 if successful  */\nint set_sups(const int target_sups_size,const gid_t* const target_sups_list) {\n#ifdef __FreeBSD__\n  const int targetsups_size = target_sups_size + 1;\n  gid_t* const targetsups_list = (gid_t* const) malloc(sizeof(gid_t) * targetsups_size);\n  if (targetsups_list == NULL) {\n    /* handle error */\n  }\n  memcpy(targetsups_list+1, target_sups_list, target_sups_size * sizeof(gid_t) );\n  targetsups_list[0] = getegid();\n#else\n  const int targetsups_size = target_sups_size;\n  const gid_t* const targetsups_list = target_sups_list;\n#endif\n  if (geteuid() == 0) { /* allowed to setgroups, let's not take any chances */\n    if (-1 == setgroups(targetsups_size, targetsups_list)) {\n      /* handle error */\n    }\n  } else {\n    int cursups_size = getgroups( 0, NULL);\n    gid_t* cursups_list = (gid_t*) malloc( sizeof(gid_t) * cursups_size);\n    if (cursups_list == NULL) {\n      /* handle error */\n    }\n    if (-1 == getgroups( cursups_size, cursups_list)) {\n      /* handle error */\n    }\n    if (!eql_sups(cursups_size, cursups_list, targetsups_size, targetsups_list)) {\n      if (-1 == setgroups(targetsups_size, targetsups_list)) { /* will probably fail... :( */\n    /* handle error */\n      }\n    }\n    free( cursups_list);\n  }\n #ifdef __FreeBSD__\n  free( targetsups_list);\n#endif\n  return 0;\n}\nRisk Assessment\nFailing to observe the correct revocation order while relinquishing privileges allows an attacker to regain elevated privileges.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS36-C\nHigh\nProbable\nYes\nYes\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nuser_defined\nSoundly supported\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS36\nCompass/ROSE\n\n\nCan detect some violations of this rule. In particular, it warns when calls to setgid() are immediately preceded by a call to setuid()\nHelix QAC\n2025.2\nDF4891, DF4892, DF4893\n\nKlocwork\n2025.2\nSV.USAGERULES.PERMISSIONS\n\n\nParasoft C/C++test\n2024.2\nCERT_C-POS36-a\nObserve correct revocation order while relinquishing privileges\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS36-C Checks for bad order of dropping privileges (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TR 24772 Privilege Sandbox Issues [XYO] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-696, Incorrect behavior order 2017-07-07: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-696 and POS36-C\nCWE-696 = Union( POS36-C, list) where list =\n\nMisordered executions besides dropping group privileges before dropping user privileges\n\nBibliography\n[Chen 2002] \"Setuid Demystified\"\n[Dowd 2006] Chapter 9, \"UNIX I: Privileges and Files\"\n[Open Group 2004] setuid()\nsetgid()\n[Tsafrir 2008] \"The Murky Issue of Changing Process Identity: Revising 'Setuid Demystified'\"",
        "language": "C"
    },
    {
        "rule_id": "POS37-C",
        "rule_title": "Ensure that privilege relinquishment is successful",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful",
        "content": "The POSIX setuid() function has complex semantics and platform-specific behavior [Open Group 2004].\nIf the process has appropriate privileges, setuid() shall set the real user ID, effective user ID, and the saved set-user-ID of the calling process to uid.\nIf the process does not have appropriate privileges, but uid is equal to the real user ID or the saved set-user-ID, setuid() shall set the effective user ID to uid; the real user ID and saved set-user-ID shall remain unchanged.\nThe meaning of \"appropriate privileges\" varies from platform to platform. For example, on Solaris, appropriate privileges for setuid() means that the PRIV_PROC_SETID privilege is in the effective privilege set of the process. On BSD, it means that the effective user ID (EUID) is zero (that is, the process is running as root) or that uid=geteuid(). On Linux, it means that the process has CAP_SETUID capability and that setuid(geteuid()) will fail if the EUID is not equal to 0, the real user ID (RUID), or the saved set-user ID (SSUID).\nBecause of this complex behavior, desired privilege drops sometimes may fail. For example, the range of Linux Kernel versions (2.2.0\u20132.2.15) is vulnerable to an insufficient privilege attack wherein setuid(getuid() did not drop privileges as expected when the capability bits were set to zero. As a precautionary measure, subtle behavior and error conditions for the targeted implementation must be carefully noted.\nNoncompliant Code Example\nThis noncompliant code example compiles cleanly on most POSIX systems, but no explicit checks are made to ensure that privilege relinquishment has succeeded. This may be dangerous depending on the sequence of the preceding privilege changes.\n/* Code intended to run with elevated privileges */\n /* Temporarily drop privileges */\nif (seteuid(getuid()) != 0) {\n  /* Handle error */\n}\n /* Code intended to run with lower privileges */\n if (need_more_privileges) {\n  /* Restore privileges */\n  if (seteuid(0) != 0) {\n    /* Handle error */\n  }\n   /* Code intended to run with elevated privileges */\n}\n /* ... */\n /* Permanently drop privileges */\nif (setuid(getuid()) != 0) {\n  /* Handle error */\n}\n /*\n * Code intended to run with lower privileges,\n * but if privilege relinquishment failed,\n * attacker can regain elevated privileges!\n */\nIf the program is run as a setuid root program, over time, the state of the UIDs might look like the following:\nDescription\nCode\nEUID\nRUID\nSSUID\nProgram startup\n\n0\nUser\n0\nTemporary drop\nseteuid(getuid())\nUser\nUser\n0\nRestore\nseteuid(0)\n0\nUser\n0\nPermanent drop\nsetuid(getuid())\nUser\nUser\nUser\nRestore (attacker)\nsetuid(0) (fails)\nUser\nUser\nUser\nIf the program fails to restore privileges, it will be unable to permanently drop them later:\nDescription\nCode\nEUID\nRUID\nSSUID\nprogram startup\n\n0\nUser\n0\nTemporary drop\nseteuid(getuid())\nUser\nUser\n0\nRestore\nseteuid(0)\nUser\nUser\n0\nPermanent drop\nsetuid(getuid())\nUser\nUser\n0\nRestore (attacker)\nsetuid(0)\n0\n0\n0\nCompliant Solution\nThis compliant solution was implemented in sendmail, a popular mail transfer agent, to determine if superuser privileges were successfully dropped [Wheeler 2003]. If the setuid() call succeeds after (supposedly) dropping privileges permanently, then the privileges were not dropped as intended.\n/* Code intended to run with elevated privileges   */\n /* Temporarily drop privileges */\nif (seteuid(getuid()) != 0) {\n  /* Handle error */\n}\n /* Code intended to run with lower privileges */\n if (need_more_privileges) {\n  /* Restore Privileges */\n  if (seteuid(0) != 0) {\n    /* Handle error */\n  }\n   /* Code intended to run with elevated privileges */\n}\n /* ... */\n /* Permanently drop privileges */\nif (setuid(getuid()) != 0) {\n  /* Handle error */\n}\n if (setuid(0) != -1) {\n  /* Privileges can be restored, handle error */\n}\n /*\n * Code intended to run with lower privileges;\n * attacker cannot regain elevated privileges\n */\nCompliant Solution\nA better solution is to ensure that proper privileges exist before attempting to perform a permanent drop:\n/* Store the privileged ID for later verification */\nuid_t privid = geteuid();\n /* Code intended to run with elevated privileges   */\n /* Temporarily drop privileges */\nif (seteuid(getuid()) != 0) {\n  /* Handle error */\n}\n /* Code intended to run with lower privileges  */\n if (need_more_privileges) {\n  /* Restore Privileges */\n  if (seteuid(privid) != 0) {\n    /* Handle error */\n  }\n   /* Code intended to run with elevated privileges   */\n}\n /* ... */\n /* Restore privileges if needed */\nif (geteuid() != privid) {\n  if (seteuid(privid) != 0) {\n    /* Handle error */\n  }\n}\n /* Permanently drop privileges */\nif (setuid(getuid()) != 0) {\n  /* Handle error */\n}\n if (setuid(0) != -1) {\n  /* Privileges can be restored, handle error */\n}\n /*\n * Code intended to run with lower privileges;\n * attacker cannot regain elevated privileges\n */\nSupplementary Group IDs\nA process may have a number of supplementary group IDs, in addition to its effective group ID, and the supplementary groups can allow privileged access to files. The getgroups() function returns an array that contains the supplementary group IDs and can also contain the effective group ID. The setgroups() function can set the supplementary group IDs and can also set the effective group ID on some systems. Using setgroups() usually requires privileges. Although POSIX defines the getgroups() function, it does not define setgroups().\nUnder normal circumstances, setuid() and related calls do not alter the supplementary group IDs. However, a setuid-root program can alter its supplementary group IDs and then relinquish root privileges, in which case, it maintains the supplementary group IDs but lacks the privilege necessary to relinquish them. Consequently, it is recommended that a program immediately relinquish supplementary group IDs before relinquishing root privileges.\nPOS36-C. Observe correct revocation order while relinquishing privileges discusses how to drop supplementary group IDs. To ensure that supplementary group IDs are indeed relinquished, you can use the following eql_sups function:\n/* Returns nonzero if the two group lists are equivalent (taking into\n   account that the lists may differ wrt the egid */\nint eql_sups(const int cursups_size, const gid_t* const cursups_list,\n         const int targetsups_size, const gid_t* const targetsups_list) {\n  int i;\n  int j;\n  const int n = targetsups_size;\n  const int diff = cursups_size - targetsups_size;\n  const gid_t egid = getegid();\n  if (diff > 1 || diff < 0 ) {\n    return 0;\n  }\n  for (i=0, j=0; i < n; i++, j++) {\n    if (cursups_list[j] != targetsups_list[i]) {\n      if (cursups_list[j] == egid) {\n    i--; /* skipping j */\n      } else {\n    return 0;\n      }\n    }\n  }\n  /* If reached here, we're sure i==targetsups_size. Now, either\n     j==cursups_size (skipped the egid or it wasn't there), or we didn't\n     get to the egid yet because it's the last entry in cursups */\n  return j == cursups_size ||\n    (j+1 == cursups_size && cursups_list[j] == egid);\n}\nSystem-Specific Capabilities\nMany systems have nonportable privilege capabilities that, if unchecked, can yield privilege escalation vulnerabilities. The following section describes one such capability.\nFile System Access Privileges (Linux)\nProcesses on Linux have two additional values called fsuid and fsgid. These values indicate the privileges used when accessing files on the file system. They normally shadow the effective user ID and effective group ID, but the setfsuid() and setfsgid() functions allow them to be changed. Because changes to the euid and egid normally also apply to fsuid and fsgid, a program relinquishing root privileges need not be concerned with setting fsuid or fsgid to safe values. However, there has been at least one kernel bug that violated this invariant ([Chen 2002] and [Tsafrir 2008]). Consequently, a prudent program checks that fsuid and fsgid have harmless values after relinquishing privileges.\nRisk Assessment\nIf privilege relinquishment conditions are left unchecked, any flaw in the program may lead to unintended system compromise corresponding to the more privileged user or group account.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS37-C\nHigh\nProbable\nYes\nYes\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nuser_defined\nSoundly supported\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS37\nHelix QAC\n2025.2\nDF4876, DF4877, DF4878\n\nKlocwork\n2025.2\nSV.USAGERULES.PERMISSIONS\n\n\nParasoft C/C++test\n2024.2\nCERT_C-POS37-a\nEnsure that privilege relinquishment is successful\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS37-C Checks for priviledge drop not verified (rule fully covered)\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nISO/IEC TR 24772 Privilege Sandbox Issues [XYO] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-273, Failure to check whether privileges were dropped successfully 2017-07-07: CERT: Exact\nBibliography\n[Chen 2002] \"Setuid Demystified\"\n[Dowd 2006] Chapter 9, \"Unix I: Privileges and Files\"\n[Open Group 2004] setuid()\ngetuid()\nseteuid()\n[Tsafrir 2008] \"The Murky Issue of Changing Process Identity: Revising 'Setuid Demystified'\"\n[Wheeler 2003] Section 7.4, \"Minimize Privileges\"",
        "language": "C"
    },
    {
        "rule_id": "POS38-C",
        "rule_title": "Beware of race conditions when using fork and file descriptors",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS38-C.+Beware+of+race+conditions+when+using+fork+and+file+descriptors",
        "content": "When forking a child process, file descriptors are copied to the child process, which can result in concurrent operations on the file. Concurrent operations on the same file can cause data to be read or written in a nondeterministic order, creating race conditions and unpredictable behavior.\nNoncompliant Code Example\nIn this example, the programmer wishes to open a file, read a character, fork, and then have both parent and child process read the second character of the file independently. However, because both processes share a file descriptor, one process might get the second character, and one might get the third. Furthermore, there is no guarantee the reads are atomic\u2014the processes might get unpredictable results. Regardless of what the programmer is trying to accomplish with this code, this code is incorrect because it contains a race condition.\nchar c;\npid_t pid;\n\nint fd = open(filename, O_RDWR);\nif (fd == -1) {\n  /* Handle error */\n}\nread(fd, &c, 1);\nprintf(\"root process:%c\\n\",c);\n\npid = fork();\nif (pid == -1) {\n  /* Handle error */\n}\n\nif (pid == 0) { /*child*/\n  read(fd, &c, 1);\n  printf(\"child:%c\\n\",c);\n}\nelse { /*parent*/\n  read(fd, &c, 1);\n  printf(\"parent:%c\\n\",c);\n}\nIf the file accessed has contents \"abc\", the output of this program could be either\nroot process:a\nparent: b\nchild: c\nor\nroot process: a\nchild: b\nparent: c\nThis code's output cannot reliably be determined and should not be used.\nCompliant Solution\nIn this compliant solution, the programmer closes the file descriptor in the child after forking and then reopens it, ensuring that the file has not been modified in the meantime. See POS01-C. Check for the existence of links when dealing with files for details.\nchar c;\n\npid_t pid;\n\n/* Open file and remember file status  */\nstruct stat orig_st;\nif (lstat( filename, &orig_st) != 0) {\n  /* handle error */\n}\nint fd = open(filename, O_RDWR);\nif (fd == -1) {\n  /* Handle error */\n}\nstruct stat new_st;\nif (fstat(fd, &new_st) != 0) {\n  /* handle error */\n}\nif (orig_st.st_dev != new_st.st_dev ||\n    orig_st.st_ino != new_st.st_ino) {\n  /* file was tampered with while opening */\n}\n\n/* file is good, operate on fd */\n\nread(fd,&c,1);\nprintf(\"root process:%c\\n\",c);\n\npid = fork();\nif (pid == -1) {\n  /* Handle error */\n}\n\nif (pid == 0){ /*child*/\n  close(fd);\n\n  /* Reopen file, creating new file descriptor */\n  fd = open(filename, O_RDONLY);\n  if (fd == -1) {\n    /* Handle error */\n  }\n  if (fstat(fd, &new_st) != 0) {\n    /* handle error */\n  }\n  if (orig_st.st_dev != new_st.st_dev ||\n      orig_st.st_ino != new_st.st_ino) {\n    /* file was tampered with between opens */\n  }\n\n  read(fd, &c, 1);\n  read(fd, &c, 1);\n  printf(\"child:%c\\n\", c);\n  close(fd);\n}\n\nelse { /*parent*/\n  read(fd, &c, 1);\n  printf(\"parent:%c\\n\", c);\n  close(fd);\n}\nThe output of this code is\nroot process:a\nchild:b\nparent:b\nRisk Assessment\nBecause race conditions in code are extremely hard to find, this problem might not appear during standard debugging stages of development. However, depending on what file is being read and how important the order of read operations is, this problem can be particular dangerous.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS38-C\nMedium\nUnlikely\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADFUNC.FORK\nUse of fork\nHelix QAC\n2025.2\nDF4951, DF4952\nParasoft C/C++test\n2024.2\nCERT_C-POS38-a\nAvoid race conditions when using fork and file descriptors\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS38-C Checks for file descriptor exposure to child process (rule fully covered)\nBibliography\nTODO",
        "language": "C"
    },
    {
        "rule_id": "POS39-C",
        "rule_title": "Use the correct byte ordering when transferring data between systems",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS39-C.+Use+the+correct+byte+ordering+when+transferring+data+between+systems",
        "content": "Different system architectures use different byte ordering, either little endian (least significant byte first) or big endian (most significant byte first). IA-32 is an example of an architecture that implements little endian byte ordering. In contrast, PowerPC and most Network Protocols (including TCP and IP) use big endian.\nWhen transferring data between systems of different endianness, the programmer must take care to reverse the byte ordering before interpreting the data.\nThe functions htonl(), htons(), ntohl(), and ntohs() can be used to transfer between network byte ordering (big endian) and the host's byte ordering. On big endian systems, these functions do nothing. They may also be implemented as macros rather than functions.\nNoncompliant Code Example\nIn this noncompliant code example, the programmer tries to read an unsigned 32-bit integer off a previously connected network socket.\nIt is important to know the sizes of your data types lest they be different on architectures that are accessible over the network. Hence, we transfer a uint32_t rather than an int. For more information, see FIO09-C. Be careful with binary data when transferring data across systems.\n/* sock is a connected TCP socket */\n\nuint32_t num;\n\nif (recv(sock, (void *)&num, sizeof(uint32_t), 0) < (int)sizeof(uint32_t)) {\n  /* Handle error */\n}\n\nprintf(\"We received %u from the network!\\n\", (unsigned int)num);\nThis program prints out the number received from the socket using an incorrect byte ordering. For example, if the value 4 is sent from a big endian machine, and the receiving system is little endian, the value 536,870,912 is read. This problem can be corrected by sending and receiving using network byte ordering.\nCompliant Solution\nIn this compliant solution, the programmer uses the ntohl() function to convert the integer from network byte order to host byte ordering:\n/* sock is a connected TCP socket */\n\nuint32_t num;\n\nif (recv(sock, (void *)&num, sizeof(uint32_t), 0) < (int)sizeof(uint32_t)) {\n  /* Handle error */\n}\n\nnum = ntohl(num);\nprintf(\"We recieved %u from the network!\\n\", (unsigned int)num);\nThe ntohl() function (network to host long) translates a uint32_t value into the host byte ordering from the network byte ordering. This function is always appropriate to use because its implementation depends on the specific system's byte ordering. Consequently, on a big endian architecture, ntohl() does nothing.\nThe reciprocal function htonl() (host to network long) should be used before sending any data to another system over network protocols.\nPortability Details\nntohs(), ntohl(), htons(), and htonl() are not part of the C Standard and are consequently not guaranteed to be portable to non-POSIX systems.\nThe POSIX implementations of ntohs(), ntohl(), htons(), and htonl() take arguments of types uint16_t and uint32_t and can be found in the header file <arpa/inet.h>.\nThe Windows implementations use unsigned short and unsigned long and can be found in the header file <winsock2.h>.\nOther variants of ntoht() and htont(), such as ntohi()/htoni() or ntohll()/htonll(), may exist on some systems.\nRisk Assessment\nIf the programmer is careless, this bug is likely. However, it will immediately break the program by printing the incorrect result and therefore should be caught by the programmer during the early stages of debugging and testing. Recognizing a value as in reversed byte ordering, however, can be difficult depending on the type and magnitude of the data.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS39-C\nMedium\nLikely\nYes\nNo\nP12\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\ntaint_sink\nSoundly supported\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS39\nHelix QAC\n2025.2\nDF4906, DF4907, DF4908\nKlocwork\n2025.2\nBYTEORDER.NTOH.RECV\nBYTEORDER.NTOH.READ\nBYTEORDER.HTON.SEND\nBYTEORDER.HTON.WRITE\nParasoft C/C++test\n2024.2\nCERT_C-POS39-a\nUse the correct byte ordering when transferring data between systems\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS39-C Checks for missing byte reordering when transferring data (rule fully covered)\nBibliography\n[MSDN] \"Winsock Functions\"\n[Open Group 2004] htonl, htons, ntohl, ntohs\u2014Convert Values between Host and Network Byte Order",
        "language": "C"
    },
    {
        "rule_id": "POS52-C",
        "rule_title": "Do not perform operations that can block while holding a POSIX lock",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS52-C.+Do+not+perform+operations+that+can+block+while+holding+a+POSIX+lock",
        "content": "If a lock is being held and an operation that can block is performed, any other thread that needs to acquire that lock may also block. This condition can degrade the performance of a system or cause a deadlock to occur.\nBlocking calls include, but are not limited to: network, file, and console I/O. This rule is a specific instance of CON05-C. Do not perform operations that can block while holding a lock using POSIX threads.\nNoncompliant Code Example\nThis noncompliant code example demonstrates an occurrence of a blocking call that waits to receive data on a socket while a mutex is locked. The recv() call blocks until data arrives on the socket. While it is blocked, other threads that are waiting for the lock are also blocked.\nAlthough this example is specific to network I/O, the recv() call could be replaced with any blocking call, and the same behavior would occur.\npthread_mutexattr_t attr;\npthread_mutex_t mutex;\n void thread_foo(void *ptr) {\n  uint32_t num;\n  int result;\n  int sock;\n   /* sock is a connected TCP socket */\n   if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n   if ((result = recv(sock, (void *)&num, sizeof(uint32_t), 0)) < 0) {\n    /* Handle Error */\n  }\n   /* ... */\n   if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n}\n int main() {\n  pthread_t thread;\n  int result;\n   if ((result = pthread_mutexattr_settype(\n      &mutex, PTHREAD_MUTEX_ERRORCHECK)) != 0) {\n    /* Handle Error */\n  }\n   if ((result = pthread_mutex_init(&mutex, &attr)) != 0) {\n    /* Handle Error */\n  }\n   if (pthread_create(&thread, NULL,(void *)& thread_foo, NULL) != 0) {\n    /* Handle Error */\n  }\n   /* ... */\n   pthread_join(thread, NULL);\n   if ((result = pthread_mutex_destroy(&mutex)) != 0) {\n    /* Handle Error */\n  }\n   return 0;\n}\nCompliant Solution (Block while Not Locked)\nThis compliant solution performs the recv() call when the lock has not been acquired. The blocking behavior consequently affects only the thread that called the blocking function.\nvoid thread_foo(void *ptr) {\n  uint32_t num;\n  int result;\n  int sock;\n   /* sock is a connected TCP socket */\n   if ((result = recv(sock, (void *)&num, sizeof(uint32_t), 0)) < 0) {\n    /* Handle Error */\n  }\n   if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n   /* ... */\n   if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n}\nCompliant Solution (Use a Nonblocking Call)\nThis compliant solution performs the recv() call with the parameter MSG_DONTWAIT, which causes the call to fail if no messages are available on the socket:\nvoid thread_foo(void *ptr) {\n  uint32_t num;\n  int result;\n   /* sock is a connected TCP socket */\n   if ((result = recv(sock, (void *)&num, sizeof(uint32_t), MSG_DONTWAIT)) < 0) {\n    /* Handle Error */\n  }\n   if ((result = pthread_mutex_lock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n   /* ... */\n   if ((result = pthread_mutex_unlock(&mutex)) != 0) {\n    /* Handle Error */\n  }\n}\nExceptions\nPOS52-C-EX1: A thread may block while holding one or more locks and waiting to acquire another lock. When acquiring multiple locks, the order of locking must avoid deadlock, as specified in CON35-C. Avoid deadlock by locking in a predefined order.\nRisk Assessment\nBlocking or lengthy operations performed within synchronized regions could result in a deadlocked or an unresponsive system.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS52-C\nLow\nProbable\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nCONCURRENCY.STARVE.BLOCKING Blocking in Critical Section\nHelix QAC\n2025.2\nDF4966, DF4967\nKlocwork\n2025.2\nCONC.SLEEP\nParasoft C/C++test\n2024.2\nCERT_C-POS52-a\nDo not use blocking functions while holding a lock\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS52-C Checks for blocking operation while holding lock (rule fully covered)\nSecurity Reviewer - Static Reviewer\n6.02\nRTOS_20 Fully implemented\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C LCK09-J. Do not perform operations that can block while holding a lock Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-557 2017-07-10: CERT: Rule subset of CWE\nCERT-CWE Mapping Notes\nKey here for mapping notes\nCWE-557 and POS52-C\nCWE-557 = Union( POS52-C, list) where list =\n\nConcurrency issues besides blocking while holding a POSIX lock\n\nBibliography\n[Barney 2010] POSIX Threads Programming\n[Open Group] pthread_cancel()\nrecv()",
        "language": "C"
    },
    {
        "rule_id": "POS54-C",
        "rule_title": "Detect and handle POSIX library errors",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/POS54-C.+Detect+and+handle+POSIX+library+errors",
        "content": "All standard library functions, including I/O functions and memory allocation functions, return either a valid value or a value of the correct return type that indicates an error (for example, \u22121 or a null pointer). Assuming that all calls to such functions will succeed and failing to check the return value for an indication of an error is a dangerous practice that may lead to unexpected or undefined behavior when an error occurs. It is essential that programs detect and appropriately handle all errors in accordance with an error-handling policy, as discussed in ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy.  In addition to the C standard library functions mentioned in ERR33-C. Detect and handle standard library errors, the following functions defined in POSIX require error checking (list is not all-inclusive).\nThe successful completion or failure of each of the standard library functions listed in the following table shall be determined either by comparing the function\u2019s return value with the value listed in the column labeled \u201cError Return\u201d or by calling one of the library functions mentioned in the footnotes to the same column.\nFunction\nSuccessful Return\nError Return\nerrno\nfmemopen()\nPointer to a FILE object\nNULL\nENOMEM\nopen_memstream()\nPointer to a FILE object\nNULL\nENOMEM\nposix_memalign()\n0\nNonzero\nUnchanged\nSetting errno is a POSIX [ISO/IEC 9945:2008] extension to the C Standard.  On error, posix_memalign() returns a value that corresponds to one of the constants defined in the <errno.h> header. The function does not set errno. The posix_memalign() function is optional and is not required to be provided by POSIX-conforming implementations.\nNoncompliant Code Example (POSIX)\nIn this noncompliant code example, fmemopen() and open_memstream() are assumed to succeed. However, if the calls fail, the two file pointers in and out will be null and the program will have undefined behavior.\n#include <stdio.h>\n#include <string.h>\n  int main(int argc, char *argv[]) {\n  FILE *out;\n  FILE *in;\n  size_t size;\n  char *ptr;\n    if (argc != 2) {\n    /* Handle error */\n  }\n    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n  /* Use in */\n    out = open_memstream(&ptr, &size);\n  /* Use out */\n    return 0;\n}\nCompliant Solution (POSIX)\nA compliant solution avoids assuming that fmemopen() and open_memstream() succeed regardless of its arguments and tests the return value of the function before using the file pointers in and out:\n#include <stdio.h>\n#include <string.h>\n  int main(int argc, char *argv[]) {\n  FILE *out;\n  FILE *in;\n  size_t size;\n  char *ptr;\n    if (argc != 2) {\n    /* Handle error */\n  }\n    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n   if (in == NULL){\n    /* Handle error */\n  }\n  /* Use in */\n    out = open_memstream(&ptr, &size);\n   if (out == NULL){\n    /* Handle error */\n  }\n  /* Use out */\n  return 0;\n}\nExceptions\nPOS54-C-EX1: This exception has been removed.\nPOS54-C-EX2: The exception from ERR33-C. Detect and handle standard library errors (that is ERR33-C-EX1) applies to this rule. See that exception for more information.\nRisk Assessment\nFailing to detect error conditions can lead to unpredictable results, including abnormal program termination and denial-of-service attacks or, in some situations, could even allow an attacker to run arbitrary code.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nPOS54-C\nHigh\nLikely\nYes\nYes\nP27\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\nerror-information-unused\nerror-information-unused-computed\nSupported\nAxivion Bauhaus Suite\n7.2.0\nCertC-POS54\nCodeSonar\n9.1p0\nLANG.FUNCS.IRV\nLANG.ERRCODE.NOTEST\nLANG.ERRCODE.NZ\nIgnored return value\nMissing Test of Error Code\nNon-zero Error Code\nCompass/ROSE\n\nCan detect violations of this recommendation when checking for violations of EXP12-C. Do not ignore values returned by functions and EXP34-C. Do not dereference null pointers\nCoverity\n2017.07\nCHECKED_RETURN\nFinds inconsistencies in how function call return values are handled. Coverity Prevent cannot discover all violations of this recommendation, so further verification is necessary\nHelix QAC\n2025.2\nC3200\nKlocwork\n2025.2\nSV.RVT.RETVAL_NOTTESTED\nLDRA tool suite\n9.7.1\n80 D\nPartially implemented\nParasoft C/C++test\n2024.2\nCERT_C-POS54-a\nThe value returned by a POSIX library function that may return an error should be used\nPC-lint Plus\n1.4\n413, 534, 613\nAssistance provided\nPolyspace Bug Finder\nR2025b\nCERT C: Rule POS54-C Checks for situations where return value of a sensitive function is not checked (rule fully covered)\nRuleChecker\n24.04\nerror-information-unused\nSupported\nRelated Vulnerabilities\nThe vulnerability in Adobe Flash [VU#159523] arises because Flash neglects to check the return value from calloc(). Even when calloc() returns NULL, Flash writes to an offset from the return value. Dereferencing NULL usually results in a program crash, but dereferencing an offset from NULL allows an exploit to succeed without crashing the program.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nKey here (explains table format and definitions)\nTaxonomy\nTaxonomy item\nRelationship\nCERT C Secure Coding Standard API04-C. Provide a consistent and usable error-checking mechanism\nERR00-C. Adopt and implement a consistent and comprehensive error-handling policy\nERR02-C. Avoid in-band error indicators\nERR05-C. Application-independent code should provide error detection without dictating error handling\nEXP12-C. Do not ignore values returned by functions\nEXP34-C. Do not dereference null pointers\nFIO10-C. Take care when using the rename() function\nFIO13-C. Never push back anything other than one read character\nFIO33-C. Detect and handle input output errors resulting in undefined behavior\nFIO34-C. Distinguish between characters read from a file and EOF or WEOF\nFLP03-C. Detect and handle floating-point errors\nFLP32-C. Prevent or detect domain and range errors in math functions\nMEM04-C. Do not perform zero-length allocations\nMEM12-C. Consider using a goto chain when leaving a function on error when using and releasing resources Prior to 2018-01-12: CERT: Unspecified Relationship\nCERT C ERR10-CPP. Check for error conditions FIO04-CPP. Detect and handle input and output errors Prior to 2018-01-12: CERT: Unspecified Relationship\nISO/IEC TS 17961 Failing to detect and handle standard library errors [liberr] Prior to 2018-01-12: CERT: Unspecified Relationship\nCWE 2.11 CWE-252, Unchecked return value 2017-07-06: CERT: Partial overlap\nCWE 2.11 CWE-253, Incorrect check of function return value 2017-07-06: CERT: Partial overlap\nCWE 2.11 CWE-391, Unchecked error condition 2017-07-06: CERT: Rule subset of CWE\nBibliography\n[DHS 2006] Handle All Errors Safely\n[Henricson 1997] Recommendation 12.1, \"Check for All Errors Reported from Functions\"\n[ISO/IEC 9899:2024] Subclause 7.23.7.10, \"The ungetc Function\"",
        "language": "C"
    },
    {
        "rule_id": "SIG00-C",
        "rule_title": "Mask signals handled by noninterruptible signal handlers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/SIG00-C.+Mask+signals+handled+by+noninterruptible+signal+handlers",
        "content": "A signal is a mechanism for transferring control that is typically used to notify a process that an event has occurred. That process can then respond to the event accordingly. The C Standard provides functions for sending and handling signals within a C program.\nProcesses handle signals by registering a signal handler using the signal() function, which is specified as\nvoid (*signal(int sig, void (*func)(int)))(int);\nThis signal handler is conceptually equivalent to\ntypedef void (*sighandler_t)(int signum);\nextern sighandler_t signal(\n  int signum,\n  sighandler_t handler\n);\nSignal handlers can be interrupted by signals, including their own. If a signal is not reset before its handler is called, the handler can interrupt its own execution. A handler that always successfully executes its code despite interrupting itself or being interrupted is async-signal-safe.\nSome platforms provide the ability to mask signals while a signal handler is being processed. If a signal is masked while its own handler is processed, the handler is noninterruptible and need not be async-signal-safe. However, even when a signal is masked while its own handler is processed, the handler must still avoid invoking async-signal-safe unsafe functions because their execution may be (or have been) interrupted by another signal.\nVulnerabilities can arise if a signal handler that is not async-signal-safe is interrupted with any unmasked signal, including its own.\nNoncompliant Code Example\nThis noncompliant code example registers a single signal handler to process both SIGUSR1 and SIGUSR2. The variable sig2 should be set to 1 if one or more SIGUSR1 signals are followed by SIGUSR2, essentially implementing a finite state machine within the signal handler.\n#include <signal.h>\n volatile sig_atomic_t sig1 = 0;\nvolatile sig_atomic_t sig2 = 0;\n void handler(int signum) {\n  if (signum == SIGUSR1) {\n    sig1 = 1;\n  }\n  else if (sig1) {\n    sig2 = 1;\n  }\n}\n int main(void) {\n  if (signal(SIGUSR1, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  if (signal(SIGUSR2, handler) == SIG_ERR) {\n    /* Handler error */\n  }\n   while (sig2 == 0) {\n    /* Do nothing or give up CPU for a while */\n  }\n   /* ... */\n   return 0;\n}\nUnfortunately, a race condition occurs in the implementation of handler(). If handler() is called to handle SIGUSR1 and is interrupted to handle SIGUSR2, it is possible that sig2 will not be set.\nCompliant Solution (POSIX)\nThe POSIX sigaction() function assigns handlers to signals in a similar manner to the C signal() function, but it also allows signal masks to be set explicitly. Consequently, sigaction() can be used to prevent a signal handler from interrupting itself.\n#include <signal.h>\n#include <stdio.h>\n volatile sig_atomic_t sig1 = 0;\nvolatile sig_atomic_t sig2 = 0;\n void handler(int signum) {\n  if (signum == SIGUSR1) {\n    sig1 = 1;\n  }\n  else if (sig1) {\n    sig2 = 1;\n  }\n}\n int main(void) {\n  struct sigaction act;\n  act.sa_handler = &handler;\n  act.sa_flags = 0;\n  if (sigemptyset(&act.sa_mask) != 0) {\n    /* Handle error */\n  }\n  if (sigaddset(&act.sa_mask, SIGUSR1)) {\n    /* Handle error */\n  }\n  if (sigaddset(&act.sa_mask, SIGUSR2)) {\n    /* Handle error */\n  }\n   if (sigaction(SIGUSR1, &act, NULL) != 0) {\n    /* Handle error */\n  }\n  if (sigaction(SIGUSR2, &act, NULL) != 0) {\n    /* Handle error */\n  }\n   while (sig2 == 0) {\n    /* Do nothing or give up CPU for a while */\n  }\n   /* ... */\n   return 0;\n}\nPOSIX recommends sigaction() and deprecates the use of signal() to register signal handlers. Unfortunately, sigaction() is not defined in the C Standard and is consequently not as portable a solution.\nRisk Assessment\nInterrupting a noninterruptible signal handler can result in a variety of vulnerabilities [Zalewski 2001].\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSIG00-C\nHigh\nLikely\nNo\nNo\nP9\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADFUNC.SIGNAL Use of signal\nHelix QAC\n2025.2\nC5019\nLDRA tool suite\n9.7.1\n44 S Enhanced enforcement\nParasoft C/C++test\n2024.2\nCERT_C-SIG00-a\nThe signal handling facilities of <signal.h> shall not be used\nPC-lint Plus\n1.4\n586\nAssistance provided: reports use of the signal function\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID SIG00-CPP. Mask signals handled by noninterruptible signal handlers\nMITRE CWE CWE-662, Insufficient synchronization\nBibliography\n[C99 Rationale 2003] Subclause 5.2.3, \"Signals and Interrupts\"\n[Dowd 2006] Chapter 13, \"Synchronization and State\" (\"Signal Interruption and Repetition\")\n[IEEE Std 1003.1:2013] XSH, System Interface, longjmp\n[OpenBSD] signal() Man Page\n[Zalewski 2001] \"Delivering Signals for Fun and Profit\"",
        "language": "C"
    },
    {
        "rule_id": "SIG01-C",
        "rule_title": "Understand implementation-specific details regarding signal handler persistence",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/SIG01-C.+Understand+implementation-specific+details+regarding+signal+handler+persistence",
        "content": "The signal() function has implementation-defined behavior and behaves differently on Windows, for example, than it does on many UNIX systems.\nThe following code example shows this behavior:\n#include <stdio.h>\n#include <signal.h>\n volatile sig_atomic_t e_flag = 0;\n void handler(int signum) {\n  e_flag = 1;\n}\n int main(void) {\n  if (signal(SIGINT, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  while (!e_flag) {}\n  puts(\"Escaped from first while ()\");\n  e_flag = 0;\n  while (!e_flag) {}\n  puts(\"Escaped from second while ()\");\n  return 0;\n}\nMany UNIX (and UNIX-like) systems automatically reinstall signal handlers upon handler execution, meaning that the signal handler defined by the user is left in place until it is explicitly removed. For example, when this code is compiled with GCC 3.4.4 and executed under Red Hat Linux, SIGINT is captured both times by handler:\n% ./test\n^C\nEscaped from first while ()\n^C\nEscaped from second while ()\n%\nWhen a signal handler is installed with the signal() function in Windows and some UNIX systems, the default action is restored for that signal after the signal is triggered. This means that signal handlers are not automatically reinstalled. For example, when this code is compiled with Microsoft Visual Studio 2005, version 8.0, only the first SIGINT is captured by handler:\n> test.exe\n^C\nEscaped from first while ()\n^C\n>\nThe second SIGINT executes the default action, which is to terminate program execution.\nDifferent actions must be taken depending on whether or not the application requires signal handlers to be persistent.\nPersistent Handlers\nAsynchronous signals may originate from malicious actors external to the process. Consequently, vulnerabilities may exist if the signal-handler-persistence behavior is inconsistent with the developer's expectations, such as when the developer expects the signal handler to persist but it does not.\nNoncompliant Code Example\nThis noncompliant code example fails to persist the signal handler on Windows platforms and on those UNIX systems where handlers are not persistent by default:\nvoid handler(int signum) {\n  /* Handle signal */\n}\nNoncompliant Code Example\nA common approach to create persistent signal handlers is to call signal() from within the handler itself, consequently unresetting the reset signal:\nvoid handler(int signum) {\n  if (signal(signum, handler) == SIG_ERR) {\n    /* Handle error */\n  }\n  /* Handle signal */\n}\nUnfortunately, this solution still contains a race window, starting when the host environment resets the signal and ending when the handler calls signal(). During that time, a second signal sent to the program will trigger the default signal behavior, defeating the persistent behavior. (See SIG34-C. Do not call signal() from within interruptible signal handlers.)\nA secure solution must prevent the environment from resetting the signal in the first place, guaranteeing persistence. Unfortunately, Windows does not provide a secure solution to this problem.\nCompliant Solution (POSIX)\nThe POSIX sigaction() function assigns handlers to signals in a manner similar to the C signal() function but also allows signal-handler persistence to be controlled via the SA_RESETHAND flag. (Leaving the flag clear makes the handler persistent.)\n/*\n * Equivalent to signal(SIGUSR1, handler) but makes\n * signal persistent.\n */\nstruct sigaction act;\nact.sa_handler = handler;\nact.sa_flags = 0;\nif (sigemptyset(&act.sa_mask) != 0) {\n  /* Handle error */\n}\nif (sigaction(SIGUSR1, &act, NULL) != 0) {\n  /* Handle error */\n}\nPOSIX recommends sigaction() and deprecates signal(). Unfortunately, sigaction() is not defined in the C Standard and is consequently not as portable a solution.\nNonpersistent Handlers\nErrors may also occur when the developer expects the default action to be restored for a signal but the signal handler persists instead.\nNoncompliant Code Example (UNIX)\nThis noncompliant code example fails to reset the signal handler to its default behavior on systems where handlers are persistent by default:\nvoid handler(int signum) {\n  /* Handle signal */\n}\nCompliant Solution (UNIX and Windows)\nA C-compliant solution to reset the handler on a UNIX system is to rebind the signal to the default handler in the first line of the handler itself. Windows, however, automatically resets handlers to their default behavior.\nvoid handler(int signum) {\n#ifndef WINDOWS\n  if (signal(signum, SIG_DFL) == SIG_ERR) {\n    /* Handler error */\n  }\n#endif\n  /* Handle signal */\n}\nWith the compliant solution for UNIX, no race condition occurs that can be exploited by an attacker sending a second signal. This is because a second signal sent to the handler, before the latter calls signal(signum, SIG_DFL), will only cause the handler to restart and call signal() anyway.\nThis solution is an exception to SIG34-C. Do not call signal() from within interruptible signal handlers.\nCompliant Solution (POSIX)\nThe POSIX sigaction() function assigns handlers to signals in a manner similar to the C signal() function but also allows signal-handler persistence to be controlled via the SA_RESETHAND flag. (Setting the flag makes the handler nonpersistent.)\n/*\n * Equivalent to signal(SIGUSR1, handler) but makes\n * signal nonpersistent.\n */\nstruct sigaction act;\nact.sa_handler = handler;\nact.sa_flags = SA_RESETHAND;\nif (sigemptyset(&act.sa_mask) != 0) {\n  /* Handle error */\n}\nif (sigaction(SIGUSR1, &act, NULL) != 0) {\n  /* Handle error */\n}\nRisk Assessment\nFailure to understand implementation-specific details regarding signal-handler persistence can lead to unexpected behavior.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSIG01-C\nLow\nUnlikely\nNo\nNo\nP1\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADFUNC.SIGNAL Use of signal\nCompass/ROSE\n\n\nCould detect possible violations by flagging any signal handler that calls signal() to (re)assert itself as the handler for its signal\nHelix QAC\n2025.2\nC5020\nLDRA tool suite\n9.7.1\n97 D Partially implemented\nParasoft C/C++test\n2024.2\nCERT_C-SIG01-a\nThe signal handling facilities of <signal.h> shall not be used\nPC-lint Plus\n1.4\n586\nAssistance provided: reports use of the signal function\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID SIG01-CPP. Understand implementation-specific details regarding signal handler persistence",
        "language": "C"
    },
    {
        "rule_id": "SIG02-C",
        "rule_title": "Avoid using signals to implement normal functionality",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/SIG02-C.+Avoid+using+signals+to+implement+normal+functionality",
        "content": "Avoid using signals to implement normal functionality. Signal handlers are severely limited in the actions they can perform in a portably secure manner. Their use should be reserved for abnormal events that can be serviced by little more than logging.\nNoncompliant Code Example\nThis noncompliant code example uses signals as a means to pass state changes around in a multithreaded environment:\n/* THREAD 1 */\nint do_work(void) {\n  /* ... */\n  kill(THR2_PID, SIGUSR1);\n}\n /* THREAD 2 */\nvolatile sig_atomic_t flag;\n void sigusr1_handler(int signum) {\n  flag = 1;\n}\n int wait_and_work(void) {\n  flag = 0;\n  while (!flag) {}\n  /* ... */\n}\nHowever, using signals for such functionality often leads to nonportable or otherwise complicated solutions.\nThis code illustrates one thread using a signal to wake up a second thread. Using an architecture's native thread library usually allows for a more sophisticated means of sending messages between threads.\nCompliant Solution (POSIX)\nA better solution, in this case, is to use condition variables. This code example uses a condition variable from the POSIX pthread library [IEEE Std 1003.1:2013]:\n#include <pthread.h>\n pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\npthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;\n /* THREAD 1 */\nint do_work(void) {\n  int result;\n  /* ... */\n  if ((result = pthread_mutex_lock(&mut)) != 0) {\n    /* Handle error condition */\n  }\n  if ((result = pthread_cond_signal(&cond,&mut)) != 0) {\n    /* Handle error condition */\n  }\n  if ((result = pthread_mutex_unlock(&mut)) != 0) {\n    /* Handle error condition */\n  }\n}\n /* THREAD 2 */\nint wait_and_work(void) {\n  if ((result = pthread_mutex_lock(&mut)) != 0) {\n    /* Handle error condition */\n  }\n  while (/* Condition does not hold */) {\n    if ((result = pthread_cond_wait(&cond, &mut)) != 0) {\n      /* Handle error condition */\n    }\n    /* ... */\n  }\n  if ((result = pthread_mutex_unlock(&mut)) != 0) {\n    /* Handle error condition */\n  }\n  /* ... */\n}\nCompliant Solution (Windows)\nThis compliant solution uses a condition variable from the Win32 API [MSDN]:\n#include <windows.h>\n /*\n * Note that the CRITICAL_SECTION must be initialized with\n * InitializeCriticalSection, and the CONDITION_VARIABLE must\n * be initialized with InitializeConditionVariable prior to\n * using them.\n */\nCRITICAL_SECTION CritSection;\nCONDITION_VARIABLE ConditionVar;\n /* THREAD 1 */\nint do_work(void) {\n  /* ... */\n  WakeConditionVariable(&ConditionVar);\n}\n /* THREAD 2 */\nint wait_and_work(void) {\n   EnterCriticalSection(&CritSection);\n  SleepConditionVariableCS(&ConditionVar, &CritSection, INFINITE);\n  LeaveCriticalSection(&CritSection);\n  /* ... */\n}\nNoncompliant Code Example\nThis noncompliant code example is from a signal race vulnerability in WU-FTPD v2.4 [Greenman 1997]:\nvoid dologout(status) {\n  if (logged_in) {\n    (void) seteuid((uid_t)0);\n    logwtmp(ttyline, \"\", \"\");\n    /* ... */\n  }\n  _exit(status);\n}\n static void lostconn(int signo) {\n  if (debug)\n    syslog(LOG_DEBUG, \"lost connection\");\n  dologout(-1);\n}\n static void myoob(signo) {\n  if (!transflag)\n    return;\n  /* ... */\n  if (strcmp(cp, \"ABOR\\r\\n\") == 0) {\n    tmpline[0] = '\\0';\n    reply(426, \"Transfer aborted. Data connection closed.\");\n    reply(226, \"Abort successful\");\n    longjmp(urgcatch, 1);\n  }\n  /* ... */\n}\n /* ... */\n signal(SIGPIPE, lostconn);\nsignal(SIGURG, myoob);\nA serious exploit can occur if SIGURG is caught immediately following the elevation of privileges in dologout(). If the longjmp() in the SIGURG handler myoob() is invoked, execution returns to the main processing loop with an effective UID of 0.\nPlease note that this code sample violates SIG30-C. Call only asynchronous-safe functions within signal handlers and SIG31-C. Do not access shared objects in signal handlers.\nAn immediate fix is to ensure that dologout() cannot be interrupted by a SIGURG:\nvoid dologout(status) {\n /*\n  * Prevent reception of SIGURG from resulting in a resumption\n  * back to the main program loop.\n  */\n  transflag = 0;\n  if (logged_in) {\n    (void) seteuid((uid_t)0);\n    logwtmp(ttyline, \"\", \"\");\n    /* ... */\n  }\n  _exit(status);\n}\nA better solution is for myoob() to set a failure flag of type volatile sig_atomic_t that is periodically checked within the main loop:\nvolatile sig_atomic_t xfer_aborted = 0;\n static void myoob(signo) {\n  /* ... */\n  if (strcmp(cp, \"ABOR\\r\\n\") == 0) {\n    xfer_aborted = 1;\n  }\n  /* ... */\n}\nThis solution, however, still violates SIG30-C. Call only asynchronous-safe functions within signal handlers and SIG31-C. Do not access shared objects in signal handlers.\nCompliant Solution\nA compliant solution (not shown) is to not use signals to signify lost connections and to design the system to have a robust error-handling mechanism (see ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy).\nRisk Assessment\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nSIG02-C\nHigh\nProbable\nNo\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADFUNC.SIGNAL Use of signal\nHelix QAC\n2025.2\nC5044\n\nLDRA tool suite\n9.7.1\n44 S Enhanced Enforcement\nParasoft C/C++test\n2024.2\nCERT_C-SIG02-a\nThe signal handling facilities of <signal.h> shall not be used\nPC-lint Plus\n1.4\n586\nAssistance provided: reports use of the signal function\nRelated Vulnerabilities\nUsing signals to implement normal functionality frequently results in the violation of one or more secure coding rules for signal handling.\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID SIG02-CPP. Avoid using signals to implement normal functionality\nBibliography\n[Dowd 2006] Chapter 13, \"Synchronization and State\"\n[Greenman 1997]\n[IEEE Std 1003.1:2013] XBD, Headers, <pthread>\n[MSDN] Using Condition Variables",
        "language": "C"
    },
    {
        "rule_id": "WIN30-C",
        "rule_title": "Properly pair allocation and deallocation functions",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/WIN30-C.+Properly+pair+allocation+and+deallocation+functions",
        "content": "Windows provides several APIs for allocating memory.  While some of these functions have converged over time, it is still important to always properly pair allocations and deallocations.  The following table shows the proper pairings.\nAllocator\nDeallocator\nmalloc() free()\nrealloc() free()\nLocalAlloc() LocalFree()\nLocalReAlloc()  LocalFree()\nGlobalAlloc() GlobalFree()\nGlobalReAlloc() GlobalFree()\nVirtualAlloc() VirtualFree()\nVirtualAllocEx() VirtualFreeEx()\nVirtualAllocExNuma() VirtualFreeEx()\nAllocateUserPhysicalPages() FreeUserPhysicalPages()\nAllocateUserPhysicalPagesNuma() FreeUserPhysicalPages()\nHeapAlloc() HeapFree()\nHeapReAlloc() HeapFree()\nNoncompliant Code Example\nIn this example, the FormatMessage() function allocates a buffer and stores it in the buf parameter.  From the documentation of FORMAT_MESSAGE_ALLOCATE_BUFFER [MSDN]:\nThe function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated buffer at the address specified by lpBuffer.  The lpBuffer parameter is a pointer to anL PTSTR; you must cast the pointer to an LPTSTR (for example, (LPTSTR)&lpBuffer). The nSize parameter specifies the minimum number of TCHARs to allocate for an output message buffer. The caller should use the LocalFree function to free the buffer when it is no longer needed.\nInstead of freeing the memory using LocalFree(), this code example uses GlobalFree() erroneously.\nLPTSTR buf;\nDWORD n = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                        FORMAT_MESSAGE_FROM_SYSTEM |\n                        FORMAT_MESSAGE_IGNORE_INSERTS, 0, GetLastError(),\n                        LANG_USER_DEFAULT, (LPTSTR)&buf, 1024, 0);\nif (n != 0) {\n  /* Format and display the error to the user */\n   GlobalFree(buf);\n}\nCompliant Solution\nThe compliant solution uses the proper deallocation function as described by the documentation.\nLPTSTR buf;\nDWORD n = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                        FORMAT_MESSAGE_FROM_SYSTEM |\n                        FORMAT_MESSAGE_IGNORE_INSERTS, 0, GetLastError(),\n                        LANG_USER_DEFAULT, (LPTSTR)&buf, 1024, 0);\nif (n != 0) {\n  /* Format and display the error to the user */\n   LocalFree(buf);\n}\nRisk Assessment\nMixing allocation and deallocation functions can lead to memory corruption issues, or result in accessing out-of-bounds memory.\nRule\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nWIN30-C\nLow\nProbable\nNo\nNo\nP2\nL3\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nAstr\u00e9e\n24.04\n\nSupported: Can be checked with appropriate analysis stubs.\nCodeSonar\n9.1p0\nALLOC.TM Type mismatch\nCoverity\n2017.07\nALLOC_FREE_MISMATCH (needs improvement)\nPartially implemented; needs improvement\nKlocwork\n2025.2\nFMM.MIGHT\nFMM.MUST\nParasoft C/C++test\n2024.2\nCERT_C-WIN30-a\nEnsure resources are freed\nPolyspace Bug Finder\nR2025b\nCERT C: Rule WIN30-C Checks for mismatched alloc/dealloc functions on Windows (rule fully covered)\nPVS-Studio\n7.38\nV701\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard MEM51-CPP. Properly deallocate dynamically allocated resources",
        "language": "C"
    },
    {
        "rule_id": "WIN00-C",
        "rule_title": "Be specific when dynamically loading libraries",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/WIN00-C.+Be+specific+when+dynamically+loading+libraries",
        "content": "The LoadLibrary() or LoadLibraryEx() function calls [MSDN] allow you to dynamically load a library at runtime and use a specific algorithm to locate the library within the file system [MSDN]. It is possible for an attacker to place a file on the DLL search path such that your application inadvertently loads and executes arbitrary source code.\nNoncompliant Code Example\n#include <Windows.h>\n \nvoid func(void) {\n  HMODULE hMod = LoadLibrary(TEXT(\"MyLibrary.dll\"));\n  if (hMod != NULL) {\n    typedef void (__cdecl func_type)(void);\n    func_type *fn = (func_type *)GetProcAddress(hMod, \"MyFunction\");\n    if (fn != NULL)\n      fn();\n  }\n}\nIf an attacker were to place a malicious DLL named MyLibrary.dll higher on the search path than where the library resides, she could trigger arbitrary code to execute either via the DllMain() entrypoint (which is called automatically by the system loader) or by providing an implementation for MyFunction(), either of which would run within the security context of your application. If your application runs with elevated privileges (such as a service application), an escalation of privileges could result.\nCompliant Solution\nBy refusing to load a library unless it is located precisely where expected, you reduce the chance of executing arbitrary code when dynamically loading libraries. This compliant solution uses LoadLibraryEx() to ensure that only the application and System32 directories are searched (eliminating other search paths such as the current directory or PATH environment variable):\n#include <Windows.h>\n \nvoid func(void) {\n  HMODULE hMod = LoadLibraryEx(TEXT(\"MyLibrary.dll\"), NULL,\n                               LOAD_LIBRARY_SEARCH_APPLICATION_DIR |\n                               LOAD_LIBRARY_SEARCH_SYSTEM32);\n  if (hMod != NULL) {\n    typedef void (__cdecl func_type)(void);\n    func_type *fn = (func_type *)GetProcAddress(hMod, \"MyFunction\");\n    if (fn != NULL)\n      fn();\n  }\n}\nRisk Assessment\nDepending on the version of Windows the application is run on, failure to properly specify the library can lead to arbitrary code execution.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nWIN00-C\nHigh\nUnlikely\nYes\nNo\nP6\nL2\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADFUNC.PATH.AFXLOADLIBRARY\nBADFUNC.PATH.COLOADLIBRARY\nBADFUNC.PATH.LOADLIBRARY\nUse of AfxLoadLibrary\nUse of CoLoadLibrary\nUse of LoadLibrary\nKlocwork\n2025.2\nSV.DLLPRELOAD.NONABSOLUTE.DLL\nSV.DLLPRELOAD.NONABSOLUTE.EXE\nSV.DLLPRELOAD.SEARCHPATH\nParasoft C/C++test\n2024.2\nCERT_C-WIN00-a\nUse care to ensure that LoadLibrary() will load the correct library\nPC-lint Plus\n1.4\n586\nFully supported\nPolyspace Bug Finder\nR2025b\nCERT C: Rec. WIN00-C\n\nChecks for:\nLoad of library from a relative path can be controlled by external actor\nLibrary loaded from externally controlled path.\nRec. partially covered.\nRelated Guidelines\n\n\nBibliography",
        "language": "C"
    },
    {
        "rule_id": "WIN02-C",
        "rule_title": "Restrict privileges when spawning child processes",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/WIN02-C.+Restrict+privileges+when+spawning+child+processes",
        "content": "The principle of least privilege states that every program and every user of the system should operate using the least set of privileges necessary to complete the job [Saltzer 1974, Saltzer 1975]. The Build Security In website [DHS 2006] provides additional definitions of this principle. Executing with minimal privileges mitigates against exploitation in case a vulnerability is discovered in the code.\nNoncompliant Code Example\nAn application may spawn another process as part of its normal course of action. On Windows, the newly-spawned process automatically receives the same privileges as the parent process [MSDN]. By allowing the child process to run in the same security context as the parent process, the attack surface for the application is extended to the child process. Furthermore, this example allows the child process to inherit handles from the parent process by passing TRUE to the bInheritsHandles parameter.\n#include <Windows.h>\n  void launch_notepad(void) {\n  PROCESS_INFORMATION pi;\n  STARTUPINFO si;\n    ZeroMemory(&si, sizeof(si));\n  si.cb = sizeof( si );\n  if (CreateProcess(TEXT(\"C:\\\\Windows\\\\Notepad.exe\"), NULL, NULL, NULL, TRUE,\n                    0, NULL, NULL, &si, &pi )) {\n    /* Process has been created; work with the process and wait for it to\n       terminate. */\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n  }\n}\nIt is possible that the act of calling launch_notepad() will give the user an elevated Notepad application (from which the user could execute Explorer.exe), allowing the user access to all user's files, change system settings, and so on.\nCompliant Solution\nBy using the Windows Integrity Mechanism [MSDN] when creating the process, you can assign an integrity level to the launched child process. Doing so allows you to execute the child process with a specific set of privileges instead of defaulting to the parent process's security level.\n#include <Windows.h>\n#include <sddl.h>\n  static void launch_notepad_as_user(HANDLE token) {\n  PROCESS_INFORMATION pi;\n  STARTUPINFO si;\n    ZeroMemory(&si, sizeof(si));\n  si.cb = sizeof( si );\n  if (CreateProcessAsUser(token, TEXT(\"C:\\\\Windows\\\\Notepad.exe\"), NULL, NULL,\n                          NULL, FALSE, 0, NULL, NULL, &si, &pi )) {\n    /* Process has been created; work with the process and wait for it to\n       terminate. */\n    WaitForSingleObject(pi.hProcess, INFINITE);\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n  }\n}\n  static BOOL adjust_token_integrity_level(HANDLE token, const char *sid) {\n  /* Convert the string SID to a SID *, then adjust the token's\n     privileges. */\n  BOOL ret;\n  PSID psd = NULL;\n  if (ConvertStringSidToSidA(sid, &psd)) {\n    TOKEN_MANDATORY_LABEL tml;\n         ZeroMemory(&tml, sizeof(tml));\n    tml.Label.Attributes = SE_GROUP_INTEGRITY;\n    tml.Label.Sid = psd;\n      ret = SetTokenInformation(token, TokenIntegrityLevel, &tml,\n                              sizeof(tml) + GetLengthSid(psd));\n         LocalFree(psd);\n  }\n  return ret;\n}\n  void launch_notepad(void) {\n  /* Low level; see table for integrity level string names */\n  const char *requested_sid = \"S-1-16-4096\";\n  HANDLE token_cur, token_dup;\n  /* Get the current process' security token as a starting point, then modify\n     a duplicate so that it runs with a fixed integrity level. */\n  if (OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE |\n                                            TOKEN_ADJUST_DEFAULT |\n                                            TOKEN_QUERY |\n                                            TOKEN_ASSIGN_PRIMARY,\n                                            &token_cur)) {\n    if (DuplicateTokenEx(token_cur, 0, NULL, SecurityImpersonation,\n                         TokenPrimary, &token_dup)) {\n      if (adjust_token_integrity_level(token_dup, requested_sid))\n        launch_notepad_as_user(token_dup);\n      CloseHandle(token_dup);\n    }\n    CloseHandle(token_cur);\n  }\n}\nThe compliant solution demonstrates how to launch notepad.exe using a low integrity level, regardless of what privilege level the parent process is running from. It also disallows handle inheritance by passing FALSE to the bInheritsHandles parameter, because notepad.exe does not require access to any of the process's handles.\nPossible values for the integrity level SID strings are listed in the following table:\nIntegrity level SID Name\nS-1-16-4096\nMandatory Label\\Low Mandatory Level\nS-1-16-8192\nMandatory Label\\Medium Mandatory Level\nS-1-16-12288\nMandatory Label\\High Mandatory Level\nS-1-16-16384\nMandatory Label\\System Mandatory Level\nRisk Assessment\nFailure to follow the principle of least privilege may allow exploits to execute with elevated privileges.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nWIN02-C\nHigh\nLikely\nYes\nNo\nP18\nL1\nAutomated Detection\nTool\nVersion\nChecker\nDescription\nCodeSonar\n9.1p0\nBADFUNC.CREATEPROCESS\nUse of CreateProcess\nPC-lint Plus\n1.4\n586\nFully supported\nSecurity Reviewer - Static Reviewer\n6.02\nUNSAFE_05\nFully implemented\nRelated Guidelines\nISO/IEC TR 24772 Adherence to Least Privilege [XYN]\nMITRE CWE CWE-250, Execution with unnecessary privileges\nCWE-272, Least privilege violation\nBibliography\n[Saltzer 1974]\n[Saltzer 1975]\n[DHS 2006] Least Privilege",
        "language": "C"
    },
    {
        "rule_id": "WIN03-C",
        "rule_title": "Understand HANDLE inheritance",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/WIN03-C.+Understand+HANDLE+inheritance",
        "content": "Securable resources such as access tokens, events, files, threads, and others are represented via HANDLE objects on Windows [MSDN]. Handle inheritance is a two-step process.  When obtaining a HANDLE, an option is given to specify whether the object is inheritable or not. This option is usually in the form of a BOOL parameter (as in the case of OpenMutex()), or a SECURITY_DESCRIPTOR parameter (as in the case of CreateFile()). When creating a process via the CreateProcess() family of APIs, a parameter is given specifying whether the spawned process will inherit handles previously flagged as being inheritable. Any handles that were opened as being inheritable will be opened in the child process using the same handle value and access privileges as in the parent process. The parent process can then alert the child process of the handle values via an inter-process communication mechanism, and the child process can use those values as though it had opened the handle [MSDN].\nWhen opening handles to securable resources or spawning child processes, prohibit handle inheritance by default to prevent accidental information leakage. If obtaining an inherited handle from a parent process, prevent leakage to subsequent child processes by duplicating the handle without inheritance.\nNoncompliant Code Example (Mutex)\nThis noncompliant code example attempts to open an existing mutex handle that can be inherited by a child process:\n#include <Windows.h>\n  void func(void) {\n  HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, TRUE, TEXT(\"Global\\\\CommonMutex\"));\n  if (!hMutex) {\n    /* Handle error */\n  }\n}\nEven if the process does not currently spawn child processes, this code example is noncompliant because future changes involving child processes could leak this handle accidentally.\nCompliant Solution (Mutex)\nThis compliant solution opens the same mutex without specifying the handle can be inherited by a child process:\n#include <Windows.h>\n  void func(void) {\n  HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, TEXT(\"Global\\\\CommonMutex\"));\n  if (!hMutex) {\n    /* Handle error */\n  }\n}\nNoncompliant Code Example (Further Inheritance)\nIn this noncompliant example, the child process is spawned and inherits a single file handle from its parent process. The first argument to the main function is the handle's integer value as a hexadecimal string. However, the child process is not validating that the handle is a valid file handle, and it is not restricting further inheritance of the handle. Additionally, a portability concern arises if the parent process and the child process are the same architecture (for example, if one is 32-bit and the other is 64-bit).\n#include <Windows.h>\n  int CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR cmdLine, int show) {\n  HANDLE hFile = (HANDLE)_strtoui64(cmdLine, NULL, 16);\n    /* Continue working with the file */\n}\nCompliant Solution (Further Inheritance)\nThis compliant solution receives the inherited handle via the command line but prevents further inheritance by duplicating the handle. It also ensures that the value passed is a valid HANDLE value. Then it validates the handle as a proper file handle by calling GetFileInformationByHandle(). This solution also properly handles cross-architecture situations between the processes.\n#include <Windows.h>\n  int CALLBACK WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR cmdLine, int show) {\n  HANDLE hUntrusted = (HANDLE)_strtoui64(cmdLine, NULL, 16);\n  HANDLE hFile = NULL;\n  BY_HANDLE_FILE_INFORMATION info;\n    if (!DuplicateHandle(GetCurrentProcess(), hUntrusted, GetCurrentProcess(), &hFile,\n                       0, FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE)) {\n    /* Handle error; possibly not even a valid handle */\n  }\n     if (!GetFileInformationByHandle(hFile, &info)) {\n    /* Handle error; likely not a valid file handle */\n      // Close the file handle since we no longer trust it.\n    CloseHandle(hFile);\n    hFile = NULL;\n  }\n     /* Continue working with the file */\n}\nNoncompliant Code Example (fopen())\nBy default, all files on Windows that are opened using fopen() will allow handle inheritance, and processes spawned via the system() API automatically inherit handles. In this noncompliant code example, SomeProcess.exe inherits the file handle for SomeFile.txt:\n#include <stdio.h>\n#include <stdlib.h>\n  int main(void) {\n  FILE *fp = fopen(\"SomeFile.txt\", \"rw\");\n  if (!fp) {\n    return -1;\n  }\n     system(\"SomeProcess.exe\");\n    fclose(fp);\n  return 0;\n}\nCompliant Solution (fopen())\nIn this compliant solution, the Windows-specific 'N' mode parameter is passed  to the call to fopen(), which ensures the file is opened without allowing handle inheritance:\n#include <stdio.h>\n#include <stdlib.h>\n  int main(void) {\n  FILE *fp = fopen(\"SomeFile.txt\", \"rwN\");\n  if (!fp) {\n    return -1;\n  }\n     system(\"SomeProcess.exe\");\n    fclose(fp);\n  return 0;\n}\nRisk Assessment\nLeaking handles across process boundaries can leak information or cause denial-of-service attacks.\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nWIN03-C\nHigh\nUnlikely\nNo\nNo\nP3\nL3\nRelated Guidelines\n\n\nBibliography",
        "language": "C"
    },
    {
        "rule_id": "WIN04-C",
        "rule_title": "Consider encrypting function pointers",
        "rule_link": "https://wiki.sei.cmu.edu/confluence/display/c/WIN04-C.+Consider+encrypting+function+pointers",
        "content": "If an attacker can overwrite memory containing function pointers, they may be able to execute arbitrary code. To mitigate the effects of such attacks, pointers to functions can be encrypted at runtime on the basis of some characteristics of the execution process so that only a running process will be able to decode them.  This is only required for stored function pointers stored to writable memory, including the stack.  The Microsoft SDL [Microsoft 2012] recommends encoding long-lived pointers in your code.\nNoncompliant Code Example\nThis noncompliant code example assigns the address of the printf() function to the log_fn function pointer, which can be allocated in the stack or data segment:\nint (*log_fn)(const char *, ...) = printf;\n/* ... */\nlog_fn(\"foo\");\nIf a vulnerability exists in this program that allows an attacker to overwrite the log_fn function pointer, such as a buffer overflow or arbitrary memory write, the attacker may be able to overwrite the value of printf with the location of an arbitrary function.\nCompliant Solution (Windows)\nMicrosoft Windows provides the EncodePointer() and DecodePointer() functions that encrypt and decrypt pointers using a secret that is unique to the given process:\n#include <Windows.h>\n  void *log_fn = EncodePointer(printf);\n/* ... */\nint (*fn)(const char *, ...) = (int (*)(const char *, ...))DecodePointer(log_fn);\n fn(\"foo\");\nNote that DecodePointer() does not return success or failure.  If an attacker has overwritten the pointer contained in log_fn, the pointer returned will be invalid and cause your application to crash.  However, this is preferable to giving an attacker the ability to execute arbitrary code. \nRisk Assessment\nRecommendation\nSeverity\nLikelihood\nDetectable\nRepairable\nPriority\nLevel\nWIN04-C\nHigh\nUnlikely\nNo\nNo\nP3\nL3\nRelated Vulnerabilities\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website.\nRelated Guidelines\nSEI CERT C++ Coding Standard VOID MSC16-CPP. Consider encrypting function pointers\nMITRE CWE CWE-311, Missing encryption of sensitive data\nCWE-319, Cleartext Transmission of Sensitive Information\nBibliography\n[MSDN] EncodePointer()\nDecodePointer()\nMicrosoft Corporation 2012\nMicrosoft Security Development Lifecycle (SDL) \u2013 version 5.2 Phase 3: Implementation",
        "language": "C"
    }
]